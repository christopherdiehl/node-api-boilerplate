/*!
 * finalhandler
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */

'use strict'

/**
 * Module dependencies.
 * @private
 */

var debug = require('debug')('finalhandler')
var escapeHtml = require('escape-html')
var onFinished = require('on-finished')
var statuses = require('statuses')
var unpipe = require('unpipe')

/**
 * Module variables.
 * @private
 */

/* istanbul ignore next */
var defer = typeof setImmediate === 'function'
  ? setImmediate
  : function (fn) ***REMOVED*** process.nextTick(fn.bind.apply(fn, arguments)) ***REMOVED***
var isFinished = onFinished.isFinished

/**
 * Module exports.
 * @public
 */

module.exports = finalhandler

/**
 * Create a function to handle the final response.
 *
 * @param ***REMOVED***Request***REMOVED*** req
 * @param ***REMOVED***Response***REMOVED*** res
 * @param ***REMOVED***Object***REMOVED*** [options]
 * @return ***REMOVED***Function***REMOVED***
 * @public
 */

function finalhandler (req, res, options) ***REMOVED***
  var opts = options || ***REMOVED******REMOVED***

  // get environment
  var env = opts.env || process.env.NODE_ENV || 'development'

  // get error callback
  var onerror = opts.onerror

  return function (err) ***REMOVED***
    var headers = Object.create(null)
    var status

    // ignore 404 on in-flight response
    if (!err && res._header) ***REMOVED***
      debug('cannot 404 after headers sent')
      return
    ***REMOVED***

    // unhandled error
    if (err) ***REMOVED***
      // respect status code from error
      status = getErrorStatusCode(err) || res.statusCode

      // default status code to 500 if outside valid range
      if (typeof status !== 'number' || status < 400 || status > 599) ***REMOVED***
        status = 500
      ***REMOVED***

      // respect err.headers
      if (err.headers && (err.status === status || err.statusCode === status)) ***REMOVED***
        var keys = Object.keys(err.headers)
        for (var i = 0; i < keys.length; i++) ***REMOVED***
          var key = keys[i]
          headers[key] = err.headers[key]
        ***REMOVED***
      ***REMOVED***

      // production gets a basic error message
      var msg = env === 'production'
        ? statuses[status]
        : err.stack || err.toString()
      msg = escapeHtml(msg)
        .replace(/\n/g, '<br>')
        .replace(/\x20***REMOVED***2***REMOVED***/g, ' &nbsp;') + '\n'
    ***REMOVED*** else ***REMOVED***
      status = 404
      msg = 'Cannot ' + escapeHtml(req.method) + ' ' + escapeHtml(req.originalUrl || req.url) + '\n'
    ***REMOVED***

    debug('default %s', status)

    // schedule onerror callback
    if (err && onerror) ***REMOVED***
      defer(onerror, err, req, res)
    ***REMOVED***

    // cannot actually respond
    if (res._header) ***REMOVED***
      debug('cannot %d after headers sent', status)
      req.socket.destroy()
      return
    ***REMOVED***

    // send response
    send(req, res, status, headers, msg)
  ***REMOVED***
***REMOVED***

/**
 * Get status code from Error object.
 *
 * @param ***REMOVED***Error***REMOVED*** err
 * @return ***REMOVED***number***REMOVED***
 * @private
 */

function getErrorStatusCode (err) ***REMOVED***
  // check err.status
  if (typeof err.status === 'number' && err.status >= 400 && err.status < 600) ***REMOVED***
    return err.status
  ***REMOVED***

  // check err.statusCode
  if (typeof err.statusCode === 'number' && err.statusCode >= 400 && err.statusCode < 600) ***REMOVED***
    return err.statusCode
  ***REMOVED***

  return undefined
***REMOVED***

/**
 * Send response.
 *
 * @param ***REMOVED***IncomingMessage***REMOVED*** req
 * @param ***REMOVED***OutgoingMessage***REMOVED*** res
 * @param ***REMOVED***number***REMOVED*** status
 * @param ***REMOVED***object***REMOVED*** headers
 * @param ***REMOVED***string***REMOVED*** body
 * @private
 */

function send (req, res, status, headers, body) ***REMOVED***
  function write () ***REMOVED***
    // response status
    res.statusCode = status
    res.statusMessage = statuses[status]

    // response headers
    var keys = Object.keys(headers)
    for (var i = 0; i < keys.length; i++) ***REMOVED***
      var key = keys[i]
      res.setHeader(key, headers[key])
    ***REMOVED***

    // security header for content sniffing
    res.setHeader('X-Content-Type-Options', 'nosniff')

    // standard headers
    res.setHeader('Content-Type', 'text/html; charset=utf-8')
    res.setHeader('Content-Length', Buffer.byteLength(body, 'utf8'))

    if (req.method === 'HEAD') ***REMOVED***
      res.end()
      return
    ***REMOVED***

    res.end(body, 'utf8')
  ***REMOVED***

  if (isFinished(req)) ***REMOVED***
    write()
    return
  ***REMOVED***

  // unpipe everything from the request
  unpipe(req)

  // flush the request
  onFinished(req, write)
  req.resume()
***REMOVED***
