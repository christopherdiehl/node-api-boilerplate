/*!
 * depd
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var callSiteToString = require('./lib/compat').callSiteToString
var eventListenerCount = require('./lib/compat').eventListenerCount
var relative = require('path').relative

/**
 * Module exports.
 */

module.exports = depd

/**
 * Get the path to base files on.
 */

var basePath = process.cwd()

/**
 * Determine if namespace is contained in the string.
 */

function containsNamespace(str, namespace) ***REMOVED***
  var val = str.split(/[ ,]+/)

  namespace = String(namespace).toLowerCase()

  for (var i = 0 ; i < val.length; i++) ***REMOVED***
    if (!(str = val[i])) continue;

    // namespace contained
    if (str === '*' || str.toLowerCase() === namespace) ***REMOVED***
      return true
    ***REMOVED***
  ***REMOVED***

  return false
***REMOVED***

/**
 * Convert a data descriptor to accessor descriptor.
 */

function convertDataDescriptorToAccessor(obj, prop, message) ***REMOVED***
  var descriptor = Object.getOwnPropertyDescriptor(obj, prop)
  var value = descriptor.value

  descriptor.get = function getter() ***REMOVED*** return value ***REMOVED***

  if (descriptor.writable) ***REMOVED***
    descriptor.set = function setter(val) ***REMOVED*** return value = val ***REMOVED***
  ***REMOVED***

  delete descriptor.value
  delete descriptor.writable

  Object.defineProperty(obj, prop, descriptor)

  return descriptor
***REMOVED***

/**
 * Create arguments string to keep arity.
 */

function createArgumentsString(arity) ***REMOVED***
  var str = ''

  for (var i = 0; i < arity; i++) ***REMOVED***
    str += ', arg' + i
  ***REMOVED***

  return str.substr(2)
***REMOVED***

/**
 * Create stack string from stack.
 */

function createStackString(stack) ***REMOVED***
  var str = this.name + ': ' + this.namespace

  if (this.message) ***REMOVED***
    str += ' deprecated ' + this.message
  ***REMOVED***

  for (var i = 0; i < stack.length; i++) ***REMOVED***
    str += '\n    at ' + callSiteToString(stack[i])
  ***REMOVED***

  return str
***REMOVED***

/**
 * Create deprecate for namespace in caller.
 */

function depd(namespace) ***REMOVED***
  if (!namespace) ***REMOVED***
    throw new TypeError('argument namespace is required')
  ***REMOVED***

  var stack = getStack()
  var site = callSiteLocation(stack[1])
  var file = site[0]

  function deprecate(message) ***REMOVED***
    // call to self as log
    log.call(deprecate, message)
  ***REMOVED***

  deprecate._file = file
  deprecate._ignored = isignored(namespace)
  deprecate._namespace = namespace
  deprecate._traced = istraced(namespace)
  deprecate._warned = Object.create(null)

  deprecate.function = wrapfunction
  deprecate.property = wrapproperty

  return deprecate
***REMOVED***

/**
 * Determine if namespace is ignored.
 */

function isignored(namespace) ***REMOVED***
  /* istanbul ignore next: tested in a child processs */
  if (process.noDeprecation) ***REMOVED***
    // --no-deprecation support
    return true
  ***REMOVED***

  var str = process.env.NO_DEPRECATION || ''

  // namespace ignored
  return containsNamespace(str, namespace)
***REMOVED***

/**
 * Determine if namespace is traced.
 */

function istraced(namespace) ***REMOVED***
  /* istanbul ignore next: tested in a child processs */
  if (process.traceDeprecation) ***REMOVED***
    // --trace-deprecation support
    return true
  ***REMOVED***

  var str = process.env.TRACE_DEPRECATION || ''

  // namespace traced
  return containsNamespace(str, namespace)
***REMOVED***

/**
 * Display deprecation message.
 */

function log(message, site) ***REMOVED***
  var haslisteners = eventListenerCount(process, 'deprecation') !== 0

  // abort early if no destination
  if (!haslisteners && this._ignored) ***REMOVED***
    return
  ***REMOVED***

  var caller
  var callFile
  var callSite
  var i = 0
  var seen = false
  var stack = getStack()
  var file = this._file

  if (site) ***REMOVED***
    // provided site
    callSite = callSiteLocation(stack[1])
    callSite.name = site.name
    file = callSite[0]
  ***REMOVED*** else ***REMOVED***
    // get call site
    i = 2
    site = callSiteLocation(stack[i])
    callSite = site
  ***REMOVED***

  // get caller of deprecated thing in relation to file
  for (; i < stack.length; i++) ***REMOVED***
    caller = callSiteLocation(stack[i])
    callFile = caller[0]

    if (callFile === file) ***REMOVED***
      seen = true
    ***REMOVED*** else if (callFile === this._file) ***REMOVED***
      file = this._file
    ***REMOVED*** else if (seen) ***REMOVED***
      break
    ***REMOVED***
  ***REMOVED***

  var key = caller
    ? site.join(':') + '__' + caller.join(':')
    : undefined

  if (key !== undefined && key in this._warned) ***REMOVED***
    // already warned
    return
  ***REMOVED***

  this._warned[key] = true

  // generate automatic message from call site
  if (!message) ***REMOVED***
    message = callSite === site || !callSite.name
      ? defaultMessage(site)
      : defaultMessage(callSite)
  ***REMOVED***

  // emit deprecation if listeners exist
  if (haslisteners) ***REMOVED***
    var err = DeprecationError(this._namespace, message, stack.slice(i))
    process.emit('deprecation', err)
    return
  ***REMOVED***

  // format and write message
  var format = process.stderr.isTTY
    ? formatColor
    : formatPlain
  var msg = format.call(this, message, caller, stack.slice(i))
  process.stderr.write(msg + '\n', 'utf8')

  return
***REMOVED***

/**
 * Get call site location as array.
 */

function callSiteLocation(callSite) ***REMOVED***
  var file = callSite.getFileName() || '<anonymous>'
  var line = callSite.getLineNumber()
  var colm = callSite.getColumnNumber()

  if (callSite.isEval()) ***REMOVED***
    file = callSite.getEvalOrigin() + ', ' + file
  ***REMOVED***

  var site = [file, line, colm]

  site.callSite = callSite
  site.name = callSite.getFunctionName()

  return site
***REMOVED***

/**
 * Generate a default message from the site.
 */

function defaultMessage(site) ***REMOVED***
  var callSite = site.callSite
  var funcName = site.name

  // make useful anonymous name
  if (!funcName) ***REMOVED***
    funcName = '<anonymous@' + formatLocation(site) + '>'
  ***REMOVED***

  var context = callSite.getThis()
  var typeName = context && callSite.getTypeName()

  // ignore useless type name
  if (typeName === 'Object') ***REMOVED***
    typeName = undefined
  ***REMOVED***

  // make useful type name
  if (typeName === 'Function') ***REMOVED***
    typeName = context.name || typeName
  ***REMOVED***

  return typeName && callSite.getMethodName()
    ? typeName + '.' + funcName
    : funcName
***REMOVED***

/**
 * Format deprecation message without color.
 */

function formatPlain(msg, caller, stack) ***REMOVED***
  var timestamp = new Date().toUTCString()

  var formatted = timestamp
    + ' ' + this._namespace
    + ' deprecated ' + msg

  // add stack trace
  if (this._traced) ***REMOVED***
    for (var i = 0; i < stack.length; i++) ***REMOVED***
      formatted += '\n    at ' + callSiteToString(stack[i])
    ***REMOVED***

    return formatted
  ***REMOVED***

  if (caller) ***REMOVED***
    formatted += ' at ' + formatLocation(caller)
  ***REMOVED***

  return formatted
***REMOVED***

/**
 * Format deprecation message with color.
 */

function formatColor(msg, caller, stack) ***REMOVED***
  var formatted = '\x1b[36;1m' + this._namespace + '\x1b[22;39m' // bold cyan
    + ' \x1b[33;1mdeprecated\x1b[22;39m' // bold yellow
    + ' \x1b[0m' + msg + '\x1b[39m' // reset

  // add stack trace
  if (this._traced) ***REMOVED***
    for (var i = 0; i < stack.length; i++) ***REMOVED***
      formatted += '\n    \x1b[36mat ' + callSiteToString(stack[i]) + '\x1b[39m' // cyan
    ***REMOVED***

    return formatted
  ***REMOVED***

  if (caller) ***REMOVED***
    formatted += ' \x1b[36m' + formatLocation(caller) + '\x1b[39m' // cyan
  ***REMOVED***

  return formatted
***REMOVED***

/**
 * Format call site location.
 */

function formatLocation(callSite) ***REMOVED***
  return relative(basePath, callSite[0])
    + ':' + callSite[1]
    + ':' + callSite[2]
***REMOVED***

/**
 * Get the stack as array of call sites.
 */

function getStack() ***REMOVED***
  var limit = Error.stackTraceLimit
  var obj = ***REMOVED******REMOVED***
  var prep = Error.prepareStackTrace

  Error.prepareStackTrace = prepareObjectStackTrace
  Error.stackTraceLimit = Math.max(10, limit)

  // capture the stack
  Error.captureStackTrace(obj)

  // slice this function off the top
  var stack = obj.stack.slice(1)

  Error.prepareStackTrace = prep
  Error.stackTraceLimit = limit

  return stack
***REMOVED***

/**
 * Capture call site stack from v8.
 */

function prepareObjectStackTrace(obj, stack) ***REMOVED***
  return stack
***REMOVED***

/**
 * Return a wrapped function in a deprecation message.
 */

function wrapfunction(fn, message) ***REMOVED***
  if (typeof fn !== 'function') ***REMOVED***
    throw new TypeError('argument fn must be a function')
  ***REMOVED***

  var args = createArgumentsString(fn.length)
  var deprecate = this
  var stack = getStack()
  var site = callSiteLocation(stack[1])

  site.name = fn.name

  var deprecatedfn = eval('(function (' + args + ') ***REMOVED***\n'
    + '"use strict"\n'
    + 'log.call(deprecate, message, site)\n'
    + 'return fn.apply(this, arguments)\n'
    + '***REMOVED***)')

  return deprecatedfn
***REMOVED***

/**
 * Wrap property in a deprecation message.
 */

function wrapproperty(obj, prop, message) ***REMOVED***
  if (!obj || (typeof obj !== 'object' && typeof obj !== 'function')) ***REMOVED***
    throw new TypeError('argument obj must be object')
  ***REMOVED***

  var descriptor = Object.getOwnPropertyDescriptor(obj, prop)

  if (!descriptor) ***REMOVED***
    throw new TypeError('must call property on owner object')
  ***REMOVED***

  if (!descriptor.configurable) ***REMOVED***
    throw new TypeError('property must be configurable')
  ***REMOVED***

  var deprecate = this
  var stack = getStack()
  var site = callSiteLocation(stack[1])

  // set site name
  site.name = prop

  // convert data descriptor
  if ('value' in descriptor) ***REMOVED***
    descriptor = convertDataDescriptorToAccessor(obj, prop, message)
  ***REMOVED***

  var get = descriptor.get
  var set = descriptor.set

  // wrap getter
  if (typeof get === 'function') ***REMOVED***
    descriptor.get = function getter() ***REMOVED***
      log.call(deprecate, message, site)
      return get.apply(this, arguments)
    ***REMOVED***
  ***REMOVED***

  // wrap setter
  if (typeof set === 'function') ***REMOVED***
    descriptor.set = function setter() ***REMOVED***
      log.call(deprecate, message, site)
      return set.apply(this, arguments)
    ***REMOVED***
  ***REMOVED***

  Object.defineProperty(obj, prop, descriptor)
***REMOVED***

/**
 * Create DeprecationError for deprecation
 */

function DeprecationError(namespace, message, stack) ***REMOVED***
  var error = new Error()
  var stackString

  Object.defineProperty(error, 'constructor', ***REMOVED***
    value: DeprecationError
  ***REMOVED***)

  Object.defineProperty(error, 'message', ***REMOVED***
    configurable: true,
    enumerable: false,
    value: message,
    writable: true
  ***REMOVED***)

  Object.defineProperty(error, 'name', ***REMOVED***
    enumerable: false,
    configurable: true,
    value: 'DeprecationError',
    writable: true
  ***REMOVED***)

  Object.defineProperty(error, 'namespace', ***REMOVED***
    configurable: true,
    enumerable: false,
    value: namespace,
    writable: true
  ***REMOVED***)

  Object.defineProperty(error, 'stack', ***REMOVED***
    configurable: true,
    enumerable: false,
    get: function () ***REMOVED***
      if (stackString !== undefined) ***REMOVED***
        return stackString
      ***REMOVED***

      // prepare stack trace
      return stackString = createStackString.call(this, stack)
    ***REMOVED***,
    set: function setter(val) ***REMOVED***
      stackString = val
    ***REMOVED***
  ***REMOVED***)

  return error
***REMOVED***
