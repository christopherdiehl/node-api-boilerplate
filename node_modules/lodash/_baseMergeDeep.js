var assignMergeValue = require('./_assignMergeValue'),
    cloneBuffer = require('./_cloneBuffer'),
    cloneTypedArray = require('./_cloneTypedArray'),
    copyArray = require('./_copyArray'),
    initCloneObject = require('./_initCloneObject'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray'),
    isArrayLikeObject = require('./isArrayLikeObject'),
    isBuffer = require('./isBuffer'),
    isFunction = require('./isFunction'),
    isObject = require('./isObject'),
    isPlainObject = require('./isPlainObject'),
    isTypedArray = require('./isTypedArray'),
    toPlainObject = require('./toPlainObject');

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param ***REMOVED***Object***REMOVED*** object The destination object.
 * @param ***REMOVED***Object***REMOVED*** source The source object.
 * @param ***REMOVED***string***REMOVED*** key The key of the value to merge.
 * @param ***REMOVED***number***REMOVED*** srcIndex The index of `source`.
 * @param ***REMOVED***Function***REMOVED*** mergeFunc The function to merge values.
 * @param ***REMOVED***Function***REMOVED*** [customizer] The function to customize assigned values.
 * @param ***REMOVED***Object***REMOVED*** [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) ***REMOVED***
  var objValue = object[key],
      srcValue = source[key],
      stacked = stack.get(srcValue);

  if (stacked) ***REMOVED***
    assignMergeValue(object, key, stacked);
    return;
  ***REMOVED***
  var newValue = customizer
    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
    : undefined;

  var isCommon = newValue === undefined;

  if (isCommon) ***REMOVED***
    var isArr = isArray(srcValue),
        isBuff = !isArr && isBuffer(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray(srcValue);

    newValue = srcValue;
    if (isArr || isBuff || isTyped) ***REMOVED***
      if (isArray(objValue)) ***REMOVED***
        newValue = objValue;
      ***REMOVED***
      else if (isArrayLikeObject(objValue)) ***REMOVED***
        newValue = copyArray(objValue);
      ***REMOVED***
      else if (isBuff) ***REMOVED***
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      ***REMOVED***
      else if (isTyped) ***REMOVED***
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      ***REMOVED***
      else ***REMOVED***
        newValue = [];
      ***REMOVED***
    ***REMOVED***
    else if (isPlainObject(srcValue) || isArguments(srcValue)) ***REMOVED***
      newValue = objValue;
      if (isArguments(objValue)) ***REMOVED***
        newValue = toPlainObject(objValue);
      ***REMOVED***
      else if (!isObject(objValue) || (srcIndex && isFunction(objValue))) ***REMOVED***
        newValue = initCloneObject(srcValue);
      ***REMOVED***
    ***REMOVED***
    else ***REMOVED***
      isCommon = false;
    ***REMOVED***
  ***REMOVED***
  if (isCommon) ***REMOVED***
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  ***REMOVED***
  assignMergeValue(object, key, newValue);
***REMOVED***

module.exports = baseMergeDeep;
