"use strict";

var EventEmitter = require('events').EventEmitter
  , inherits = require('util').inherits
  , getSingleProperty = require('./utils').getSingleProperty
  , shallowClone = require('./utils').shallowClone
  , parseIndexOptions = require('./utils').parseIndexOptions
  , debugOptions = require('./utils').debugOptions
  , CommandCursor = require('./command_cursor')
  , handleCallback = require('./utils').handleCallback
  , filterOptions = require('./utils').filterOptions
  , toError = require('./utils').toError
  , ReadPreference = require('./read_preference')
  , f = require('util').format
  , Admin = require('./admin')
  , Code = require('mongodb-core').BSON.Code
  , CoreReadPreference = require('mongodb-core').ReadPreference
  , MongoError = require('mongodb-core').MongoError
  , ObjectID = require('mongodb-core').ObjectID
  , Define = require('./metadata')
  , Logger = require('mongodb-core').Logger
  , Collection = require('./collection')
  , crypto = require('crypto')
  , assign = require('./utils').assign;

var debugFields = ['authSource', 'w', 'wtimeout', 'j', 'native_parser', 'forceServerObjectId'
  , 'serializeFunctions', 'raw', 'promoteLongs', 'promoteValues', 'promoteBuffers', 'bufferMaxEntries', 'numberOfRetries', 'retryMiliSeconds'
  , 'readPreference', 'pkFactory', 'parentDb', 'promiseLibrary', 'noListener'];

// Filter out any write concern options
var illegalCommandFields = ['w', 'wtimeout', 'j', 'fsync', 'autoIndexId'
  , 'strict', 'serializeFunctions', 'pkFactory', 'raw', 'readPreference'];

/**
 * @fileOverview The **Db** class is a class that represents a MongoDB Database.
 *
 * @example
 * var MongoClient = require('mongodb').MongoClient,
 *   test = require('assert');
 * // Connection url
 * var url = 'mongodb://localhost:27017/test';
 * // Connect using MongoClient
 * MongoClient.connect(url, function(err, db) ***REMOVED***
 *   // Get an additional db
 *   var testDb = db.db('test');
 *   db.close();
 * ***REMOVED***);
 */

// Allowed parameters
var legalOptionNames = ['w', 'wtimeout', 'fsync', 'j', 'readPreference', 'readPreferenceTags', 'native_parser'
  , 'forceServerObjectId', 'pkFactory', 'serializeFunctions', 'raw', 'bufferMaxEntries', 'authSource'
  , 'ignoreUndefined', 'promoteLongs', 'promiseLibrary', 'readConcern', 'retryMiliSeconds', 'numberOfRetries'
  , 'parentDb', 'noListener', 'loggerLevel', 'logger', 'promoteBuffers', 'promoteLongs', 'promoteValues'];

/**
 * Creates a new Db instance
 * @class
 * @param ***REMOVED***string***REMOVED*** databaseName The name of the database this instance represents.
 * @param ***REMOVED***(Server|ReplSet|Mongos)***REMOVED*** topology The server topology for the database.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***string***REMOVED*** [options.authSource=null] If the database authentication is dependent on another databaseName.
 * @param ***REMOVED***(number|string)***REMOVED*** [options.w=null] The write concern.
 * @param ***REMOVED***number***REMOVED*** [options.wtimeout=null] The write concern timeout.
 * @param ***REMOVED***boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param ***REMOVED***boolean***REMOVED*** [options.forceServerObjectId=false] Force server to assign _id values instead of driver.
 * @param ***REMOVED***boolean***REMOVED*** [options.serializeFunctions=false] Serialize functions on any object.
 * @param ***REMOVED***Boolean***REMOVED*** [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
 * @param ***REMOVED***boolean***REMOVED*** [options.raw=false] Return document results as raw BSON buffers.
 * @param ***REMOVED***boolean***REMOVED*** [options.promoteLongs=true] Promotes Long values to number if they fit inside the 53 bits resolution.
 * @param ***REMOVED***boolean***REMOVED*** [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.
 * @param ***REMOVED***boolean***REMOVED*** [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.
 * @param ***REMOVED***number***REMOVED*** [options.bufferMaxEntries=-1] Sets a cap on how many operations the driver will buffer up before giving up on getting a working connection, default is -1 which is unlimited.
 * @param ***REMOVED***(ReadPreference|string)***REMOVED*** [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param ***REMOVED***object***REMOVED*** [options.pkFactory=null] A primary key factory object for generation of custom _id keys.
 * @param ***REMOVED***object***REMOVED*** [options.promiseLibrary=null] A Promise library class the application wishes to use such as Bluebird, must be ES6 compatible
 * @param ***REMOVED***object***REMOVED*** [options.readConcern=null] Specify a read concern for the collection. (only MongoDB 3.2 or higher supported)
 * @param ***REMOVED***object***REMOVED*** [options.readConcern.level='local'] Specify a read concern level for the collection operations, one of [local|majority]. (only MongoDB 3.2 or higher supported)
 * @property ***REMOVED***(Server|ReplSet|Mongos)***REMOVED*** serverConfig Get the current db topology.
 * @property ***REMOVED***number***REMOVED*** bufferMaxEntries Current bufferMaxEntries value for the database
 * @property ***REMOVED***string***REMOVED*** databaseName The name of the database this instance represents.
 * @property ***REMOVED***object***REMOVED*** options The options associated with the db instance.
 * @property ***REMOVED***boolean***REMOVED*** native_parser The current value of the parameter native_parser.
 * @property ***REMOVED***boolean***REMOVED*** slaveOk The current slaveOk value for the db instance.
 * @property ***REMOVED***object***REMOVED*** writeConcern The current write concern values.
 * @property ***REMOVED***object***REMOVED*** topology Access the topology object (single server, replicaset or mongos).
 * @fires Db#close
 * @fires Db#authenticated
 * @fires Db#reconnect
 * @fires Db#error
 * @fires Db#timeout
 * @fires Db#parseError
 * @fires Db#fullsetup
 * @return ***REMOVED***Db***REMOVED*** a Db instance.
 */
var Db = function(databaseName, topology, options) ***REMOVED***
  options = options || ***REMOVED******REMOVED***;
  if(!(this instanceof Db)) return new Db(databaseName, topology, options);
  EventEmitter.call(this);
  var self = this;

  // Get the promiseLibrary
  var promiseLibrary = options.promiseLibrary;

  // No promise library selected fall back
  if(!promiseLibrary) ***REMOVED***
    promiseLibrary = typeof global.Promise == 'function' ?
      global.Promise : require('es6-promise').Promise;
  ***REMOVED***

  // Filter the options
  options = filterOptions(options, legalOptionNames);

  // Ensure we put the promiseLib in the options
  options.promiseLibrary = promiseLibrary;

  // var self = this;  // Internal state of the db object
  this.s = ***REMOVED***
    // Database name
      databaseName: databaseName
    // DbCache
    , dbCache: ***REMOVED******REMOVED***
    // Children db's
    , children: []
    // Topology
    , topology: topology
    // Options
    , options: options
    // Logger instance
    , logger: Logger('Db', options)
    // Get the bson parser
    , bson: topology ? topology.bson : null
    // Authsource if any
    , authSource: options.authSource
    // Unpack read preference
    , readPreference: options.readPreference
    // Set buffermaxEntries
    , bufferMaxEntries: typeof options.bufferMaxEntries == 'number' ? options.bufferMaxEntries : -1
    // Parent db (if chained)
    , parentDb: options.parentDb || null
    // Set up the primary key factory or fallback to ObjectID
    , pkFactory: options.pkFactory || ObjectID
    // Get native parser
    , nativeParser: options.nativeParser || options.native_parser
    // Promise library
    , promiseLibrary: promiseLibrary
    // No listener
    , noListener: typeof options.noListener == 'boolean' ? options.noListener : false
    // ReadConcern
    , readConcern: options.readConcern
  ***REMOVED***

  // Ensure we have a valid db name
  validateDatabaseName(self.s.databaseName);

  // Add a read Only property
  getSingleProperty(this, 'serverConfig', self.s.topology);
  getSingleProperty(this, 'bufferMaxEntries', self.s.bufferMaxEntries);
  getSingleProperty(this, 'databaseName', self.s.databaseName);

  // This is a child db, do not register any listeners
  if(options.parentDb) return;
  if(this.s.noListener) return;

  // Add listeners
  topology.on('error', createListener(self, 'error', self));
  topology.on('timeout', createListener(self, 'timeout', self));
  topology.on('close', createListener(self, 'close', self));
  topology.on('parseError', createListener(self, 'parseError', self));
  topology.once('open', createListener(self, 'open', self));
  topology.once('fullsetup', createListener(self, 'fullsetup', self));
  topology.once('all', createListener(self, 'all', self));
  topology.on('reconnect', createListener(self, 'reconnect', self));
***REMOVED***

inherits(Db, EventEmitter);

var define = Db.define = new Define('Db', Db, false);

// Topology
Object.defineProperty(Db.prototype, 'topology', ***REMOVED***
  enumerable:true,
  get: function() ***REMOVED*** return this.s.topology; ***REMOVED***
***REMOVED***);

// Options
Object.defineProperty(Db.prototype, 'options', ***REMOVED***
  enumerable:true,
  get: function() ***REMOVED*** return this.s.options; ***REMOVED***
***REMOVED***);

// slaveOk specified
Object.defineProperty(Db.prototype, 'slaveOk', ***REMOVED***
  enumerable:true,
  get: function() ***REMOVED***
    if(this.s.options.readPreference != null
      && (this.s.options.readPreference != 'primary' || this.s.options.readPreference.mode != 'primary')) ***REMOVED***
      return true;
    ***REMOVED***
    return false;
  ***REMOVED***
***REMOVED***);

// get the write Concern
Object.defineProperty(Db.prototype, 'writeConcern', ***REMOVED***
  enumerable:true,
  get: function() ***REMOVED***
    var ops = ***REMOVED******REMOVED***;
    if(this.s.options.w != null) ops.w = this.s.options.w;
    if(this.s.options.j != null) ops.j = this.s.options.j;
    if(this.s.options.fsync != null) ops.fsync = this.s.options.fsync;
    if(this.s.options.wtimeout != null) ops.wtimeout = this.s.options.wtimeout;
    return ops;
  ***REMOVED***
***REMOVED***);

/**
 * The callback format for the Db.open method
 * @callback Db~openCallback
 * @param ***REMOVED***MongoError***REMOVED*** error An error instance representing the error during the execution.
 * @param ***REMOVED***Db***REMOVED*** db The Db instance if the open method was successful.
 */

// Internal method
var open = function(self, callback) ***REMOVED***
  self.s.topology.connect(self, self.s.options, function(err) ***REMOVED***
    if(callback == null) return;
    var internalCallback = callback;
    callback == null;

    if(err) ***REMOVED***
      self.close();
      return internalCallback(err);
    ***REMOVED***

    internalCallback(null, self);
  ***REMOVED***);
***REMOVED***

/**
 * Open the database
 * @method
 * @param ***REMOVED***Db~openCallback***REMOVED*** [callback] Callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Db.prototype.open = function(callback) ***REMOVED***
  var self = this;
  // We provided a callback leg
  if(typeof callback == 'function') return open(self, callback);
  // Return promise
  return new self.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    open(self, function(err, db) ***REMOVED***
      if(err) return reject(err);
      resolve(db);
    ***REMOVED***)
  ***REMOVED***);
***REMOVED***

define.classMethod('open', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Converts provided read preference to CoreReadPreference
 * @param ***REMOVED***(ReadPreference|string|object)***REMOVED*** readPreference the user provided read preference
 * @return ***REMOVED***CoreReadPreference***REMOVED***
 */
var convertReadPreference = function(readPreference) ***REMOVED***
  if(readPreference && typeof readPreference == 'string') ***REMOVED***
    return new CoreReadPreference(readPreference);
  ***REMOVED*** else if(readPreference instanceof ReadPreference) ***REMOVED***
    return new CoreReadPreference(readPreference.mode, readPreference.tags, ***REMOVED***maxStalenessSeconds: readPreference.maxStalenessSeconds***REMOVED***);
  ***REMOVED*** else if(readPreference && typeof readPreference == 'object') ***REMOVED***
    var mode = readPreference.mode || readPreference.preference;
    if (mode && typeof mode == 'string') ***REMOVED***
      readPreference = new CoreReadPreference(mode, readPreference.tags, ***REMOVED***maxStalenessSeconds: readPreference.maxStalenessSeconds***REMOVED***);
    ***REMOVED***
  ***REMOVED***
  return readPreference;
***REMOVED***

/**
 * The callback format for results
 * @callback Db~resultCallback
 * @param ***REMOVED***MongoError***REMOVED*** error An error instance representing the error during the execution.
 * @param ***REMOVED***object***REMOVED*** result The result object if the command was executed successfully.
 */

var executeCommand = function(self, command, options, callback) ***REMOVED***
  // Did the user destroy the topology
  if(self.serverConfig && self.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed'));
  // Get the db name we are executing against
  var dbName = options.dbName || options.authdb || self.s.databaseName;

  // If we have a readPreference set
  if(options.readPreference == null && self.s.readPreference) ***REMOVED***
    options.readPreference = self.s.readPreference;
  ***REMOVED***

  // Convert the readPreference if its not a write
  if(options.readPreference) ***REMOVED***
    options.readPreference = convertReadPreference(options.readPreference);
  ***REMOVED*** else ***REMOVED***
    options.readPreference = CoreReadPreference.primary;
  ***REMOVED***

  // Debug information
  if(self.s.logger.isDebug()) self.s.logger.debug(f('executing command %s against %s with options [%s]'
    , JSON.stringify(command), f('%s.$cmd', dbName), JSON.stringify(debugOptions(debugFields, options))));

  // Execute command
  self.s.topology.command(f('%s.$cmd', dbName), command, options, function(err, result) ***REMOVED***
    if(err) return handleCallback(callback, err);
    if(options.full) return handleCallback(callback, null, result);
    handleCallback(callback, null, result.result);
  ***REMOVED***);
***REMOVED***

/**
 * Execute a command
 * @method
 * @param ***REMOVED***object***REMOVED*** command The command hash
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(ReadPreference|string)***REMOVED*** [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param ***REMOVED***Db~resultCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Db.prototype.command = function(command, options, callback) ***REMOVED***
  var self = this;
  // Change the callback
  if(typeof options == 'function') callback = options, options = ***REMOVED******REMOVED***;
  // Clone the options
  options = shallowClone(options);

  // Do we have a callback
  if(typeof callback == 'function') return executeCommand(self, command, options, callback);
  // Return a promise
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    executeCommand(self, command, options, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

define.classMethod('command', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * The callback format for results
 * @callback Db~noResultCallback
 * @param ***REMOVED***MongoError***REMOVED*** error An error instance representing the error during the execution.
 * @param ***REMOVED***null***REMOVED*** result Is not set to a value
 */

/**
 * Close the db and its underlying connections
 * @method
 * @param ***REMOVED***boolean***REMOVED*** force Force close, emitting no events
 * @param ***REMOVED***Db~noResultCallback***REMOVED*** [callback] The result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Db.prototype.close = function(force, callback) ***REMOVED***
  if(typeof force == 'function') callback = force, force = false;
  this.s.topology.close(force);
  var self = this;

  // Fire close event if any listeners
  if(this.listeners('close').length > 0) ***REMOVED***
    this.emit('close');

    // If it's the top level db emit close on all children
    if(this.parentDb == null) ***REMOVED***
      // Fire close on all children
      for(var i = 0; i < this.s.children.length; i++) ***REMOVED***
        this.s.children[i].emit('close');
      ***REMOVED***
    ***REMOVED***

    // Remove listeners after emit
    self.removeAllListeners('close');
  ***REMOVED***

  // Close parent db if set
  if(this.s.parentDb) this.s.parentDb.close();
  // Callback after next event loop tick
  if(typeof callback == 'function') return process.nextTick(function() ***REMOVED***
    handleCallback(callback, null);
  ***REMOVED***)

  // Return dummy promise
  return new this.s.promiseLibrary(function(resolve) ***REMOVED***
    resolve();
  ***REMOVED***);
***REMOVED***

define.classMethod('close', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Return the Admin db instance
 * @method
 * @return ***REMOVED***Admin***REMOVED*** return the new Admin db instance
 */
Db.prototype.admin = function() ***REMOVED***
  return new Admin(this, this.s.topology, this.s.promiseLibrary);
***REMOVED***;

define.classMethod('admin', ***REMOVED***callback: false, promise:false, returns: [Admin]***REMOVED***);

/**
 * The callback format for the collection method, must be used if strict is specified
 * @callback Db~collectionResultCallback
 * @param ***REMOVED***MongoError***REMOVED*** error An error instance representing the error during the execution.
 * @param ***REMOVED***Collection***REMOVED*** collection The collection instance.
 */

/**
 * Fetch a specific collection (containing the actual collection information). If the application does not use strict mode you can
 * can use it without a callback in the following way: `var collection = db.collection('mycollection');`
 *
 * @method
 * @param ***REMOVED***string***REMOVED*** name the collection name we wish to access.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(number|string)***REMOVED*** [options.w=null] The write concern.
 * @param ***REMOVED***number***REMOVED*** [options.wtimeout=null] The write concern timeout.
 * @param ***REMOVED***boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param ***REMOVED***boolean***REMOVED*** [options.raw=false] Return document results as raw BSON buffers.
 * @param ***REMOVED***object***REMOVED*** [options.pkFactory=null] A primary key factory object for generation of custom _id keys.
 * @param ***REMOVED***(ReadPreference|string)***REMOVED*** [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param ***REMOVED***boolean***REMOVED*** [options.serializeFunctions=false] Serialize functions on any object.
 * @param ***REMOVED***boolean***REMOVED*** [options.strict=false] Returns an error if the collection does not exist
 * @param ***REMOVED***object***REMOVED*** [options.readConcern=null] Specify a read concern for the collection. (only MongoDB 3.2 or higher supported)
 * @param ***REMOVED***object***REMOVED*** [options.readConcern.level='local'] Specify a read concern level for the collection operations, one of [local|majority]. (only MongoDB 3.2 or higher supported)
 * @param ***REMOVED***Db~collectionResultCallback***REMOVED*** callback The collection result callback
 * @return ***REMOVED***Collection***REMOVED*** return the new Collection instance if not in strict mode
 */
Db.prototype.collection = function(name, options, callback) ***REMOVED***
  var self = this;
  if(typeof options == 'function') callback = options, options = ***REMOVED******REMOVED***;
  options = options || ***REMOVED******REMOVED***;
  options = shallowClone(options);
  // Set the promise library
  options.promiseLibrary = this.s.promiseLibrary;

  // If we have not set a collection level readConcern set the db level one
  options.readConcern = options.readConcern || this.s.readConcern;

  // Do we have ignoreUndefined set
  if(this.s.options.ignoreUndefined) ***REMOVED***
    options.ignoreUndefined = this.s.options.ignoreUndefined;
  ***REMOVED***

  // Execute
  if(options == null || !options.strict) ***REMOVED***
    try ***REMOVED***
      var collection = new Collection(this, this.s.topology, this.s.databaseName, name, this.s.pkFactory, options);
      if(callback) callback(null, collection);
      return collection;
    ***REMOVED*** catch(err) ***REMOVED***
      if(callback) return callback(err);
      throw err;
    ***REMOVED***
  ***REMOVED***

  // Strict mode
  if(typeof callback != 'function') ***REMOVED***
    throw toError(f("A callback is required in strict mode. While getting collection %s.", name));
  ***REMOVED***

  // Did the user destroy the topology
  if(self.serverConfig && self.serverConfig.isDestroyed()) ***REMOVED***
    return callback(new MongoError('topology was destroyed'));
  ***REMOVED***

  // Strict mode
  this.listCollections(***REMOVED***name:name***REMOVED***).toArray(function(err, collections) ***REMOVED***
    if(err != null) return handleCallback(callback, err, null);
    if(collections.length == 0) return handleCallback(callback, toError(f("Collection %s does not exist. Currently in strict mode.", name)), null);

    try ***REMOVED***
      return handleCallback(callback, null, new Collection(self, self.s.topology, self.s.databaseName, name, self.s.pkFactory, options));
    ***REMOVED*** catch(err) ***REMOVED***
      return handleCallback(callback, err, null);
    ***REMOVED***
  ***REMOVED***);
***REMOVED***

define.classMethod('collection', ***REMOVED***callback: true, promise:false, returns: [Collection]***REMOVED***);

function decorateWithWriteConcern(command, self, options) ***REMOVED***
  // Do we support write concerns 3.4 and higher
  if(self.s.topology.capabilities().commandsTakeWriteConcern) ***REMOVED***
    // Get the write concern settings
    var finalOptions = writeConcern(shallowClone(options), self, options);
    // Add the write concern to the command
    if(finalOptions.writeConcern) ***REMOVED***
      command.writeConcern = finalOptions.writeConcern;
    ***REMOVED***
  ***REMOVED***
***REMOVED***

var createCollection = function(self, name, options, callback) ***REMOVED***
  // Get the write concern options
  var finalOptions = writeConcern(shallowClone(options), self, options);
  // Did the user destroy the topology
  if(self.serverConfig && self.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed'));
  // Check if we have the name
  self.listCollections(***REMOVED***name: name***REMOVED***)
    .setReadPreference(ReadPreference.PRIMARY)
    .toArray(function(err, collections) ***REMOVED***
      if(err != null) return handleCallback(callback, err, null);
      if(collections.length > 0 && finalOptions.strict) ***REMOVED***
        return handleCallback(callback, MongoError.create(***REMOVED***message: f("Collection %s already exists. Currently in strict mode.", name), driver:true***REMOVED***), null);
      ***REMOVED*** else if (collections.length > 0) ***REMOVED***
        try ***REMOVED*** return handleCallback(callback, null, new Collection(self, self.s.topology, self.s.databaseName, name, self.s.pkFactory, options)); ***REMOVED***
        catch(err) ***REMOVED*** return handleCallback(callback, err); ***REMOVED***
      ***REMOVED***

      // Create collection command
      var cmd = ***REMOVED***'create':name***REMOVED***;

      // Decorate command with writeConcern if supported
      decorateWithWriteConcern(cmd, self, options);
      // Add all optional parameters
      for(var n in options) ***REMOVED***
        if(options[n] != null
          && typeof options[n] != 'function' && illegalCommandFields.indexOf(n) == -1) ***REMOVED***
            cmd[n] = options[n];
        ***REMOVED***
      ***REMOVED***

      // Force a primary read Preference
      finalOptions.readPreference = ReadPreference.PRIMARY;

      // Execute command
      self.command(cmd, finalOptions, function(err) ***REMOVED***
        if(err) return handleCallback(callback, err);
        handleCallback(callback, null, new Collection(self, self.s.topology, self.s.databaseName, name, self.s.pkFactory, options));
      ***REMOVED***);
  ***REMOVED***);
***REMOVED***

/**
 * Create a new collection on a server with the specified options. Use this to create capped collections.
 *
 * @method
 * @param ***REMOVED***string***REMOVED*** name the collection name we wish to access.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(number|string)***REMOVED*** [options.w=null] The write concern.
 * @param ***REMOVED***number***REMOVED*** [options.wtimeout=null] The write concern timeout.
 * @param ***REMOVED***boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param ***REMOVED***boolean***REMOVED*** [options.raw=false] Return document results as raw BSON buffers.
 * @param ***REMOVED***object***REMOVED*** [options.pkFactory=null] A primary key factory object for generation of custom _id keys.
 * @param ***REMOVED***(ReadPreference|string)***REMOVED*** [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param ***REMOVED***boolean***REMOVED*** [options.serializeFunctions=false] Serialize functions on any object.
 * @param ***REMOVED***boolean***REMOVED*** [options.strict=false] Returns an error if the collection does not exist
 * @param ***REMOVED***boolean***REMOVED*** [options.capped=false] Create a capped collection.
 * @param ***REMOVED***number***REMOVED*** [options.size=null] The size of the capped collection in bytes.
 * @param ***REMOVED***number***REMOVED*** [options.max=null] The maximum number of documents in the capped collection.
 * @param ***REMOVED***boolean***REMOVED*** [options.autoIndexId=true] Create an index on the _id field of the document, True by default on MongoDB 2.2 or higher off for version < 2.2.
 * @param ***REMOVED***object***REMOVED*** [options.collation=null] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).
 * @param ***REMOVED***Db~collectionResultCallback***REMOVED*** [callback] The results callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Db.prototype.createCollection = function(name, options, callback) ***REMOVED***
  var self = this;
  var args = Array.prototype.slice.call(arguments, 0);
  callback = args.pop();
  if(typeof callback != 'function') args.push(callback);
  name = args.length ? args.shift() : null;
  options = args.length ? args.shift() || ***REMOVED******REMOVED*** : ***REMOVED******REMOVED***;

  // Do we have a promisesLibrary
  options.promiseLibrary = options.promiseLibrary || this.s.promiseLibrary;

  // Check if the callback is in fact a string
  if(typeof callback == 'string') name = callback;

  // Execute the fallback callback
  if(typeof callback == 'function') return createCollection(self, name, options, callback);
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    createCollection(self, name, options, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

define.classMethod('createCollection', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Get all the db statistics.
 *
 * @method
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***number***REMOVED*** [options.scale=null] Divide the returned sizes by scale value.
 * @param ***REMOVED***Db~resultCallback***REMOVED*** [callback] The collection result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Db.prototype.stats = function(options, callback) ***REMOVED***
  if(typeof options == 'function') callback = options, options = ***REMOVED******REMOVED***;
  options = options || ***REMOVED******REMOVED***;
  // Build command object
  var commandObject = ***REMOVED*** dbStats:true ***REMOVED***;
  // Check if we have the scale value
  if(options['scale'] != null) commandObject['scale'] = options['scale'];

  // If we have a readPreference set
  if(options.readPreference == null && this.s.readPreference) ***REMOVED***
    options.readPreference = this.s.readPreference;
  ***REMOVED***

  // Execute the command
  return this.command(commandObject, options, callback);
***REMOVED***

define.classMethod('stats', ***REMOVED***callback: true, promise:true***REMOVED***);

// Transformation methods for cursor results
var listCollectionsTranforms = function(databaseName) ***REMOVED***
  var matching = f('%s.', databaseName);

  return ***REMOVED***
    doc: function(doc) ***REMOVED***
      var index = doc.name.indexOf(matching);
      // Remove database name if available
      if(doc.name && index == 0) ***REMOVED***
        doc.name = doc.name.substr(index + matching.length);
      ***REMOVED***

      return doc;
    ***REMOVED***
  ***REMOVED***
***REMOVED***

/**
 * Get the list of all collection information for the specified db.
 *
 * @method
 * @param ***REMOVED***object***REMOVED*** filter Query to filter collections by
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***number***REMOVED*** [options.batchSize=null] The batchSize for the returned command cursor or if pre 2.8 the systems batch collection
 * @param ***REMOVED***(ReadPreference|string)***REMOVED*** [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @return ***REMOVED***CommandCursor***REMOVED***
 */
Db.prototype.listCollections = function(filter, options) ***REMOVED***
  filter = filter || ***REMOVED******REMOVED***;
  options = options || ***REMOVED******REMOVED***;

  // Shallow clone the object
  options = shallowClone(options);
  // Set the promise library
  options.promiseLibrary = this.s.promiseLibrary;

  // Ensure valid readPreference
  if(options.readPreference) ***REMOVED***
    options.readPreference = convertReadPreference(options.readPreference);
  ***REMOVED***

  // We have a list collections command
  if(this.serverConfig.capabilities().hasListCollectionsCommand) ***REMOVED***
    // Cursor options
    var cursor = options.batchSize ? ***REMOVED***batchSize: options.batchSize***REMOVED*** : ***REMOVED******REMOVED***
    // Build the command
    var command = ***REMOVED*** listCollections : true, filter: filter, cursor: cursor ***REMOVED***;
    // Set the AggregationCursor constructor
    options.cursorFactory = CommandCursor;
    // Create the cursor
    cursor = this.s.topology.cursor(f('%s.$cmd', this.s.databaseName), command, options);
    // Do we have a readPreference, apply it
    if(options.readPreference) ***REMOVED***
      cursor.setReadPreference(options.readPreference);
    ***REMOVED***
    // Return the cursor
    return cursor;
  ***REMOVED***

  // We cannot use the listCollectionsCommand
  if(!this.serverConfig.capabilities().hasListCollectionsCommand) ***REMOVED***
    // If we have legacy mode and have not provided a full db name filter it
    if(typeof filter.name == 'string' && !(new RegExp('^' + this.databaseName + '\\.').test(filter.name))) ***REMOVED***
      filter = shallowClone(filter);
      filter.name = f('%s.%s', this.s.databaseName, filter.name);
    ***REMOVED***
  ***REMOVED***

  // No filter, filter by current database
  if(filter == null) ***REMOVED***
    filter.name = f('/%s/', this.s.databaseName);
  ***REMOVED***

  // Rewrite the filter to use $and to filter out indexes
  if(filter.name) ***REMOVED***
    filter = ***REMOVED***$and: [***REMOVED***name: filter.name***REMOVED***, ***REMOVED***name:/^((?!\$).)*$/***REMOVED***]***REMOVED***;
  ***REMOVED*** else ***REMOVED***
    filter = ***REMOVED***name:/^((?!\$).)*$/***REMOVED***;
  ***REMOVED***

  // Return options
  var _options = ***REMOVED***transforms: listCollectionsTranforms(this.s.databaseName)***REMOVED***
  // Get the cursor
  cursor = this.collection(Db.SYSTEM_NAMESPACE_COLLECTION).find(filter, _options);
  // Do we have a readPreference, apply it
  if(options.readPreference) cursor.setReadPreference(options.readPreference);
  // Set the passed in batch size if one was provided
  if(options.batchSize) cursor = cursor.batchSize(options.batchSize);
  // We have a fallback mode using legacy systems collections
  return cursor;
***REMOVED***;

define.classMethod('listCollections', ***REMOVED***callback: false, promise:false, returns: [CommandCursor]***REMOVED***);

var evaluate = function(self, code, parameters, options, callback) ***REMOVED***
  var finalCode = code;
  var finalParameters = [];

  // Did the user destroy the topology
  if(self.serverConfig && self.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed'));

  // If not a code object translate to one
  if(!(finalCode && finalCode._bsontype == 'Code')) finalCode = new Code(finalCode);
  // Ensure the parameters are correct
  if(parameters != null && !Array.isArray(parameters) && typeof parameters !== 'function') ***REMOVED***
    finalParameters = [parameters];
  ***REMOVED*** else if(parameters != null && Array.isArray(parameters) && typeof parameters !== 'function') ***REMOVED***
    finalParameters = parameters;
  ***REMOVED***

  // Create execution selector
  var cmd = ***REMOVED***'$eval':finalCode, 'args':finalParameters***REMOVED***;
  // Check if the nolock parameter is passed in
  if(options['nolock']) ***REMOVED***
    cmd['nolock'] = options['nolock'];
  ***REMOVED***

  // Set primary read preference
  options.readPreference = new CoreReadPreference(ReadPreference.PRIMARY);

  // Execute the command
  self.command(cmd, options, function(err, result) ***REMOVED***
    if(err) return handleCallback(callback, err, null);
    if(result && result.ok == 1) return handleCallback(callback, null, result.retval);
    if(result) return handleCallback(callback, MongoError.create(***REMOVED***message: f("eval failed: %s", result.errmsg), driver:true***REMOVED***), null);
    handleCallback(callback, err, result);
  ***REMOVED***);
***REMOVED***

/**
 * Evaluate JavaScript on the server
 *
 * @method
 * @param ***REMOVED***Code***REMOVED*** code JavaScript to execute on server.
 * @param ***REMOVED***(object|array)***REMOVED*** parameters The parameters for the call.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***boolean***REMOVED*** [options.nolock=false] Tell MongoDB not to block on the evaulation of the javascript.
 * @param ***REMOVED***Db~resultCallback***REMOVED*** [callback] The results callback
 * @deprecated Eval is deprecated on MongoDB 3.2 and forward
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Db.prototype.eval = function(code, parameters, options, callback) ***REMOVED***
  var self = this;
  var args = Array.prototype.slice.call(arguments, 1);
  callback = args.pop();
  if(typeof callback != 'function') args.push(callback);
  parameters = args.length ? args.shift() : parameters;
  options = args.length ? args.shift() || ***REMOVED******REMOVED*** : ***REMOVED******REMOVED***;

  // Check if the callback is in fact a string
  if(typeof callback == 'function') return evaluate(self, code, parameters, options, callback);
  // Execute the command
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    evaluate(self, code, parameters, options, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***;

define.classMethod('eval', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Rename a collection.
 *
 * @method
 * @param ***REMOVED***string***REMOVED*** fromCollection Name of current collection to rename.
 * @param ***REMOVED***string***REMOVED*** toCollection New name of of the collection.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***boolean***REMOVED*** [options.dropTarget=false] Drop the target name collection if it previously exists.
 * @param ***REMOVED***Db~collectionResultCallback***REMOVED*** [callback] The results callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Db.prototype.renameCollection = function(fromCollection, toCollection, options, callback) ***REMOVED***
  var self = this;
  if(typeof options == 'function') callback = options, options = ***REMOVED******REMOVED***;
  options = options || ***REMOVED******REMOVED***;
  // Add return new collection
  options.new_collection = true;

  // Check if the callback is in fact a string
  if(typeof callback == 'function') ***REMOVED***
    return this.collection(fromCollection).rename(toCollection, options, callback);
  ***REMOVED***

  // Return a promise
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    self.collection(fromCollection).rename(toCollection, options, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***;

define.classMethod('renameCollection', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Drop a collection from the database, removing it permanently. New accesses will create a new collection.
 *
 * @method
 * @param ***REMOVED***string***REMOVED*** name Name of collection to drop
 * @param ***REMOVED***Db~resultCallback***REMOVED*** [callback] The results callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Db.prototype.dropCollection = function(name, options, callback) ***REMOVED***
  var self = this;
  if(typeof options == 'function') callback = options, options = ***REMOVED******REMOVED***;
  options = options || ***REMOVED******REMOVED***;

  // Command to execute
  var cmd = ***REMOVED***'drop':name***REMOVED***

  // Decorate with write concern
  decorateWithWriteConcern(cmd, self, options);

  // options
  options = assign(***REMOVED******REMOVED***, this.s.options, ***REMOVED***readPreference: ReadPreference.PRIMARY***REMOVED***);

  // Check if the callback is in fact a string
  if(typeof callback == 'function') return this.command(cmd, options, function(err, result) ***REMOVED***
    // Did the user destroy the topology
    if(self.serverConfig && self.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed'));
    if(err) return handleCallback(callback, err);
    if(result.ok) return handleCallback(callback, null, true);
    handleCallback(callback, null, false);
  ***REMOVED***);

  // Clone the options
  options = shallowClone(self.s.options);
  // Set readPreference PRIMARY
  options.readPreference = ReadPreference.PRIMARY;

  // Execute the command
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    // Execute command
    self.command(cmd, options, function(err, result) ***REMOVED***
      // Did the user destroy the topology
      if(self.serverConfig && self.serverConfig.isDestroyed()) return reject(new MongoError('topology was destroyed'));
      if(err) return reject(err);
      if(result.ok) return resolve(true);
      resolve(false);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***;

define.classMethod('dropCollection', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Drop a database, removing it permanently from the server.
 *
 * @method
 * @param ***REMOVED***Db~resultCallback***REMOVED*** [callback] The results callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Db.prototype.dropDatabase = function(options, callback) ***REMOVED***
  var self = this;
  if(typeof options == 'function') callback = options, options = ***REMOVED******REMOVED***;
  options = options || ***REMOVED******REMOVED***;
  // Drop database command
  var cmd = ***REMOVED***'dropDatabase':1***REMOVED***;

  // Decorate with write concern
  decorateWithWriteConcern(cmd, self, options);

  // Ensure primary only
  options = assign(***REMOVED******REMOVED***, this.s.options, ***REMOVED***readPreference: ReadPreference.PRIMARY***REMOVED***);

  // Check if the callback is in fact a string
  if(typeof callback == 'function') return this.command(cmd, options, function(err, result) ***REMOVED***
    // Did the user destroy the topology
    if(self.serverConfig && self.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed'));
    if(callback == null) return;
    if(err) return handleCallback(callback, err, null);
    handleCallback(callback, null, result.ok ? true : false);
  ***REMOVED***);

  // Execute the command
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    // Execute command
    self.command(cmd, options, function(err, result) ***REMOVED***
      // Did the user destroy the topology
      if(self.serverConfig && self.serverConfig.isDestroyed()) return reject(new MongoError('topology was destroyed'));
      if(err) return reject(err);
      if(result.ok) return resolve(true);
      resolve(false);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

define.classMethod('dropDatabase', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * The callback format for the collections method.
 * @callback Db~collectionsResultCallback
 * @param ***REMOVED***MongoError***REMOVED*** error An error instance representing the error during the execution.
 * @param ***REMOVED***Collection[]***REMOVED*** collections An array of all the collections objects for the db instance.
 */
var collections = function(self, callback) ***REMOVED***
  // Let's get the collection names
  self.listCollections().toArray(function(err, documents) ***REMOVED***
    if(err != null) return handleCallback(callback, err, null);
    // Filter collections removing any illegal ones
    documents = documents.filter(function(doc) ***REMOVED***
      return doc.name.indexOf('$') == -1;
    ***REMOVED***);

    // Return the collection objects
    handleCallback(callback, null, documents.map(function(d) ***REMOVED***
      return new Collection(self, self.s.topology, self.s.databaseName, d.name.replace(self.s.databaseName + ".", ''), self.s.pkFactory, self.s.options);
    ***REMOVED***));
  ***REMOVED***);
***REMOVED***

/**
 * Fetch all collections for the current db.
 *
 * @method
 * @param ***REMOVED***Db~collectionsResultCallback***REMOVED*** [callback] The results callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Db.prototype.collections = function(callback) ***REMOVED***
  var self = this;

  // Return the callback
  if(typeof callback == 'function') return collections(self, callback);
  // Return the promise
  return new self.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    collections(self, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***;

define.classMethod('collections', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Runs a command on the database as admin.
 * @method
 * @param ***REMOVED***object***REMOVED*** command The command hash
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(ReadPreference|string)***REMOVED*** [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param ***REMOVED***Db~resultCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Db.prototype.executeDbAdminCommand = function(selector, options, callback) ***REMOVED***
  var self = this;
  if(typeof options == 'function') callback = options, options = ***REMOVED******REMOVED***;
  options = options || ***REMOVED******REMOVED***;

  // Return the callback
  if(typeof callback == 'function') ***REMOVED***
    // Convert read preference
    if(options.readPreference) ***REMOVED***
      options.readPreference = convertReadPreference(options.readPreference)
    ***REMOVED***

    return self.s.topology.command('admin.$cmd', selector, options, function(err, result) ***REMOVED***
      // Did the user destroy the topology
      if(self.serverConfig && self.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed'));
      if(err) return handleCallback(callback, err);
      handleCallback(callback, null, result.result);
    ***REMOVED***);
  ***REMOVED***

  // Return promise
  return new self.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    self.s.topology.command('admin.$cmd', selector, options, function(err, result) ***REMOVED***
      // Did the user destroy the topology
      if(self.serverConfig && self.serverConfig.isDestroyed()) return reject(new MongoError('topology was destroyed'));
      if(err) return reject(err);
      resolve(result.result);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***;

define.classMethod('executeDbAdminCommand', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Creates an index on the db and collection collection.
 * @method
 * @param ***REMOVED***string***REMOVED*** name Name of the collection to create the index on.
 * @param ***REMOVED***(string|object)***REMOVED*** fieldOrSpec Defines the index.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(number|string)***REMOVED*** [options.w=null] The write concern.
 * @param ***REMOVED***number***REMOVED*** [options.wtimeout=null] The write concern timeout.
 * @param ***REMOVED***boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param ***REMOVED***boolean***REMOVED*** [options.unique=false] Creates an unique index.
 * @param ***REMOVED***boolean***REMOVED*** [options.sparse=false] Creates a sparse index.
 * @param ***REMOVED***boolean***REMOVED*** [options.background=false] Creates the index in the background, yielding whenever possible.
 * @param ***REMOVED***boolean***REMOVED*** [options.dropDups=false] A unique index cannot be created on a key that has pre-existing duplicate values. If you would like to create the index anyway, keeping the first document the database indexes and deleting all subsequent documents that have duplicate value
 * @param ***REMOVED***number***REMOVED*** [options.min=null] For geospatial indexes set the lower bound for the co-ordinates.
 * @param ***REMOVED***number***REMOVED*** [options.max=null] For geospatial indexes set the high bound for the co-ordinates.
 * @param ***REMOVED***number***REMOVED*** [options.v=null] Specify the format version of the indexes.
 * @param ***REMOVED***number***REMOVED*** [options.expireAfterSeconds=null] Allows you to expire data on indexes applied to a data (MongoDB 2.2 or higher)
 * @param ***REMOVED***number***REMOVED*** [options.name=null] Override the autogenerated index name (useful if the resulting name is larger than 128 bytes)
 * @param ***REMOVED***object***REMOVED*** [options.partialFilterExpression=null] Creates a partial index based on the given filter object (MongoDB 3.2 or higher)
 * @param ***REMOVED***Db~resultCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Db.prototype.createIndex = function(name, fieldOrSpec, options, callback) ***REMOVED***
  var self = this;
  var args = Array.prototype.slice.call(arguments, 2);
  callback = args.pop();
  if(typeof callback != 'function') args.push(callback);
  options = args.length ? args.shift() || ***REMOVED******REMOVED*** : ***REMOVED******REMOVED***;
  options = typeof callback === 'function' ? options : callback;
  options = options == null ? ***REMOVED******REMOVED*** : options;
  // Shallow clone the options
  options = shallowClone(options);
  // Run only against primary
  options.readPreference = ReadPreference.PRIMARY;

  // If we have a callback fallback
  if(typeof callback == 'function') return createIndex(self, name, fieldOrSpec, options, callback);
  // Return a promise
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    createIndex(self, name, fieldOrSpec, options, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***;

var createIndex = function(self, name, fieldOrSpec, options, callback) ***REMOVED***
  // Get the write concern options
  var finalOptions = writeConcern(***REMOVED******REMOVED***, self, options);
  // Ensure we have a callback
  if(finalOptions.writeConcern && typeof callback != 'function') ***REMOVED***
    throw MongoError.create(***REMOVED***message: "Cannot use a writeConcern without a provided callback", driver:true***REMOVED***);
  ***REMOVED***

  // Did the user destroy the topology
  if(self.serverConfig && self.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed'));

  // Attempt to run using createIndexes command
  createIndexUsingCreateIndexes(self, name, fieldOrSpec, options, function(err, result) ***REMOVED***
    if(err == null) return handleCallback(callback, err, result);

    // 67 = 'CannotCreateIndex' (malformed index options)
    // 85 = 'IndexOptionsConflict' (index already exists with different options)
    // 11000 = 'DuplicateKey' (couldn't build unique index because of dupes)
    // These errors mean that the server recognized `createIndex` as a command
    // and so we don't need to fallback to an insert.
    if(err.code === 67 || err.code == 11000 || err.code === 85) ***REMOVED***
      return handleCallback(callback, err, result);
    ***REMOVED***

    // Create command
    var doc = createCreateIndexCommand(self, name, fieldOrSpec, options);
    // Set no key checking
    finalOptions.checkKeys = false;
    // Insert document
    self.s.topology.insert(f("%s.%s", self.s.databaseName, Db.SYSTEM_INDEX_COLLECTION), doc, finalOptions, function(err, result) ***REMOVED***
      if(callback == null) return;
      if(err) return handleCallback(callback, err);
      if(result == null) return handleCallback(callback, null, null);
      if(result.result.writeErrors) return handleCallback(callback, MongoError.create(result.result.writeErrors[0]), null);
      handleCallback(callback, null, doc.name);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

define.classMethod('createIndex', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Ensures that an index exists, if it does not it creates it
 * @method
 * @deprecated since version 2.0
 * @param ***REMOVED***string***REMOVED*** name The index name
 * @param ***REMOVED***(string|object)***REMOVED*** fieldOrSpec Defines the index.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(number|string)***REMOVED*** [options.w=null] The write concern.
 * @param ***REMOVED***number***REMOVED*** [options.wtimeout=null] The write concern timeout.
 * @param ***REMOVED***boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param ***REMOVED***boolean***REMOVED*** [options.unique=false] Creates an unique index.
 * @param ***REMOVED***boolean***REMOVED*** [options.sparse=false] Creates a sparse index.
 * @param ***REMOVED***boolean***REMOVED*** [options.background=false] Creates the index in the background, yielding whenever possible.
 * @param ***REMOVED***boolean***REMOVED*** [options.dropDups=false] A unique index cannot be created on a key that has pre-existing duplicate values. If you would like to create the index anyway, keeping the first document the database indexes and deleting all subsequent documents that have duplicate value
 * @param ***REMOVED***number***REMOVED*** [options.min=null] For geospatial indexes set the lower bound for the co-ordinates.
 * @param ***REMOVED***number***REMOVED*** [options.max=null] For geospatial indexes set the high bound for the co-ordinates.
 * @param ***REMOVED***number***REMOVED*** [options.v=null] Specify the format version of the indexes.
 * @param ***REMOVED***number***REMOVED*** [options.expireAfterSeconds=null] Allows you to expire data on indexes applied to a data (MongoDB 2.2 or higher)
 * @param ***REMOVED***number***REMOVED*** [options.name=null] Override the autogenerated index name (useful if the resulting name is larger than 128 bytes)
 * @param ***REMOVED***Db~resultCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Db.prototype.ensureIndex = function(name, fieldOrSpec, options, callback) ***REMOVED***
  var self = this;
  if(typeof options == 'function') callback = options, options = ***REMOVED******REMOVED***;
  options = options || ***REMOVED******REMOVED***;

  // If we have a callback fallback
  if(typeof callback == 'function') return ensureIndex(self, name, fieldOrSpec, options, callback);

  // Return a promise
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    ensureIndex(self, name, fieldOrSpec, options, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***;

var ensureIndex = function(self, name, fieldOrSpec, options, callback) ***REMOVED***
  // Get the write concern options
  var finalOptions = writeConcern(***REMOVED******REMOVED***, self, options);
  // Create command
  var selector = createCreateIndexCommand(self, name, fieldOrSpec, options);
  var index_name = selector.name;

  // Did the user destroy the topology
  if(self.serverConfig && self.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed'));

  // Check if the index allready exists
  self.indexInformation(name, finalOptions, function(err, indexInformation) ***REMOVED***
    if(err != null && err.code != 26) return handleCallback(callback, err, null);
    // If the index does not exist, create it
    if(indexInformation == null || !indexInformation[index_name])  ***REMOVED***
      self.createIndex(name, fieldOrSpec, options, callback);
    ***REMOVED*** else ***REMOVED***
      if(typeof callback === 'function') return handleCallback(callback, null, index_name);
    ***REMOVED***
  ***REMOVED***);
***REMOVED***

define.classMethod('ensureIndex', ***REMOVED***callback: true, promise:true***REMOVED***);

Db.prototype.addChild = function(db) ***REMOVED***
  if(this.s.parentDb) return this.s.parentDb.addChild(db);
  this.s.children.push(db);
***REMOVED***

/**
 * Create a new Db instance sharing the current socket connections. Be aware that the new db instances are
 * related in a parent-child relationship to the original instance so that events are correctly emitted on child
 * db instances. Child db instances are cached so performing db('db1') twice will return the same instance.
 * You can control these behaviors with the options noListener and returnNonCachedInstance.
 *
 * @method
 * @param ***REMOVED***string***REMOVED*** name The name of the database we want to use.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***boolean***REMOVED*** [options.noListener=false] Do not make the db an event listener to the original connection.
 * @param ***REMOVED***boolean***REMOVED*** [options.returnNonCachedInstance=false] Control if you want to return a cached instance or have a new one created
 * @return ***REMOVED***Db***REMOVED***
 */
Db.prototype.db = function(dbName, options) ***REMOVED***
  options = options || ***REMOVED******REMOVED***;

  // Copy the options and add out internal override of the not shared flag
  var finalOptions = assign(***REMOVED******REMOVED***, this.options, options);

  // Do we have the db in the cache already
  if(this.s.dbCache[dbName] && finalOptions.returnNonCachedInstance !== true) ***REMOVED***
    return this.s.dbCache[dbName];
  ***REMOVED***

  // Add current db as parentDb
  if(finalOptions.noListener == null || finalOptions.noListener == false) ***REMOVED***
    finalOptions.parentDb = this;
  ***REMOVED***

  // Add promiseLibrary
  finalOptions.promiseLibrary = this.s.promiseLibrary;

  // Return the db object
  var db = new Db(dbName, this.s.topology, finalOptions)

  // Add as child
  if(finalOptions.noListener == null || finalOptions.noListener == false) ***REMOVED***
    this.addChild(db);
  ***REMOVED***

  // Add the db to the cache
  this.s.dbCache[dbName] = db;
  // Return the database
  return db;
***REMOVED***;

define.classMethod('db', ***REMOVED***callback: false, promise:false, returns: [Db]***REMOVED***);

var _executeAuthCreateUserCommand = function(self, username, password, options, callback) ***REMOVED***
  // Special case where there is no password ($external users)
  if(typeof username == 'string'
    && password != null && typeof password == 'object') ***REMOVED***
    options = password;
    password = null;
  ***REMOVED***

  // Unpack all options
  if(typeof options == 'function') ***REMOVED***
    callback = options;
    options = ***REMOVED******REMOVED***;
  ***REMOVED***

  // Error out if we digestPassword set
  if(options.digestPassword != null) ***REMOVED***
    throw toError("The digestPassword option is not supported via add_user. Please use db.command('createUser', ...) instead for this option.");
  ***REMOVED***

  // Get additional values
  var customData = options.customData != null ? options.customData : ***REMOVED******REMOVED***;
  var roles = Array.isArray(options.roles) ? options.roles : [];
  var maxTimeMS = typeof options.maxTimeMS == 'number' ? options.maxTimeMS : null;

  // If not roles defined print deprecated message
  if(roles.length == 0) ***REMOVED***
    console.log("Creating a user without roles is deprecated in MongoDB >= 2.6");
  ***REMOVED***

  // Get the error options
  var commandOptions = ***REMOVED***writeCommand:true***REMOVED***;
  if(options['dbName']) commandOptions.dbName = options['dbName'];

  // Add maxTimeMS to options if set
  if(maxTimeMS != null) commandOptions.maxTimeMS = maxTimeMS;

  // Check the db name and add roles if needed
  if((self.databaseName.toLowerCase() == 'admin' || options.dbName == 'admin') && !Array.isArray(options.roles)) ***REMOVED***
    roles = ['root']
  ***REMOVED*** else if(!Array.isArray(options.roles)) ***REMOVED***
    roles = ['dbOwner']
  ***REMOVED***

  // Build the command to execute
  var command = ***REMOVED***
      createUser: username
    , customData: customData
    , roles: roles
    , digestPassword:false
  ***REMOVED***

  // Apply write concern to command
  command = writeConcern(command, self, options);

  // Use node md5 generator
  var md5 = crypto.createHash('md5');
  // Generate keys used for authentication
  md5.update(username + ":mongo:" + password);
  var userPassword = md5.digest('hex');

  // No password
  if(typeof password == 'string') ***REMOVED***
    command.pwd = userPassword;
  ***REMOVED***

  // Force write using primary
  commandOptions.readPreference = ReadPreference.primary;

  // Execute the command
  self.command(command, commandOptions, function(err, result) ***REMOVED***
    if(err && err.ok == 0 && err.code == undefined) return handleCallback(callback, ***REMOVED***code: -5000***REMOVED***, null);
    if(err) return handleCallback(callback, err, null);
    handleCallback(callback, !result.ok ? toError(result) : null
      , result.ok ? [***REMOVED***user: username, pwd: ''***REMOVED***] : null);
  ***REMOVED***)
***REMOVED***

var addUser = function(self, username, password, options, callback) ***REMOVED***
  // Did the user destroy the topology
  if(self.serverConfig && self.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed'));
  // Attempt to execute auth command
  _executeAuthCreateUserCommand(self, username, password, options, function(err, r) ***REMOVED***
    // We need to perform the backward compatible insert operation
    if(err && err.code == -5000) ***REMOVED***
      var finalOptions = writeConcern(shallowClone(options), self, options);
      // Use node md5 generator
      var md5 = crypto.createHash('md5');
      // Generate keys used for authentication
      md5.update(username + ":mongo:" + password);
      var userPassword = md5.digest('hex');

      // If we have another db set
      var db = options.dbName ? self.db(options.dbName) : self;

      // Fetch a user collection
      var collection = db.collection(Db.SYSTEM_USER_COLLECTION);

      // Check if we are inserting the first user
      collection.count(***REMOVED******REMOVED***, function(err, count) ***REMOVED***
        // We got an error (f.ex not authorized)
        if(err != null) return handleCallback(callback, err, null);
        // Check if the user exists and update i
        collection.find(***REMOVED***user: username***REMOVED***, ***REMOVED***dbName: options['dbName']***REMOVED***).toArray(function(err) ***REMOVED***
          // We got an error (f.ex not authorized)
          if(err != null) return handleCallback(callback, err, null);
          // Add command keys
          finalOptions.upsert = true;

          // We have a user, let's update the password or upsert if not
          collection.update(***REMOVED***user: username***REMOVED***,***REMOVED***$set: ***REMOVED***user: username, pwd: userPassword***REMOVED******REMOVED***, finalOptions, function(err) ***REMOVED***
            if(count == 0 && err) return handleCallback(callback, null, [***REMOVED***user:username, pwd:userPassword***REMOVED***]);
            if(err) return handleCallback(callback, err, null)
            handleCallback(callback, null, [***REMOVED***user:username, pwd:userPassword***REMOVED***]);
          ***REMOVED***);
        ***REMOVED***);
      ***REMOVED***);

      return;
    ***REMOVED***

    if(err) return handleCallback(callback, err);
    handleCallback(callback, err, r);
  ***REMOVED***);
***REMOVED***

/**
 * Add a user to the database.
 * @method
 * @param ***REMOVED***string***REMOVED*** username The username.
 * @param ***REMOVED***string***REMOVED*** password The password.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(number|string)***REMOVED*** [options.w=null] The write concern.
 * @param ***REMOVED***number***REMOVED*** [options.wtimeout=null] The write concern timeout.
 * @param ***REMOVED***boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param ***REMOVED***object***REMOVED*** [options.customData=null] Custom data associated with the user (only Mongodb 2.6 or higher)
 * @param ***REMOVED***object[]***REMOVED*** [options.roles=null] Roles associated with the created user (only Mongodb 2.6 or higher)
 * @param ***REMOVED***Db~resultCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Db.prototype.addUser = function(username, password, options, callback) ***REMOVED***
  // Unpack the parameters
  var self = this;
  var args = Array.prototype.slice.call(arguments, 2);
  callback = args.pop();
  if(typeof callback != 'function') args.push(callback);
  options = args.length ? args.shift() || ***REMOVED******REMOVED*** : ***REMOVED******REMOVED***;

  // If we have a callback fallback
  if(typeof callback == 'function') return addUser(self, username, password, options, callback);

  // Return a promise
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    addUser(self, username, password, options, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***;

define.classMethod('addUser', ***REMOVED***callback: true, promise:true***REMOVED***);

var _executeAuthRemoveUserCommand = function(self, username, options, callback) ***REMOVED***
  if(typeof options == 'function') callback = options, options = ***REMOVED******REMOVED***;
  // Did the user destroy the topology
  if(self.serverConfig && self.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed'));
  // Get the error options
  var commandOptions = ***REMOVED***writeCommand:true***REMOVED***;
  if(options['dbName']) commandOptions.dbName = options['dbName'];

  // Get additional values
  var maxTimeMS = typeof options.maxTimeMS == 'number' ? options.maxTimeMS : null;

  // Add maxTimeMS to options if set
  if(maxTimeMS != null) commandOptions.maxTimeMS = maxTimeMS;

  // Build the command to execute
  var command = ***REMOVED***
    dropUser: username
  ***REMOVED***

  // Apply write concern to command
  command = writeConcern(command, self, options);

  // Force write using primary
  commandOptions.readPreference = ReadPreference.primary;

  // Execute the command
  self.command(command, commandOptions, function(err, result) ***REMOVED***
    if(err && !err.ok && err.code == undefined) return handleCallback(callback, ***REMOVED***code: -5000***REMOVED***);
    if(err) return handleCallback(callback, err, null);
    handleCallback(callback, null, result.ok ? true : false);
  ***REMOVED***)
***REMOVED***

var removeUser = function(self, username, options, callback) ***REMOVED***
  // Attempt to execute command
  _executeAuthRemoveUserCommand(self, username, options, function(err, result) ***REMOVED***
    if(err && err.code == -5000) ***REMOVED***
      var finalOptions = writeConcern(shallowClone(options), self, options);
      // If we have another db set
      var db = options.dbName ? self.db(options.dbName) : self;

      // Fetch a user collection
      var collection = db.collection(Db.SYSTEM_USER_COLLECTION);

      // Locate the user
      collection.findOne(***REMOVED***user: username***REMOVED***, ***REMOVED******REMOVED***, function(err, user) ***REMOVED***
        if(user == null) return handleCallback(callback, err, false);
        collection.remove(***REMOVED***user: username***REMOVED***, finalOptions, function(err) ***REMOVED***
          handleCallback(callback, err, true);
        ***REMOVED***);
      ***REMOVED***);

      return;
    ***REMOVED***

    if(err) return handleCallback(callback, err);
    handleCallback(callback, err, result);
  ***REMOVED***);
***REMOVED***

define.classMethod('removeUser', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Remove a user from a database
 * @method
 * @param ***REMOVED***string***REMOVED*** username The username.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(number|string)***REMOVED*** [options.w=null] The write concern.
 * @param ***REMOVED***number***REMOVED*** [options.wtimeout=null] The write concern timeout.
 * @param ***REMOVED***boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param ***REMOVED***Db~resultCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Db.prototype.removeUser = function(username, options, callback) ***REMOVED***
  // Unpack the parameters
  var self = this;
  var args = Array.prototype.slice.call(arguments, 1);
  callback = args.pop();
  if(typeof callback != 'function') args.push(callback);
  options = args.length ? args.shift() || ***REMOVED******REMOVED*** : ***REMOVED******REMOVED***;

  // If we have a callback fallback
  if(typeof callback == 'function') return removeUser(self, username, options, callback);

  // Return a promise
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    removeUser(self, username, options, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***;

var authenticate = function(self, username, password, options, callback) ***REMOVED***
  // Did the user destroy the topology
  if(self.serverConfig && self.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed'));

  // the default db to authenticate against is 'self'
  // if authententicate is called from a retry context, it may be another one, like admin
  var authdb = options.dbName ? options.dbName : self.databaseName;
  authdb = self.authSource ? self.authSource : authdb;
  authdb = options.authdb ? options.authdb : authdb;
  authdb = options.authSource ? options.authSource : authdb;

  // Callback
  var _callback = function(err, result) ***REMOVED***
    if(self.listeners('authenticated').length > 0) ***REMOVED***
      self.emit('authenticated', err, result);
    ***REMOVED***

    // Return to caller
    handleCallback(callback, err, result);
  ***REMOVED***

  // authMechanism
  var authMechanism = options.authMechanism || '';
  authMechanism = authMechanism.toUpperCase();

  // If classic auth delegate to auth command
  if(authMechanism == 'MONGODB-CR') ***REMOVED***
    self.s.topology.auth('mongocr', authdb, username, password, function(err) ***REMOVED***
      if(err) return handleCallback(callback, err, false);
      _callback(null, true);
    ***REMOVED***);
  ***REMOVED*** else if(authMechanism == 'PLAIN') ***REMOVED***
    self.s.topology.auth('plain', authdb, username, password, function(err) ***REMOVED***
      if(err) return handleCallback(callback, err, false);
      _callback(null, true);
    ***REMOVED***);
  ***REMOVED*** else if(authMechanism == 'MONGODB-X509') ***REMOVED***
    self.s.topology.auth('x509', authdb, username, password, function(err) ***REMOVED***
      if(err) return handleCallback(callback, err, false);
      _callback(null, true);
    ***REMOVED***);
  ***REMOVED*** else if(authMechanism == 'SCRAM-SHA-1') ***REMOVED***
    self.s.topology.auth('scram-sha-1', authdb, username, password, function(err) ***REMOVED***
      if(err) return handleCallback(callback, err, false);
      _callback(null, true);
    ***REMOVED***);
  ***REMOVED*** else if(authMechanism == 'GSSAPI') ***REMOVED***
    if(process.platform == 'win32') ***REMOVED***
      self.s.topology.auth('sspi', authdb, username, password, options, function(err) ***REMOVED***
        if(err) return handleCallback(callback, err, false);
        _callback(null, true);
      ***REMOVED***);
    ***REMOVED*** else ***REMOVED***
      self.s.topology.auth('gssapi', authdb, username, password, options, function(err) ***REMOVED***
        if(err) return handleCallback(callback, err, false);
        _callback(null, true);
      ***REMOVED***);
    ***REMOVED***
  ***REMOVED*** else if(authMechanism == 'DEFAULT') ***REMOVED***
    self.s.topology.auth('default', authdb, username, password, function(err) ***REMOVED***
      if(err) return handleCallback(callback, err, false);
      _callback(null, true);
    ***REMOVED***);
  ***REMOVED*** else ***REMOVED***
    handleCallback(callback, MongoError.create(***REMOVED***message: f("authentication mechanism %s not supported", options.authMechanism), driver:true***REMOVED***));
  ***REMOVED***
***REMOVED***

/**
 * Authenticate a user against the server.
 * @method
 * @param ***REMOVED***string***REMOVED*** username The username.
 * @param ***REMOVED***string***REMOVED*** [password] The password.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***string***REMOVED*** [options.authMechanism=MONGODB-CR] The authentication mechanism to use, GSSAPI, MONGODB-CR, MONGODB-X509, PLAIN
 * @param ***REMOVED***Db~resultCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Db.prototype.authenticate = function(username, password, options, callback) ***REMOVED***
  if(typeof options == 'function') callback = options, options = ***REMOVED******REMOVED***;
  var self = this;
  // Shallow copy the options
  options = shallowClone(options);

  // Set default mechanism
  if(!options.authMechanism) ***REMOVED***
    options.authMechanism = 'DEFAULT';
  ***REMOVED*** else if(options.authMechanism != 'GSSAPI'
    && options.authMechanism != 'DEFAULT'
    && options.authMechanism != 'MONGODB-CR'
    && options.authMechanism != 'MONGODB-X509'
    && options.authMechanism != 'SCRAM-SHA-1'
    && options.authMechanism != 'PLAIN') ***REMOVED***
      return handleCallback(callback, MongoError.create(***REMOVED***message: "only DEFAULT, GSSAPI, PLAIN, MONGODB-X509, SCRAM-SHA-1 or MONGODB-CR is supported by authMechanism", driver:true***REMOVED***));
  ***REMOVED***

  // If we have a callback fallback
  if(typeof callback == 'function') return authenticate(self, username, password, options, function(err, r) ***REMOVED***
    // Support failed auth method
    if(err && err.message && err.message.indexOf('saslStart') != -1) err.code = 59;
    // Reject error
    if(err) return callback(err, r);
    callback(null, r);
  ***REMOVED***);

  // Return a promise
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    authenticate(self, username, password, options, function(err, r) ***REMOVED***
      // Support failed auth method
      if(err && err.message && err.message.indexOf('saslStart') != -1) err.code = 59;
      // Reject error
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***;

define.classMethod('authenticate', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Logout user from server, fire off on all connections and remove all auth info
 * @method
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***string***REMOVED*** [options.dbName=null] Logout against different database than current.
 * @param ***REMOVED***Db~resultCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Db.prototype.logout = function(options, callback) ***REMOVED***
  var self = this;
  if(typeof options == 'function') callback = options, options = ***REMOVED******REMOVED***;
  options = options || ***REMOVED******REMOVED***;

  // Establish the correct database name
  var dbName = this.s.authSource ? this.s.authSource : this.s.databaseName;
  dbName = options.dbName ? options.dbName : dbName;

  // If we have a callback
  if(typeof callback == 'function') ***REMOVED***
    return self.s.topology.logout(dbName, function(err) ***REMOVED***
      if(err) return callback(err);
      callback(null, true);
    ***REMOVED***);
  ***REMOVED***

  // Return a promise
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    self.s.topology.logout(dbName, function(err) ***REMOVED***
      if(err) return reject(err);
      resolve(true);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

define.classMethod('logout', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Retrieves this collections index info.
 * @method
 * @param ***REMOVED***string***REMOVED*** name The name of the collection.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***boolean***REMOVED*** [options.full=false] Returns the full raw index information.
 * @param ***REMOVED***(ReadPreference|string)***REMOVED*** [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param ***REMOVED***Db~resultCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Db.prototype.indexInformation = function(name, options, callback) ***REMOVED***
  var self = this;
  if(typeof options == 'function') callback = options, options = ***REMOVED******REMOVED***;
  options = options || ***REMOVED******REMOVED***;

  // If we have a callback fallback
  if(typeof callback == 'function') return indexInformation(self, name, options, callback);

  // Return a promise
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    indexInformation(self, name, options, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***;

var indexInformation = function(self, name, options, callback) ***REMOVED***
    // If we specified full information
  var full = options['full'] == null ? false : options['full'];

  // Did the user destroy the topology
  if(self.serverConfig && self.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed'));

  // Process all the results from the index command and collection
  var processResults = function(indexes) ***REMOVED***
    // Contains all the information
    var info = ***REMOVED******REMOVED***;
    // Process all the indexes
    for(var i = 0; i < indexes.length; i++) ***REMOVED***
      var index = indexes[i];
      // Let's unpack the object
      info[index.name] = [];
      for(var name in index.key) ***REMOVED***
        info[index.name].push([name, index.key[name]]);
      ***REMOVED***
    ***REMOVED***

    return info;
  ***REMOVED***

  // Get the list of indexes of the specified collection
  self.collection(name).listIndexes().toArray(function(err, indexes) ***REMOVED***
    if(err) return callback(toError(err));
    if(!Array.isArray(indexes)) return handleCallback(callback, null, []);
    if(full) return handleCallback(callback, null, indexes);
    handleCallback(callback, null, processResults(indexes));
  ***REMOVED***);
***REMOVED***

define.classMethod('indexInformation', ***REMOVED***callback: true, promise:true***REMOVED***);

var createCreateIndexCommand = function(db, name, fieldOrSpec, options) ***REMOVED***
  var indexParameters = parseIndexOptions(fieldOrSpec);
  var fieldHash = indexParameters.fieldHash;

  // Generate the index name
  var indexName = typeof options.name == 'string' ? options.name : indexParameters.name;
  var selector = ***REMOVED***
    'ns': db.databaseName + "." + name, 'key': fieldHash, 'name': indexName
  ***REMOVED***

  // Ensure we have a correct finalUnique
  var finalUnique = options == null || 'object' === typeof options ? false : options;
  // Set up options
  options = options == null || typeof options == 'boolean' ? ***REMOVED******REMOVED*** : options;

  // Add all the options
  var keysToOmit = Object.keys(selector);
  for(var optionName in options) ***REMOVED***
    if(keysToOmit.indexOf(optionName) == -1) ***REMOVED***
      selector[optionName] = options[optionName];
    ***REMOVED***
  ***REMOVED***

  if(selector['unique'] == null) selector['unique'] = finalUnique;

  // Remove any write concern operations
  var removeKeys = ['w', 'wtimeout', 'j', 'fsync', 'readPreference'];
  for(var i = 0; i < removeKeys.length; i++) ***REMOVED***
    delete selector[removeKeys[i]];
  ***REMOVED***

  // Return the command creation selector
  return selector;
***REMOVED***

var createIndexUsingCreateIndexes = function(self, name, fieldOrSpec, options, callback) ***REMOVED***
  // Build the index
  var indexParameters = parseIndexOptions(fieldOrSpec);
  // Generate the index name
  var indexName = typeof options.name == 'string' ? options.name : indexParameters.name;
  // Set up the index
  var indexes = [***REMOVED*** name: indexName, key: indexParameters.fieldHash ***REMOVED***];
  // merge all the options
  var keysToOmit = Object.keys(indexes[0]);
  for(var optionName in options) ***REMOVED***
    if(keysToOmit.indexOf(optionName) == -1) ***REMOVED***
      indexes[0][optionName] = options[optionName];
    ***REMOVED***

    // Remove any write concern operations
    var removeKeys = ['w', 'wtimeout', 'j', 'fsync', 'readPreference'];
    for(var i = 0; i < removeKeys.length; i++) ***REMOVED***
      delete indexes[0][removeKeys[i]];
    ***REMOVED***
  ***REMOVED***

  // Get capabilities
  var capabilities = self.s.topology.capabilities();

  // Did the user pass in a collation, check if our write server supports it
  if(indexes[0].collation && capabilities && !capabilities.commandsTakeCollation) ***REMOVED***
    // Create a new error
    var error = new MongoError(f('server/primary/mongos does not support collation'));
    error.code = 67;
    // Return the error
    return callback(error);
  ***REMOVED***

  // Create command, apply write concern to command
  var cmd = writeConcern(***REMOVED***createIndexes: name, indexes: indexes***REMOVED***, self, options);

  // Decorate command with writeConcern if supported
  decorateWithWriteConcern(cmd, self, options);

  // ReadPreference primary
  options.readPreference = ReadPreference.PRIMARY;

  // Build the command
  self.command(cmd, options, function(err, result) ***REMOVED***
    if(err) return handleCallback(callback, err, null);
    if(result.ok == 0) return handleCallback(callback, toError(result), null);
    // Return the indexName for backward compatibility
    handleCallback(callback, null, indexName);
  ***REMOVED***);
***REMOVED***

// Validate the database name
var validateDatabaseName = function(databaseName) ***REMOVED***
  if(typeof databaseName !== 'string') throw MongoError.create(***REMOVED***message: "database name must be a string", driver:true***REMOVED***);
  if(databaseName.length === 0) throw MongoError.create(***REMOVED***message: "database name cannot be the empty string", driver:true***REMOVED***);
  if(databaseName == '$external') return;

  var invalidChars = [" ", ".", "$", "/", "\\"];
  for(var i = 0; i < invalidChars.length; i++) ***REMOVED***
    if(databaseName.indexOf(invalidChars[i]) != -1) throw MongoError.create(***REMOVED***message: "database names cannot contain the character '" + invalidChars[i] + "'", driver:true***REMOVED***);
  ***REMOVED***
***REMOVED***

// Get write concern
var writeConcern = function(target, db, options) ***REMOVED***
  if(options.w != null || options.j != null || options.fsync != null) ***REMOVED***
    var opts = ***REMOVED******REMOVED***;
    if(options.w) opts.w = options.w;
    if(options.wtimeout) opts.wtimeout = options.wtimeout;
    if(options.j) opts.j = options.j;
    if(options.fsync) opts.fsync = options.fsync;
    target.writeConcern = opts;
  ***REMOVED*** else if(db.writeConcern.w != null || db.writeConcern.j != null || db.writeConcern.fsync != null) ***REMOVED***
    target.writeConcern = db.writeConcern;
  ***REMOVED***

  return target
***REMOVED***

// Add listeners to topology
var createListener = function(self, e, object) ***REMOVED***
  var listener = function(err) ***REMOVED***
    if(object.listeners(e).length > 0) ***REMOVED***
      object.emit(e, err, self);

      // Emit on all associated db's if available
      for(var i = 0; i < self.s.children.length; i++) ***REMOVED***
        self.s.children[i].emit(e, err, self.s.children[i]);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
  return listener;
***REMOVED***


/**
 * Unref all sockets
 * @method
 */
Db.prototype.unref = function() ***REMOVED***
  this.s.topology.unref();
***REMOVED***

/**
 * Db close event
 *
 * Emitted after a socket closed against a single server or mongos proxy.
 *
 * @event Db#close
 * @type ***REMOVED***MongoError***REMOVED***
 */

/**
 * Db authenticated event
 *
 * Emitted after all server members in the topology (single server, replicaset or mongos) have successfully authenticated.
 *
 * @event Db#authenticated
 * @type ***REMOVED***object***REMOVED***
 */

/**
 * Db reconnect event
 *
 *  * Server: Emitted when the driver has reconnected and re-authenticated.
 *  * ReplicaSet: N/A
 *  * Mongos: Emitted when the driver reconnects and re-authenticates successfully against a Mongos.
 *
 * @event Db#reconnect
 * @type ***REMOVED***object***REMOVED***
 */

/**
 * Db error event
 *
 * Emitted after an error occurred against a single server or mongos proxy.
 *
 * @event Db#error
 * @type ***REMOVED***MongoError***REMOVED***
 */

/**
 * Db timeout event
 *
 * Emitted after a socket timeout occurred against a single server or mongos proxy.
 *
 * @event Db#timeout
 * @type ***REMOVED***MongoError***REMOVED***
 */

/**
 * Db parseError event
 *
 * The parseError event is emitted if the driver detects illegal or corrupt BSON being received from the server.
 *
 * @event Db#parseError
 * @type ***REMOVED***MongoError***REMOVED***
 */

/**
 * Db fullsetup event, emitted when all servers in the topology have been connected to at start up time.
 *
 * * Server: Emitted when the driver has connected to the single server and has authenticated.
 * * ReplSet: Emitted after the driver has attempted to connect to all replicaset members.
 * * Mongos: Emitted after the driver has attempted to connect to all mongos proxies.
 *
 * @event Db#fullsetup
 * @type ***REMOVED***Db***REMOVED***
 */

// Constants
Db.SYSTEM_NAMESPACE_COLLECTION = "system.namespaces";
Db.SYSTEM_INDEX_COLLECTION = "system.indexes";
Db.SYSTEM_PROFILE_COLLECTION = "system.profile";
Db.SYSTEM_USER_COLLECTION = "system.users";
Db.SYSTEM_COMMAND_COLLECTION = "$cmd";
Db.SYSTEM_JS_COLLECTION = "system.js";

module.exports = Db;
