"use strict";

var EventEmitter = require('events').EventEmitter
  , inherits = require('util').inherits
  , CServer = require('mongodb-core').Server
  , Cursor = require('./cursor')
  , AggregationCursor = require('./aggregation_cursor')
  , CommandCursor = require('./command_cursor')
  , f = require('util').format
  , ServerCapabilities = require('./topology_base').ServerCapabilities
  , Store = require('./topology_base').Store
  , Define = require('./metadata')
  , MongoError = require('mongodb-core').MongoError
  , MAX_JS_INT = require('./utils').MAX_JS_INT
  , translateOptions = require('./utils').translateOptions
  , filterOptions = require('./utils').filterOptions
  , mergeOptions = require('./utils').mergeOptions
  , os = require('os');

// Get package.json variable
var driverVersion = require(__dirname + '/../package.json').version;
var nodejsversion = f('Node.js %s, %s', process.version, os.endianness());
var type = os.type();
var name = process.platform;
var architecture = process.arch;
var release = os.release();

/**
 * @fileOverview The **Server** class is a class that represents a single server topology and is
 * used to construct connections.
 *
 * **Server Should not be used, use MongoClient.connect**
 * @example
 * var Db = require('mongodb').Db,
 *   Server = require('mongodb').Server,
 *   test = require('assert');
 * // Connect using single Server
 * var db = new Db('test', new Server('localhost', 27017););
 * db.open(function(err, db) ***REMOVED***
 *   // Get an additional db
 *   db.close();
 * ***REMOVED***);
 */

 // Allowed parameters
 var legalOptionNames = ['ha', 'haInterval', 'acceptableLatencyMS'
   , 'poolSize', 'ssl', 'checkServerIdentity', 'sslValidate'
   , 'sslCA', 'sslCert', 'sslKey', 'sslPass', 'socketOptions', 'bufferMaxEntries'
   , 'store', 'auto_reconnect', 'autoReconnect', 'emitError'
   , 'keepAlive', 'noDelay', 'connectTimeoutMS', 'socketTimeoutMS'
   , 'loggerLevel', 'logger', 'reconnectTries', 'reconnectInterval', 'monitoring'
   , 'appname', 'domainsEnabled'
   , 'servername', 'promoteLongs', 'promoteValues', 'promoteBuffers'];

/**
 * Creates a new Server instance
 * @class
 * @deprecated
 * @param ***REMOVED***string***REMOVED*** host The host for the server, can be either an IP4, IP6 or domain socket style host.
 * @param ***REMOVED***number***REMOVED*** [port] The server port if IP4.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***number***REMOVED*** [options.poolSize=5] Number of connections in the connection pool for each server instance, set to 5 as default for legacy reasons.
 * @param ***REMOVED***boolean***REMOVED*** [options.ssl=false] Use ssl connection (needs to have a mongod server with ssl support)
 * @param ***REMOVED***object***REMOVED*** [options.sslValidate=true] Validate mongod server certificate against ca (needs to have a mongod server with ssl support, 2.4 or higher)
 * @param ***REMOVED***boolean|function***REMOVED*** [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.
 * @param ***REMOVED***array***REMOVED*** [options.sslCA=null] Array of valid certificates either as Buffers or Strings (needs to have a mongod server with ssl support, 2.4 or higher)
 * @param ***REMOVED***(Buffer|string)***REMOVED*** [options.sslCert=null] String or buffer containing the certificate we wish to present (needs to have a mongod server with ssl support, 2.4 or higher)
 * @param ***REMOVED***(Buffer|string)***REMOVED*** [options.sslKey=null] String or buffer containing the certificate private key we wish to present (needs to have a mongod server with ssl support, 2.4 or higher)
 * @param ***REMOVED***(Buffer|string)***REMOVED*** [options.sslPass=null] String or buffer containing the certificate password (needs to have a mongod server with ssl support, 2.4 or higher)
 * @param ***REMOVED***string***REMOVED*** [options.servername=null] String containing the server name requested via TLS SNI.
 * @param ***REMOVED***object***REMOVED*** [options.socketOptions=null] Socket options
 * @param ***REMOVED***boolean***REMOVED*** [options.socketOptions.autoReconnect=true] Reconnect on error.
 * @param ***REMOVED***boolean***REMOVED*** [options.socketOptions.noDelay=true] TCP Socket NoDelay option.
 * @param ***REMOVED***number***REMOVED*** [options.socketOptions.keepAlive=0] TCP KeepAlive on the socket with a X ms delay before start.
 * @param ***REMOVED***number***REMOVED*** [options.socketOptions.connectTimeoutMS=0] TCP Connection timeout setting
 * @param ***REMOVED***number***REMOVED*** [options.socketOptions.socketTimeoutMS=0] TCP Socket timeout setting
 * @param ***REMOVED***number***REMOVED*** [options.reconnectTries=30] Server attempt to reconnect #times
 * @param ***REMOVED***number***REMOVED*** [options.reconnectInterval=1000] Server will wait # milliseconds between retries
 * @param ***REMOVED***number***REMOVED*** [options.monitoring=true] Triggers the server instance to call ismaster
 * @param ***REMOVED***number***REMOVED*** [options.haInterval=10000] The interval of calling ismaster when monitoring is enabled.
 * @param ***REMOVED***boolean***REMOVED*** [options.domainsEnabled=false] Enable the wrapping of the callback in the current domain, disabled by default to avoid perf hit.
 * @fires Server#connect
 * @fires Server#close
 * @fires Server#error
 * @fires Server#timeout
 * @fires Server#parseError
 * @fires Server#reconnect
 * @property ***REMOVED***string***REMOVED*** parserType the parser type used (c++ or js).
 * @return ***REMOVED***Server***REMOVED*** a Server instance.
 */
var Server = function(host, port, options) ***REMOVED***
  options = options || ***REMOVED******REMOVED***;
  if(!(this instanceof Server)) return new Server(host, port, options);
  EventEmitter.call(this);
  var self = this;

  // Filter the options
  options = filterOptions(options, legalOptionNames);

  // Stored options
  var storeOptions = ***REMOVED***
      force: false
    , bufferMaxEntries: typeof options.bufferMaxEntries == 'number' ? options.bufferMaxEntries : MAX_JS_INT
  ***REMOVED***

  // Shared global store
  var store = options.store || new Store(self, storeOptions);

  // Detect if we have a socket connection
  if(host.indexOf('\/') != -1) ***REMOVED***
    if(port != null && typeof port == 'object') ***REMOVED***
      options = port;
      port = null;
    ***REMOVED***
  ***REMOVED*** else if(port == null) ***REMOVED***
    throw MongoError.create(***REMOVED***message: 'port must be specified', driver:true***REMOVED***);
  ***REMOVED***

  // Get the reconnect option
  var reconnect = typeof options.auto_reconnect == 'boolean' ? options.auto_reconnect : true;
  reconnect = typeof options.autoReconnect == 'boolean' ? options.autoReconnect : reconnect;

  // Clone options
  var clonedOptions = mergeOptions(***REMOVED******REMOVED***, ***REMOVED***
    host: host, port: port, disconnectHandler: store,
    cursorFactory: Cursor,
    reconnect: reconnect,
    emitError: typeof options.emitError == 'boolean' ? options.emitError : true,
    size: typeof options.poolSize == 'number' ? options.poolSize : 5
  ***REMOVED***);

  // Translate any SSL options and other connectivity options
  clonedOptions = translateOptions(clonedOptions, options);

  // Socket options
  var socketOptions = options.socketOptions && Object.keys(options.socketOptions).length > 0
    ? options.socketOptions : options;

  // Translate all the options to the mongodb-core ones
  clonedOptions = translateOptions(clonedOptions, socketOptions);
  if(typeof clonedOptions.keepAlive == 'number') ***REMOVED***
    clonedOptions.keepAliveInitialDelay = clonedOptions.keepAlive;
    clonedOptions.keepAlive = clonedOptions.keepAlive > 0;
  ***REMOVED***

  // Build default client information
  this.clientInfo = ***REMOVED***
    driver: ***REMOVED***
      name: "nodejs",
      version: driverVersion
    ***REMOVED***,
    os: ***REMOVED***
      type: type,
      name: name,
      architecture: architecture,
      version: release
    ***REMOVED***,
    platform: nodejsversion
  ***REMOVED***

  // Build default client information
  clonedOptions.clientInfo = this.clientInfo;
  // Do we have an application specific string
  if(options.appname) ***REMOVED***
    clonedOptions.clientInfo.application = ***REMOVED*** name: options.appname ***REMOVED***;
  ***REMOVED***

  // Create an instance of a server instance from mongodb-core
  var server = new CServer(clonedOptions);

  // Define the internal properties
  this.s = ***REMOVED***
    // Create an instance of a server instance from mongodb-core
      server: server
    // Server capabilities
    , sCapabilities: null
    // Cloned options
    , clonedOptions: clonedOptions
    // Reconnect
    , reconnect: clonedOptions.reconnect
    // Emit error
    , emitError: clonedOptions.emitError
    // Pool size
    , poolSize: clonedOptions.size
    // Store Options
    , storeOptions: storeOptions
    // Store
    , store: store
    // Host
    , host: host
    // Port
    , port: port
    // Options
    , options: options
  ***REMOVED***
***REMOVED***

inherits(Server, EventEmitter);

var define = Server.define = new Define('Server', Server, false);

// BSON property
Object.defineProperty(Server.prototype, 'bson', ***REMOVED***
  enumerable: true, get: function() ***REMOVED***
    return this.s.server.s.bson;
  ***REMOVED***
***REMOVED***);

// Last ismaster
Object.defineProperty(Server.prototype, 'isMasterDoc', ***REMOVED***
  enumerable:true, get: function() ***REMOVED***
    return this.s.server.lastIsMaster();
  ***REMOVED***
***REMOVED***);

Object.defineProperty(Server.prototype, 'parserType', ***REMOVED***
  enumerable:true, get: function() ***REMOVED***
    return this.s.server.parserType;
  ***REMOVED***
***REMOVED***);

// Last ismaster
Object.defineProperty(Server.prototype, 'poolSize', ***REMOVED***
  enumerable:true, get: function() ***REMOVED*** return this.s.server.connections().length; ***REMOVED***
***REMOVED***);

Object.defineProperty(Server.prototype, 'autoReconnect', ***REMOVED***
  enumerable:true, get: function() ***REMOVED*** return this.s.reconnect; ***REMOVED***
***REMOVED***);

Object.defineProperty(Server.prototype, 'host', ***REMOVED***
  enumerable:true, get: function() ***REMOVED*** return this.s.host; ***REMOVED***
***REMOVED***);

Object.defineProperty(Server.prototype, 'port', ***REMOVED***
  enumerable:true, get: function() ***REMOVED*** return this.s.port; ***REMOVED***
***REMOVED***);

// Connect
Server.prototype.connect = function(db, _options, callback) ***REMOVED***
  var self = this;
  if('function' === typeof _options) callback = _options, _options = ***REMOVED******REMOVED***;
  if(_options == null) _options = ***REMOVED******REMOVED***;
  if(!('function' === typeof callback)) callback = null;
  self.s.options = _options;

  // Update bufferMaxEntries
  self.s.storeOptions.bufferMaxEntries = db.bufferMaxEntries;

  // Error handler
  var connectErrorHandler = function() ***REMOVED***
    return function(err) ***REMOVED***
      // Remove all event handlers
      var events = ['timeout', 'error', 'close'];
      events.forEach(function(e) ***REMOVED***
        self.s.server.removeListener(e, connectHandlers[e]);
      ***REMOVED***);

      self.s.server.removeListener('connect', connectErrorHandler);

      // Try to callback
      try ***REMOVED***
        callback(err);
      ***REMOVED*** catch(err) ***REMOVED***
        process.nextTick(function() ***REMOVED*** throw err; ***REMOVED***)
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  // Actual handler
  var errorHandler = function(event) ***REMOVED***
    return function(err) ***REMOVED***
      if(event != 'error') ***REMOVED***
        self.emit(event, err);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  // Error handler
  var reconnectHandler = function() ***REMOVED***
    self.emit('reconnect', self);
    self.s.store.execute();
  ***REMOVED***

  // Reconnect failed
  var reconnectFailedHandler = function(err) ***REMOVED***
    self.emit('reconnectFailed', err);
    self.s.store.flush(err);
  ***REMOVED***

  // Destroy called on topology, perform cleanup
  var destroyHandler = function() ***REMOVED***
    self.s.store.flush();
  ***REMOVED***

  // Connect handler
  var connectHandler = function() ***REMOVED***
    // Clear out all the current handlers left over
    ["timeout", "error", "close", 'serverOpening', 'serverDescriptionChanged', 'serverHeartbeatStarted',
      'serverHeartbeatSucceeded', 'serverHeartbeatFailed', 'serverClosed', 'topologyOpening',
      'topologyClosed', 'topologyDescriptionChanged'].forEach(function(e) ***REMOVED***
      self.s.server.removeAllListeners(e);
    ***REMOVED***);

    // Set up listeners
    self.s.server.on('timeout', errorHandler('timeout'));
    self.s.server.once('error', errorHandler('error'));
    self.s.server.on('close', errorHandler('close'));
    // Only called on destroy
    self.s.server.on('destroy', destroyHandler);

    // relay the event
    var relay = function(event) ***REMOVED***
      return function(t, server) ***REMOVED***
        self.emit(event, t, server);
      ***REMOVED***
    ***REMOVED***

    // Set up SDAM listeners
    self.s.server.on('serverDescriptionChanged', relay('serverDescriptionChanged'));
    self.s.server.on('serverHeartbeatStarted', relay('serverHeartbeatStarted'));
    self.s.server.on('serverHeartbeatSucceeded', relay('serverHeartbeatSucceeded'));
    self.s.server.on('serverHeartbeatFailed', relay('serverHeartbeatFailed'));
    self.s.server.on('serverOpening', relay('serverOpening'));
    self.s.server.on('serverClosed', relay('serverClosed'));
    self.s.server.on('topologyOpening', relay('topologyOpening'));
    self.s.server.on('topologyClosed', relay('topologyClosed'));
    self.s.server.on('topologyDescriptionChanged', relay('topologyDescriptionChanged'));
    self.s.server.on('attemptReconnect', relay('attemptReconnect'));
    self.s.server.on('monitoring', relay('monitoring'));

    // Emit open event
    self.emit('open', null, self);

    // Return correctly
    try ***REMOVED***
      callback(null, self);
    ***REMOVED*** catch(err) ***REMOVED***
      console.log(err.stack)
      process.nextTick(function() ***REMOVED*** throw err; ***REMOVED***)
    ***REMOVED***
  ***REMOVED***

  // Set up listeners
  var connectHandlers = ***REMOVED***
    timeout: connectErrorHandler('timeout'),
    error: connectErrorHandler('error'),
    close: connectErrorHandler('close')
  ***REMOVED***;

  // Add the event handlers
  self.s.server.once('timeout', connectHandlers.timeout);
  self.s.server.once('error', connectHandlers.error);
  self.s.server.once('close', connectHandlers.close);
  self.s.server.once('connect', connectHandler);
  // Reconnect server
  self.s.server.on('reconnect', reconnectHandler);
  self.s.server.on('reconnectFailed', reconnectFailedHandler);

  // Start connection
  self.s.server.connect(_options);
***REMOVED***

// Server capabilities
Server.prototype.capabilities = function() ***REMOVED***
  if(this.s.sCapabilities) return this.s.sCapabilities;
  if(this.s.server.lastIsMaster() == null) return null;
  this.s.sCapabilities = new ServerCapabilities(this.s.server.lastIsMaster());
  return this.s.sCapabilities;
***REMOVED***

define.classMethod('capabilities', ***REMOVED***callback: false, promise:false, returns: [ServerCapabilities]***REMOVED***);

// Command
Server.prototype.command = function(ns, cmd, options, callback) ***REMOVED***
  this.s.server.command(ns, cmd, options, callback);
***REMOVED***

define.classMethod('command', ***REMOVED***callback: true, promise:false***REMOVED***);

// Insert
Server.prototype.insert = function(ns, ops, options, callback) ***REMOVED***
  this.s.server.insert(ns, ops, options, callback);
***REMOVED***

define.classMethod('insert', ***REMOVED***callback: true, promise:false***REMOVED***);

// Update
Server.prototype.update = function(ns, ops, options, callback) ***REMOVED***
  this.s.server.update(ns, ops, options, callback);
***REMOVED***

define.classMethod('update', ***REMOVED***callback: true, promise:false***REMOVED***);

// Remove
Server.prototype.remove = function(ns, ops, options, callback) ***REMOVED***
  this.s.server.remove(ns, ops, options, callback);
***REMOVED***

define.classMethod('remove', ***REMOVED***callback: true, promise:false***REMOVED***);

// IsConnected
Server.prototype.isConnected = function() ***REMOVED***
  return this.s.server.isConnected();
***REMOVED***

Server.prototype.isDestroyed = function() ***REMOVED***
  return this.s.server.isDestroyed();
***REMOVED***

define.classMethod('isConnected', ***REMOVED***callback: false, promise:false, returns: [Boolean]***REMOVED***);

// Insert
Server.prototype.cursor = function(ns, cmd, options) ***REMOVED***
  options.disconnectHandler = this.s.store;
  return this.s.server.cursor(ns, cmd, options);
***REMOVED***

define.classMethod('cursor', ***REMOVED***callback: false, promise:false, returns: [Cursor, AggregationCursor, CommandCursor]***REMOVED***);

Server.prototype.lastIsMaster = function() ***REMOVED***
  return this.s.server.lastIsMaster();
***REMOVED***

/**
 * Unref all sockets
 * @method
 */
Server.prototype.unref = function() ***REMOVED***
  this.s.server.unref();
***REMOVED***

Server.prototype.close = function(forceClosed) ***REMOVED***
  this.s.server.destroy();
  // We need to wash out all stored processes
  if(forceClosed == true) ***REMOVED***
    this.s.storeOptions.force = forceClosed;
    this.s.store.flush();
  ***REMOVED***
***REMOVED***

define.classMethod('close', ***REMOVED***callback: false, promise:false***REMOVED***);

Server.prototype.auth = function() ***REMOVED***
  var args = Array.prototype.slice.call(arguments, 0);
  this.s.server.auth.apply(this.s.server, args);
***REMOVED***

define.classMethod('auth', ***REMOVED***callback: true, promise:false***REMOVED***);

Server.prototype.logout = function() ***REMOVED***
  var args = Array.prototype.slice.call(arguments, 0);
  this.s.server.logout.apply(this.s.server, args);
***REMOVED***

define.classMethod('logout', ***REMOVED***callback: true, promise:false***REMOVED***);

/**
 * All raw connections
 * @method
 * @return ***REMOVED***array***REMOVED***
 */
Server.prototype.connections = function() ***REMOVED***
  return this.s.server.connections();
***REMOVED***

define.classMethod('connections', ***REMOVED***callback: false, promise:false, returns:[Array]***REMOVED***);

/**
 * Server connect event
 *
 * @event Server#connect
 * @type ***REMOVED***object***REMOVED***
 */

/**
 * Server close event
 *
 * @event Server#close
 * @type ***REMOVED***object***REMOVED***
 */

/**
 * Server reconnect event
 *
 * @event Server#reconnect
 * @type ***REMOVED***object***REMOVED***
 */

/**
 * Server error event
 *
 * @event Server#error
 * @type ***REMOVED***MongoError***REMOVED***
 */

/**
 * Server timeout event
 *
 * @event Server#timeout
 * @type ***REMOVED***object***REMOVED***
 */

/**
 * Server parseError event
 *
 * @event Server#parseError
 * @type ***REMOVED***object***REMOVED***
 */

module.exports = Server;
