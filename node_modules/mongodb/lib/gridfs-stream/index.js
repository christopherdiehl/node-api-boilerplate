var Emitter = require('events').EventEmitter;
var GridFSBucketReadStream = require('./download');
var GridFSBucketWriteStream = require('./upload');
var shallowClone = require('../utils').shallowClone;
var toError = require('../utils').toError;
var util = require('util');

var DEFAULT_GRIDFS_BUCKET_OPTIONS = ***REMOVED***
  bucketName: 'fs',
  chunkSizeBytes: 255 * 1024
***REMOVED***;

module.exports = GridFSBucket;

/**
 * Constructor for a streaming GridFS interface
 * @class
 * @param ***REMOVED***Db***REMOVED*** db A db handle
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***string***REMOVED*** [options.bucketName="fs"] The 'files' and 'chunks' collections will be prefixed with the bucket name followed by a dot.
 * @param ***REMOVED***number***REMOVED*** [options.chunkSizeBytes=255 * 1024] Number of bytes stored in each chunk. Defaults to 255KB
 * @param ***REMOVED***object***REMOVED*** [options.writeConcern=null] Optional write concern to be passed to write operations, for instance `***REMOVED*** w: 1 ***REMOVED***`
 * @param ***REMOVED***object***REMOVED*** [options.readPreference=null] Optional read preference to be passed to read operations
 * @fires GridFSBucketWriteStream#index
 * @return ***REMOVED***GridFSBucket***REMOVED***
 */

function GridFSBucket(db, options) ***REMOVED***
  Emitter.apply(this);
  this.setMaxListeners(0);

  if (options && typeof options === 'object') ***REMOVED***
    options = shallowClone(options);
    var keys = Object.keys(DEFAULT_GRIDFS_BUCKET_OPTIONS);
    for (var i = 0; i < keys.length; ++i) ***REMOVED***
      if (!options[keys[i]]) ***REMOVED***
        options[keys[i]] = DEFAULT_GRIDFS_BUCKET_OPTIONS[keys[i]];
      ***REMOVED***
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    options = DEFAULT_GRIDFS_BUCKET_OPTIONS;
  ***REMOVED***

  this.s = ***REMOVED***
    db: db,
    options: options,
    _chunksCollection: db.collection(options.bucketName + '.chunks'),
    _filesCollection: db.collection(options.bucketName + '.files'),
    checkedIndexes: false,
    calledOpenUploadStream: false,
    promiseLibrary: db.s.promiseLibrary ||
      (typeof global.Promise == 'function' ? global.Promise : require('es6-promise').Promise)
  ***REMOVED***;
***REMOVED***

util.inherits(GridFSBucket, Emitter);

/**
 * When the first call to openUploadStream is made, the upload stream will
 * check to see if it needs to create the proper indexes on the chunks and
 * files collections. This event is fired either when 1) it determines that
 * no index creation is necessary, 2) when it successfully creates the
 * necessary indexes.
 *
 * @event GridFSBucket#index
 * @type ***REMOVED***Error***REMOVED***
 */

/**
 * Returns a writable stream (GridFSBucketWriteStream) for writing
 * buffers to GridFS. The stream's 'id' property contains the resulting
 * file's id.
 * @method
 * @param ***REMOVED***string***REMOVED*** filename The value of the 'filename' key in the files doc
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***number***REMOVED*** [options.chunkSizeBytes=null] Optional overwrite this bucket's chunkSizeBytes for this file
 * @param ***REMOVED***object***REMOVED*** [options.metadata=null] Optional object to store in the file document's `metadata` field
 * @param ***REMOVED***string***REMOVED*** [options.contentType=null] Optional string to store in the file document's `contentType` field
 * @param ***REMOVED***array***REMOVED*** [options.aliases=null] Optional array of strings to store in the file document's `aliases` field
 * @return ***REMOVED***GridFSBucketWriteStream***REMOVED***
 */

GridFSBucket.prototype.openUploadStream = function(filename, options) ***REMOVED***
  if (options) ***REMOVED***
    options = shallowClone(options);
  ***REMOVED*** else ***REMOVED***
    options = ***REMOVED******REMOVED***;
  ***REMOVED***
  if (!options.chunkSizeBytes) ***REMOVED***
    options.chunkSizeBytes = this.s.options.chunkSizeBytes;
  ***REMOVED***
  return new GridFSBucketWriteStream(this, filename, options);
***REMOVED***;

/**
 * Returns a writable stream (GridFSBucketWriteStream) for writing
 * buffers to GridFS for a custom file id. The stream's 'id' property contains the resulting
 * file's id.
 * @method
 * @param ***REMOVED***string|number|object***REMOVED*** id A custom id used to identify the file
 * @param ***REMOVED***string***REMOVED*** filename The value of the 'filename' key in the files doc
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***number***REMOVED*** [options.chunkSizeBytes=null] Optional overwrite this bucket's chunkSizeBytes for this file
 * @param ***REMOVED***object***REMOVED*** [options.metadata=null] Optional object to store in the file document's `metadata` field
 * @param ***REMOVED***string***REMOVED*** [options.contentType=null] Optional string to store in the file document's `contentType` field
 * @param ***REMOVED***array***REMOVED*** [options.aliases=null] Optional array of strings to store in the file document's `aliases` field
 * @return ***REMOVED***GridFSBucketWriteStream***REMOVED***
 */

GridFSBucket.prototype.openUploadStreamWithId = function(id, filename, options) ***REMOVED***
  if (options) ***REMOVED***
    options = shallowClone(options);
  ***REMOVED*** else ***REMOVED***
    options = ***REMOVED******REMOVED***;
  ***REMOVED***

  if (!options.chunkSizeBytes) ***REMOVED***
    options.chunkSizeBytes = this.s.options.chunkSizeBytes;
  ***REMOVED***

  options.id = id;

  return new GridFSBucketWriteStream(this, filename, options);
***REMOVED***;

/**
 * Returns a readable stream (GridFSBucketReadStream) for streaming file
 * data from GridFS.
 * @method
 * @param ***REMOVED***ObjectId***REMOVED*** id The id of the file doc
 * @param ***REMOVED***Object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***Number***REMOVED*** [options.start=null] Optional 0-based offset in bytes to start streaming from
 * @param ***REMOVED***Number***REMOVED*** [options.end=null] Optional 0-based offset in bytes to stop streaming before
 * @return ***REMOVED***GridFSBucketReadStream***REMOVED***
 */

GridFSBucket.prototype.openDownloadStream = function(id, options) ***REMOVED***
  var filter = ***REMOVED*** _id: id ***REMOVED***;
  options = ***REMOVED***
    start: options && options.start,
    end: options && options.end
  ***REMOVED***;

  return new GridFSBucketReadStream(this.s._chunksCollection,
    this.s._filesCollection, this.s.options.readPreference, filter, options);
***REMOVED***;

/**
 * Deletes a file with the given id
 * @method
 * @param ***REMOVED***ObjectId***REMOVED*** id The id of the file doc
 * @param ***REMOVED***GridFSBucket~errorCallback***REMOVED*** [callback]
 */

GridFSBucket.prototype.delete = function(id, callback) ***REMOVED***
  if (typeof callback === 'function') ***REMOVED***
    return _delete(this, id, callback);
  ***REMOVED***

  var _this = this;
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    _delete(_this, id, function(error, res) ***REMOVED***
      if (error) ***REMOVED***
        reject(error);
      ***REMOVED*** else ***REMOVED***
        resolve(res);
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***;

/**
 * @ignore
 */

function _delete(_this, id, callback) ***REMOVED***
  _this.s._filesCollection.deleteOne(***REMOVED*** _id: id ***REMOVED***, function(error, res) ***REMOVED***
    if (error) ***REMOVED***
      return callback(error);
    ***REMOVED***

    _this.s._chunksCollection.deleteMany(***REMOVED*** files_id: id ***REMOVED***, function(error) ***REMOVED***
      if (error) ***REMOVED***
        return callback(error);
      ***REMOVED***

      // Delete orphaned chunks before returning FileNotFound
      if (!res.result.n) ***REMOVED***
        var errmsg = 'FileNotFound: no file with id ' + id + ' found';
        return callback(new Error(errmsg));
      ***REMOVED***

      callback();
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

/**
 * Convenience wrapper around find on the files collection
 * @method
 * @param ***REMOVED***Object***REMOVED*** filter
 * @param ***REMOVED***Object***REMOVED*** [options=null] Optional settings for cursor
 * @param ***REMOVED***number***REMOVED*** [options.batchSize=null] Optional batch size for cursor
 * @param ***REMOVED***number***REMOVED*** [options.limit=null] Optional limit for cursor
 * @param ***REMOVED***number***REMOVED*** [options.maxTimeMS=null] Optional maxTimeMS for cursor
 * @param ***REMOVED***boolean***REMOVED*** [options.noCursorTimeout=null] Optionally set cursor's `noCursorTimeout` flag
 * @param ***REMOVED***number***REMOVED*** [options.skip=null] Optional skip for cursor
 * @param ***REMOVED***object***REMOVED*** [options.sort=null] Optional sort for cursor
 * @return ***REMOVED***Cursor***REMOVED***
 */

GridFSBucket.prototype.find = function(filter, options) ***REMOVED***
  filter = filter || ***REMOVED******REMOVED***;
  options = options || ***REMOVED******REMOVED***;

  var cursor = this.s._filesCollection.find(filter);

  if (options.batchSize != null) ***REMOVED***
    cursor.batchSize(options.batchSize);
  ***REMOVED***
  if (options.limit != null) ***REMOVED***
    cursor.limit(options.limit);
  ***REMOVED***
  if (options.maxTimeMS != null) ***REMOVED***
    cursor.maxTimeMS(options.maxTimeMS);
  ***REMOVED***
  if (options.noCursorTimeout != null) ***REMOVED***
    cursor.addCursorFlag('noCursorTimeout', options.noCursorTimeout);
  ***REMOVED***
  if (options.skip != null) ***REMOVED***
    cursor.skip(options.skip);
  ***REMOVED***
  if (options.sort != null) ***REMOVED***
    cursor.sort(options.sort);
  ***REMOVED***

  return cursor;
***REMOVED***;

/**
 * Returns a readable stream (GridFSBucketReadStream) for streaming the
 * file with the given name from GridFS. If there are multiple files with
 * the same name, this will stream the most recent file with the given name
 * (as determined by the `uploadDate` field). You can set the `revision`
 * option to change this behavior.
 * @method
 * @param ***REMOVED***String***REMOVED*** filename The name of the file to stream
 * @param ***REMOVED***Object***REMOVED*** [options=null] Optional settings
 * @param ***REMOVED***number***REMOVED*** [options.revision=-1] The revision number relative to the oldest file with the given filename. 0 gets you the oldest file, 1 gets you the 2nd oldest, -1 gets you the newest.
 * @param ***REMOVED***Number***REMOVED*** [options.start=null] Optional 0-based offset in bytes to start streaming from
 * @param ***REMOVED***Number***REMOVED*** [options.end=null] Optional 0-based offset in bytes to stop streaming before
 * @return ***REMOVED***GridFSBucketReadStream***REMOVED***
 */

GridFSBucket.prototype.openDownloadStreamByName = function(filename, options) ***REMOVED***
  var sort = ***REMOVED*** uploadDate: -1 ***REMOVED***;
  var skip = null;
  if (options && options.revision != null) ***REMOVED***
    if (options.revision >= 0) ***REMOVED***
      sort = ***REMOVED*** uploadDate: 1 ***REMOVED***;
      skip = options.revision;
    ***REMOVED*** else ***REMOVED***
      skip = -options.revision - 1;
    ***REMOVED***
  ***REMOVED***

  var filter = ***REMOVED*** filename: filename ***REMOVED***;
  options = ***REMOVED***
    sort: sort,
    skip: skip,
    start: options && options.start,
    end: options && options.end
  ***REMOVED***;
  return new GridFSBucketReadStream(this.s._chunksCollection,
    this.s._filesCollection, this.s.options.readPreference, filter, options);
***REMOVED***;

/**
 * Renames the file with the given _id to the given string
 * @method
 * @param ***REMOVED***ObjectId***REMOVED*** id the id of the file to rename
 * @param ***REMOVED***String***REMOVED*** filename new name for the file
 * @param ***REMOVED***GridFSBucket~errorCallback***REMOVED*** [callback]
 */

GridFSBucket.prototype.rename = function(id, filename, callback) ***REMOVED***
  if (typeof callback === 'function') ***REMOVED***
    return _rename(this, id, filename, callback);
  ***REMOVED***

  var _this = this;
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    _rename(_this, id, filename, function(error, res) ***REMOVED***
      if (error) ***REMOVED***
        reject(error);
      ***REMOVED*** else ***REMOVED***
        resolve(res);
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***;

/**
 * @ignore
 */

function _rename(_this, id, filename, callback) ***REMOVED***
  var filter = ***REMOVED*** _id: id ***REMOVED***;
  var update = ***REMOVED*** $set: ***REMOVED*** filename: filename ***REMOVED*** ***REMOVED***;
  _this.s._filesCollection.updateOne(filter, update, function(error, res) ***REMOVED***
    if (error) ***REMOVED***
      return callback(error);
    ***REMOVED***
    if (!res.result.n) ***REMOVED***
      return callback(toError('File with id ' + id + ' not found'));
    ***REMOVED***
    callback();
  ***REMOVED***);
***REMOVED***

/**
 * Removes this bucket's files collection, followed by its chunks collection.
 * @method
 * @param ***REMOVED***GridFSBucket~errorCallback***REMOVED*** [callback]
 */

GridFSBucket.prototype.drop = function(callback) ***REMOVED***
  if (typeof callback === 'function') ***REMOVED***
    return _drop(this, callback);
  ***REMOVED***

  var _this = this;
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    _drop(_this, function(error, res) ***REMOVED***
      if (error) ***REMOVED***
        reject(error);
      ***REMOVED*** else ***REMOVED***
        resolve(res);
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***;

/**
 * @ignore
 */

function _drop(_this, callback) ***REMOVED***
  _this.s._filesCollection.drop(function(error) ***REMOVED***
    if (error) ***REMOVED***
      return callback(error);
    ***REMOVED***
    _this.s._chunksCollection.drop(function(error) ***REMOVED***
      if (error) ***REMOVED***
        return callback(error);
      ***REMOVED***

      return callback();
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

/**
 * Callback format for all GridFSBucket methods that can accept a callback.
 * @callback GridFSBucket~errorCallback
 * @param ***REMOVED***MongoError***REMOVED*** error An error instance representing any errors that occurred
 */
