"use strict";

/**
 * @fileOverview GridFS is a tool for MongoDB to store files to the database.
 * Because of the restrictions of the object size the database can hold, a
 * facility to split a file into several chunks is needed. The ***REMOVED***@link GridStore***REMOVED***
 * class offers a simplified api to interact with files while managing the
 * chunks of split files behind the scenes. More information about GridFS can be
 * found <a href="http://www.mongodb.org/display/DOCS/GridFS">here</a>.
 *
 * @example
 * var MongoClient = require('mongodb').MongoClient,
 *   GridStore = require('mongodb').GridStore,
 *   ObjectID = require('mongodb').ObjectID,
 *   test = require('assert');
 *
 * // Connection url
 * var url = 'mongodb://localhost:27017/test';
 * // Connect using MongoClient
 * MongoClient.connect(url, function(err, db) ***REMOVED***
 *   var gridStore = new GridStore(db, null, "w");
 *   gridStore.open(function(err, gridStore) ***REMOVED***
 *     gridStore.write("hello world!", function(err, gridStore) ***REMOVED***
 *       gridStore.close(function(err, result) ***REMOVED***
 *
 *         // Let's read the file using object Id
 *         GridStore.read(db, result._id, function(err, data) ***REMOVED***
 *           test.equal('hello world!', data);
 *           db.close();
 *           test.done();
 *         ***REMOVED***);
 *       ***REMOVED***);
 *     ***REMOVED***);
 *   ***REMOVED***);
 * ***REMOVED***);
 */
var Chunk = require('./chunk'),
  ObjectID = require('mongodb-core').BSON.ObjectID,
  ReadPreference = require('../read_preference'),
  Buffer = require('buffer').Buffer,
  Collection = require('../collection'),
  fs = require('fs'),
  f = require('util').format,
  util = require('util'),
  Define = require('../metadata'),
  MongoError = require('mongodb-core').MongoError,
  inherits = util.inherits,
  Duplex = require('stream').Duplex || require('readable-stream').Duplex,
  shallowClone = require('../utils').shallowClone;

var REFERENCE_BY_FILENAME = 0,
  REFERENCE_BY_ID = 1;

/**
 * Namespace provided by the mongodb-core and node.js
 * @external Duplex
 */

/**
 * Create a new GridStore instance
 *
 * Modes
 *  - **"r"** - read only. This is the default mode.
 *  - **"w"** - write in truncate mode. Existing data will be overwriten.
 *
 * @class
 * @param ***REMOVED***Db***REMOVED*** db A database instance to interact with.
 * @param ***REMOVED***object***REMOVED*** [id] optional unique id for this file
 * @param ***REMOVED***string***REMOVED*** [filename] optional filename for this file, no unique constrain on the field
 * @param ***REMOVED***string***REMOVED*** mode set the mode for this file.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(number|string)***REMOVED*** [options.w=null] The write concern.
 * @param ***REMOVED***number***REMOVED*** [options.wtimeout=null] The write concern timeout.
 * @param ***REMOVED***boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param ***REMOVED***boolean***REMOVED*** [options.fsync=false] Specify a file sync write concern.
 * @param ***REMOVED***string***REMOVED*** [options.root=null] Root collection to use. Defaults to *****REMOVED***GridStore.DEFAULT_ROOT_COLLECTION***REMOVED*****.
 * @param ***REMOVED***string***REMOVED*** [options.content_type=null] MIME type of the file. Defaults to *****REMOVED***GridStore.DEFAULT_CONTENT_TYPE***REMOVED*****.
 * @param ***REMOVED***number***REMOVED*** [options.chunk_size=261120] Size for the chunk. Defaults to *****REMOVED***Chunk.DEFAULT_CHUNK_SIZE***REMOVED*****.
 * @param ***REMOVED***object***REMOVED*** [options.metadata=null] Arbitrary data the user wants to store.
 * @param ***REMOVED***object***REMOVED*** [options.promiseLibrary=null] A Promise library class the application wishes to use such as Bluebird, must be ES6 compatible
 * @param ***REMOVED***(ReadPreference|string)***REMOVED*** [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @property ***REMOVED***number***REMOVED*** chunkSize Get the gridstore chunk size.
 * @property ***REMOVED***number***REMOVED*** md5 The md5 checksum for this file.
 * @property ***REMOVED***number***REMOVED*** chunkNumber The current chunk number the gridstore has materialized into memory
 * @return ***REMOVED***GridStore***REMOVED*** a GridStore instance.
 * @deprecated Use GridFSBucket API instead
 */
var GridStore = function GridStore(db, id, filename, mode, options) ***REMOVED***
  if(!(this instanceof GridStore)) return new GridStore(db, id, filename, mode, options);
  this.db = db;

  // Handle options
  if(typeof options === 'undefined') options = ***REMOVED******REMOVED***;
  // Handle mode
  if(typeof mode === 'undefined') ***REMOVED***
    mode = filename;
    filename = undefined;
  ***REMOVED*** else if(typeof mode == 'object') ***REMOVED***
    options = mode;
    mode = filename;
    filename = undefined;
  ***REMOVED***

  if(id && id._bsontype == 'ObjectID') ***REMOVED***
    this.referenceBy = REFERENCE_BY_ID;
    this.fileId = id;
    this.filename = filename;
  ***REMOVED*** else if(typeof filename == 'undefined') ***REMOVED***
    this.referenceBy = REFERENCE_BY_FILENAME;
    this.filename = id;
    if (mode.indexOf('w') != null) ***REMOVED***
      this.fileId = new ObjectID();
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    this.referenceBy = REFERENCE_BY_ID;
    this.fileId = id;
    this.filename = filename;
  ***REMOVED***

  // Set up the rest
  this.mode = mode == null ? "r" : mode;
  this.options = options || ***REMOVED******REMOVED***;

  // Opened
  this.isOpen = false;

  // Set the root if overridden
  this.root = this.options['root'] == null ? GridStore.DEFAULT_ROOT_COLLECTION : this.options['root'];
  this.position = 0;
  this.readPreference = this.options.readPreference || db.options.readPreference || ReadPreference.PRIMARY;
  this.writeConcern = _getWriteConcern(db, this.options);
  // Set default chunk size
  this.internalChunkSize = this.options['chunkSize'] == null ? Chunk.DEFAULT_CHUNK_SIZE : this.options['chunkSize'];

  // Get the promiseLibrary
  var promiseLibrary = this.options.promiseLibrary;

  // No promise library selected fall back
  if(!promiseLibrary) ***REMOVED***
    promiseLibrary = typeof global.Promise == 'function' ?
      global.Promise : require('es6-promise').Promise;
  ***REMOVED***

  // Set the promiseLibrary
  this.promiseLibrary = promiseLibrary;

  Object.defineProperty(this, "chunkSize", ***REMOVED*** enumerable: true
   , get: function () ***REMOVED***
       return this.internalChunkSize;
     ***REMOVED***
   , set: function(value) ***REMOVED***
       if(!(this.mode[0] == "w" && this.position == 0 && this.uploadDate == null)) ***REMOVED***
         this.internalChunkSize = this.internalChunkSize;
       ***REMOVED*** else ***REMOVED***
         this.internalChunkSize = value;
       ***REMOVED***
     ***REMOVED***
  ***REMOVED***);

  Object.defineProperty(this, "md5", ***REMOVED*** enumerable: true
   , get: function () ***REMOVED***
       return this.internalMd5;
     ***REMOVED***
  ***REMOVED***);

  Object.defineProperty(this, "chunkNumber", ***REMOVED*** enumerable: true
   , get: function () ***REMOVED***
       return this.currentChunk && this.currentChunk.chunkNumber ? this.currentChunk.chunkNumber : null;
     ***REMOVED***
  ***REMOVED***);
***REMOVED***

var define = GridStore.define = new Define('Gridstore', GridStore, true);

/**
 * The callback format for the Gridstore.open method
 * @callback GridStore~openCallback
 * @param ***REMOVED***MongoError***REMOVED*** error An error instance representing the error during the execution.
 * @param ***REMOVED***GridStore***REMOVED*** gridStore The GridStore instance if the open method was successful.
 */

/**
 * Opens the file from the database and initialize this object. Also creates a
 * new one if file does not exist.
 *
 * @method
 * @param ***REMOVED***GridStore~openCallback***REMOVED*** [callback] this will be called after executing this method
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 * @deprecated Use GridFSBucket API instead
 */
GridStore.prototype.open = function(callback) ***REMOVED***
  var self = this;
  if( this.mode != "w" && this.mode != "w+" && this.mode != "r")***REMOVED***
    throw MongoError.create(***REMOVED***message: "Illegal mode " + this.mode, driver:true***REMOVED***);
  ***REMOVED***

  // We provided a callback leg
  if(typeof callback == 'function') return open(self, callback);
  // Return promise
  return new self.promiseLibrary(function(resolve, reject) ***REMOVED***
    open(self, function(err, store) ***REMOVED***
      if(err) return reject(err);
      resolve(store);
    ***REMOVED***)
  ***REMOVED***);
***REMOVED***;

var open = function(self, callback) ***REMOVED***
  // Get the write concern
  var writeConcern = _getWriteConcern(self.db, self.options);

  // If we are writing we need to ensure we have the right indexes for md5's
  if((self.mode == "w" || self.mode == "w+")) ***REMOVED***
    // Get files collection
    var collection = self.collection();
    // Put index on filename
    collection.ensureIndex([['filename', 1]], writeConcern, function() ***REMOVED***
      // Get chunk collection
      var chunkCollection = self.chunkCollection();
      // Make an unique index for compatibility with mongo-cxx-driver:legacy
      var chunkIndexOptions = shallowClone(writeConcern);
      chunkIndexOptions.unique = true;
      // Ensure index on chunk collection
      chunkCollection.ensureIndex([['files_id', 1], ['n', 1]], chunkIndexOptions, function() ***REMOVED***
        // Open the connection
        _open(self, writeConcern, function(err, r) ***REMOVED***
          if(err) return callback(err);
          self.isOpen = true;
          callback(err, r);
        ***REMOVED***);
      ***REMOVED***);
    ***REMOVED***);
  ***REMOVED*** else ***REMOVED***
    // Open the gridstore
    _open(self, writeConcern, function(err, r) ***REMOVED***
      if(err) return callback(err);
      self.isOpen = true;
      callback(err, r);
    ***REMOVED***);
  ***REMOVED***
***REMOVED***

// Push the definition for open
define.classMethod('open', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Verify if the file is at EOF.
 *
 * @method
 * @return ***REMOVED***boolean***REMOVED*** true if the read/write head is at the end of this file.
 * @deprecated Use GridFSBucket API instead
 */
GridStore.prototype.eof = function() ***REMOVED***
  return this.position == this.length ? true : false;
***REMOVED***

define.classMethod('eof', ***REMOVED***callback: false, promise:false, returns: [Boolean]***REMOVED***);

/**
 * The callback result format.
 * @callback GridStore~resultCallback
 * @param ***REMOVED***MongoError***REMOVED*** error An error instance representing the error during the execution.
 * @param ***REMOVED***object***REMOVED*** result The result from the callback.
 */

/**
 * Retrieves a single character from this file.
 *
 * @method
 * @param ***REMOVED***GridStore~resultCallback***REMOVED*** [callback] this gets called after this method is executed. Passes null to the first parameter and the character read to the second or null to the second if the read/write head is at the end of the file.
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 * @deprecated Use GridFSBucket API instead
 */
GridStore.prototype.getc = function(callback) ***REMOVED***
  var self = this;
  // We provided a callback leg
  if(typeof callback == 'function') return eof(self, callback);
  // Return promise
  return new self.promiseLibrary(function(resolve, reject) ***REMOVED***
    eof(self, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***)
  ***REMOVED***);
***REMOVED***

var eof = function(self, callback) ***REMOVED***
  if(self.eof()) ***REMOVED***
    callback(null, null);
  ***REMOVED*** else if(self.currentChunk.eof()) ***REMOVED***
    nthChunk(self, self.currentChunk.chunkNumber + 1, function(err, chunk) ***REMOVED***
      self.currentChunk = chunk;
      self.position = self.position + 1;
      callback(err, self.currentChunk.getc());
    ***REMOVED***);
  ***REMOVED*** else ***REMOVED***
    self.position = self.position + 1;
    callback(null, self.currentChunk.getc());
  ***REMOVED***
***REMOVED***

define.classMethod('getc', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Writes a string to the file with a newline character appended at the end if
 * the given string does not have one.
 *
 * @method
 * @param ***REMOVED***string***REMOVED*** string the string to write.
 * @param ***REMOVED***GridStore~resultCallback***REMOVED*** [callback] this will be called after executing this method. The first parameter will contain null and the second one will contain a reference to this object.
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 * @deprecated Use GridFSBucket API instead
 */
GridStore.prototype.puts = function(string, callback) ***REMOVED***
  var self = this;
  var finalString = string.match(/\n$/) == null ? string + "\n" : string;
  // We provided a callback leg
  if(typeof callback == 'function') return this.write(finalString, callback);
  // Return promise
  return new self.promiseLibrary(function(resolve, reject) ***REMOVED***
    self.write(finalString, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***)
  ***REMOVED***);
***REMOVED***

define.classMethod('puts', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Return a modified Readable stream including a possible transform method.
 *
 * @method
 * @return ***REMOVED***GridStoreStream***REMOVED***
 * @deprecated Use GridFSBucket API instead
 */
GridStore.prototype.stream = function() ***REMOVED***
  return new GridStoreStream(this);
***REMOVED***

define.classMethod('stream', ***REMOVED***callback: false, promise:false, returns: [GridStoreStream]***REMOVED***);

/**
 * Writes some data. This method will work properly only if initialized with mode "w" or "w+".
 *
 * @method
 * @param ***REMOVED***(string|Buffer)***REMOVED*** data the data to write.
 * @param ***REMOVED***boolean***REMOVED*** [close] closes this file after writing if set to true.
 * @param ***REMOVED***GridStore~resultCallback***REMOVED*** [callback] this will be called after executing this method. The first parameter will contain null and the second one will contain a reference to this object.
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 * @deprecated Use GridFSBucket API instead
 */
GridStore.prototype.write = function write(data, close, callback) ***REMOVED***
  var self = this;
  // We provided a callback leg
  if(typeof callback == 'function') return _writeNormal(this, data, close, callback);
  // Return promise
  return new self.promiseLibrary(function(resolve, reject) ***REMOVED***
    _writeNormal(self, data, close, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***)
  ***REMOVED***);
***REMOVED***

define.classMethod('write', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Handles the destroy part of a stream
 *
 * @method
 * @result ***REMOVED***null***REMOVED***
 * @deprecated Use GridFSBucket API instead
 */
GridStore.prototype.destroy = function destroy() ***REMOVED***
  // close and do not emit any more events. queued data is not sent.
  if(!this.writable) return;
  this.readable = false;
  if(this.writable) ***REMOVED***
    this.writable = false;
    this._q.length = 0;
    this.emit('close');
  ***REMOVED***
***REMOVED***

define.classMethod('destroy', ***REMOVED***callback: false, promise:false***REMOVED***);

/**
 * Stores a file from the file system to the GridFS database.
 *
 * @method
 * @param ***REMOVED***(string|Buffer|FileHandle)***REMOVED*** file the file to store.
 * @param ***REMOVED***GridStore~resultCallback***REMOVED*** [callback] this will be called after executing this method. The first parameter will contain null and the second one will contain a reference to this object.
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 * @deprecated Use GridFSBucket API instead
 */
GridStore.prototype.writeFile = function (file, callback) ***REMOVED***
  var self = this;
  // We provided a callback leg
  if(typeof callback == 'function') return writeFile(self, file, callback);
  // Return promise
  return new self.promiseLibrary(function(resolve, reject) ***REMOVED***
    writeFile(self, file, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***)
  ***REMOVED***);
***REMOVED***;

var writeFile = function(self, file, callback) ***REMOVED***
  if (typeof file === 'string') ***REMOVED***
    fs.open(file, 'r', function (err, fd) ***REMOVED***
      if(err) return callback(err);
      self.writeFile(fd, callback);
    ***REMOVED***);
    return;
  ***REMOVED***

  self.open(function (err, self) ***REMOVED***
    if(err) return callback(err, self);

    fs.fstat(file, function (err, stats) ***REMOVED***
      if(err) return callback(err, self);

      var offset = 0;
      var index = 0;

      // Write a chunk
      var writeChunk = function() ***REMOVED***
        fs.read(file, self.chunkSize, offset, 'binary', function(err, data, bytesRead) ***REMOVED***
          if(err) return callback(err, self);

          offset = offset + bytesRead;

          // Create a new chunk for the data
          var chunk = new Chunk(self, ***REMOVED***n:index++***REMOVED***, self.writeConcern);
          chunk.write(data, function(err, chunk) ***REMOVED***
            if(err) return callback(err, self);

            chunk.save(***REMOVED******REMOVED***, function(err) ***REMOVED***
              if(err) return callback(err, self);

              self.position = self.position + data.length;

              // Point to current chunk
              self.currentChunk = chunk;

              if(offset >= stats.size) ***REMOVED***
                fs.close(file);
                self.close(function(err) ***REMOVED***
                  if(err) return callback(err, self);
                  return callback(null, self);
                ***REMOVED***);
              ***REMOVED*** else ***REMOVED***
                return process.nextTick(writeChunk);
              ***REMOVED***
            ***REMOVED***);
          ***REMOVED***);
        ***REMOVED***);
      ***REMOVED***

      // Process the first write
      process.nextTick(writeChunk);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

define.classMethod('writeFile', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Saves this file to the database. This will overwrite the old entry if it
 * already exists. This will work properly only if mode was initialized to
 * "w" or "w+".
 *
 * @method
 * @param ***REMOVED***GridStore~resultCallback***REMOVED*** [callback] this will be called after executing this method. The first parameter will contain null and the second one will contain a reference to this object.
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 * @deprecated Use GridFSBucket API instead
 */
GridStore.prototype.close = function(callback) ***REMOVED***
  var self = this;
  // We provided a callback leg
  if(typeof callback == 'function') return close(self, callback);
  // Return promise
  return new self.promiseLibrary(function(resolve, reject) ***REMOVED***
    close(self, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***)
  ***REMOVED***);
***REMOVED***;

var close = function(self, callback) ***REMOVED***
  if(self.mode[0] == "w") ***REMOVED***
    // Set up options
    var options = self.writeConcern;

    if(self.currentChunk != null && self.currentChunk.position > 0) ***REMOVED***
      self.currentChunk.save(***REMOVED******REMOVED***, function(err) ***REMOVED***
        if(err && typeof callback == 'function') return callback(err);

        self.collection(function(err, files) ***REMOVED***
          if(err && typeof callback == 'function') return callback(err);

          // Build the mongo object
          if(self.uploadDate != null) ***REMOVED***
            buildMongoObject(self, function(err, mongoObject) ***REMOVED***
              if(err) ***REMOVED***
                if(typeof callback == 'function') return callback(err); else throw err;
              ***REMOVED***

              files.save(mongoObject, options, function(err) ***REMOVED***
                if(typeof callback == 'function')
                  callback(err, mongoObject);
              ***REMOVED***);
            ***REMOVED***);
          ***REMOVED*** else ***REMOVED***
            self.uploadDate = new Date();
            buildMongoObject(self, function(err, mongoObject) ***REMOVED***
              if(err) ***REMOVED***
                if(typeof callback == 'function') return callback(err); else throw err;
              ***REMOVED***

              files.save(mongoObject, options, function(err) ***REMOVED***
                if(typeof callback == 'function')
                  callback(err, mongoObject);
              ***REMOVED***);
            ***REMOVED***);
          ***REMOVED***
        ***REMOVED***);
      ***REMOVED***);
    ***REMOVED*** else ***REMOVED***
      self.collection(function(err, files) ***REMOVED***
        if(err && typeof callback == 'function') return callback(err);

        self.uploadDate = new Date();
        buildMongoObject(self, function(err, mongoObject) ***REMOVED***
          if(err) ***REMOVED***
            if(typeof callback == 'function') return callback(err); else throw err;
          ***REMOVED***

          files.save(mongoObject, options, function(err) ***REMOVED***
            if(typeof callback == 'function')
              callback(err, mongoObject);
          ***REMOVED***);
        ***REMOVED***);
      ***REMOVED***);
    ***REMOVED***
  ***REMOVED*** else if(self.mode[0] == "r") ***REMOVED***
    if(typeof callback == 'function')
      callback(null, null);
  ***REMOVED*** else ***REMOVED***
    if(typeof callback == 'function')
      callback(MongoError.create(***REMOVED***message: f("Illegal mode %s", self.mode), driver:true***REMOVED***));
  ***REMOVED***
***REMOVED***

define.classMethod('close', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * The collection callback format.
 * @callback GridStore~collectionCallback
 * @param ***REMOVED***MongoError***REMOVED*** error An error instance representing the error during the execution.
 * @param ***REMOVED***Collection***REMOVED*** collection The collection from the command execution.
 */

/**
 * Retrieve this file's chunks collection.
 *
 * @method
 * @param ***REMOVED***GridStore~collectionCallback***REMOVED*** callback the command callback.
 * @return ***REMOVED***Collection***REMOVED***
 * @deprecated Use GridFSBucket API instead
 */
GridStore.prototype.chunkCollection = function(callback) ***REMOVED***
  if(typeof callback == 'function')
    return this.db.collection((this.root + ".chunks"), callback);
  return this.db.collection((this.root + ".chunks"));
***REMOVED***;

define.classMethod('chunkCollection', ***REMOVED***callback: true, promise:false, returns: [Collection]***REMOVED***);

/**
 * Deletes all the chunks of this file in the database.
 *
 * @method
 * @param ***REMOVED***GridStore~resultCallback***REMOVED*** [callback] the command callback.
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 * @deprecated Use GridFSBucket API instead
 */
GridStore.prototype.unlink = function(callback) ***REMOVED***
  var self = this;
  // We provided a callback leg
  if(typeof callback == 'function') return unlink(self, callback);
  // Return promise
  return new self.promiseLibrary(function(resolve, reject) ***REMOVED***
    unlink(self, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***)
  ***REMOVED***);
***REMOVED***;

var unlink = function(self, callback) ***REMOVED***
  deleteChunks(self, function(err) ***REMOVED***
    if(err!==null) ***REMOVED***
      err.message = "at deleteChunks: " + err.message;
      return callback(err);
    ***REMOVED***

    self.collection(function(err, collection) ***REMOVED***
      if(err!==null) ***REMOVED***
        err.message = "at collection: " + err.message;
        return callback(err);
      ***REMOVED***

      collection.remove(***REMOVED***'_id':self.fileId***REMOVED***, self.writeConcern, function(err) ***REMOVED***
        callback(err, self);
      ***REMOVED***);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

define.classMethod('unlink', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Retrieves the file collection associated with this object.
 *
 * @method
 * @param ***REMOVED***GridStore~collectionCallback***REMOVED*** callback the command callback.
 * @return ***REMOVED***Collection***REMOVED***
 * @deprecated Use GridFSBucket API instead
 */
GridStore.prototype.collection = function(callback) ***REMOVED***
  if(typeof callback == 'function')
    this.db.collection(this.root + ".files", callback);
  return this.db.collection(this.root + ".files");
***REMOVED***;

define.classMethod('collection', ***REMOVED***callback: true, promise:false, returns: [Collection]***REMOVED***);

/**
 * The readlines callback format.
 * @callback GridStore~readlinesCallback
 * @param ***REMOVED***MongoError***REMOVED*** error An error instance representing the error during the execution.
 * @param ***REMOVED***string[]***REMOVED*** strings The array of strings returned.
 */

/**
 * Read the entire file as a list of strings splitting by the provided separator.
 *
 * @method
 * @param ***REMOVED***string***REMOVED*** [separator] The character to be recognized as the newline separator.
 * @param ***REMOVED***GridStore~readlinesCallback***REMOVED*** [callback] the command callback.
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 * @deprecated Use GridFSBucket API instead
 */
GridStore.prototype.readlines = function(separator, callback) ***REMOVED***
  var self = this;
  var args = Array.prototype.slice.call(arguments, 0);
  callback = args.pop();
  if(typeof callback != 'function') args.push(callback);
  separator = args.length ? args.shift() : "\n";
  separator = separator || "\n";

  // We provided a callback leg
  if(typeof callback == 'function') return readlines(self, separator, callback);

  // Return promise
  return new self.promiseLibrary(function(resolve, reject) ***REMOVED***
    readlines(self, separator, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***)
  ***REMOVED***);
***REMOVED***;

var readlines = function(self, separator, callback) ***REMOVED***
  self.read(function(err, data) ***REMOVED***
    if(err) return callback(err);

    var items = data.toString().split(separator);
    items = items.length > 0 ? items.splice(0, items.length - 1) : [];
    for(var i = 0; i < items.length; i++) ***REMOVED***
      items[i] = items[i] + separator;
    ***REMOVED***

    callback(null, items);
  ***REMOVED***);
***REMOVED***

define.classMethod('readlines', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Deletes all the chunks of this file in the database if mode was set to "w" or
 * "w+" and resets the read/write head to the initial position.
 *
 * @method
 * @param ***REMOVED***GridStore~resultCallback***REMOVED*** [callback] this will be called after executing this method. The first parameter will contain null and the second one will contain a reference to this object.
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 * @deprecated Use GridFSBucket API instead
 */
GridStore.prototype.rewind = function(callback) ***REMOVED***
  var self = this;
  // We provided a callback leg
  if(typeof callback == 'function') return rewind(self, callback);
  // Return promise
  return new self.promiseLibrary(function(resolve, reject) ***REMOVED***
    rewind(self, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***)
  ***REMOVED***);
***REMOVED***;

var rewind = function(self, callback) ***REMOVED***
  if(self.currentChunk.chunkNumber != 0) ***REMOVED***
    if(self.mode[0] == "w") ***REMOVED***
      deleteChunks(self, function(err) ***REMOVED***
        if(err) return callback(err);
        self.currentChunk = new Chunk(self, ***REMOVED***'n': 0***REMOVED***, self.writeConcern);
        self.position = 0;
        callback(null, self);
      ***REMOVED***);
    ***REMOVED*** else ***REMOVED***
      self.currentChunk(0, function(err, chunk) ***REMOVED***
        if(err) return callback(err);
        self.currentChunk = chunk;
        self.currentChunk.rewind();
        self.position = 0;
        callback(null, self);
      ***REMOVED***);
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    self.currentChunk.rewind();
    self.position = 0;
    callback(null, self);
  ***REMOVED***
***REMOVED***

define.classMethod('rewind', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * The read callback format.
 * @callback GridStore~readCallback
 * @param ***REMOVED***MongoError***REMOVED*** error An error instance representing the error during the execution.
 * @param ***REMOVED***Buffer***REMOVED*** data The data read from the GridStore object
 */

/**
 * Retrieves the contents of this file and advances the read/write head. Works with Buffers only.
 *
 * There are 3 signatures for this method:
 *
 * (callback)
 * (length, callback)
 * (length, buffer, callback)
 *
 * @method
 * @param ***REMOVED***number***REMOVED*** [length] the number of characters to read. Reads all the characters from the read/write head to the EOF if not specified.
 * @param ***REMOVED***(string|Buffer)***REMOVED*** [buffer] a string to hold temporary data. This is used for storing the string data read so far when recursively calling this method.
 * @param ***REMOVED***GridStore~readCallback***REMOVED*** [callback] the command callback.
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 * @deprecated Use GridFSBucket API instead
 */
GridStore.prototype.read = function(length, buffer, callback) ***REMOVED***
  var self = this;

  var args = Array.prototype.slice.call(arguments, 0);
  callback = args.pop();
  if(typeof callback != 'function') args.push(callback);
  length = args.length ? args.shift() : null;
  buffer = args.length ? args.shift() : null;
  // We provided a callback leg
  if(typeof callback == 'function') return read(self, length, buffer, callback);
  // Return promise
  return new self.promiseLibrary(function(resolve, reject) ***REMOVED***
    read(self, length, buffer, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***)
  ***REMOVED***);
***REMOVED***

var read = function(self, length, buffer, callback) ***REMOVED***
  // The data is a c-terminated string and thus the length - 1
  var finalLength = length == null ? self.length - self.position : length;
  var finalBuffer = buffer == null ? new Buffer(finalLength) : buffer;
  // Add a index to buffer to keep track of writing position or apply current index
  finalBuffer._index = buffer != null && buffer._index != null ? buffer._index : 0;

  if((self.currentChunk.length() - self.currentChunk.position + finalBuffer._index) >= finalLength) ***REMOVED***
    var slice = self.currentChunk.readSlice(finalLength - finalBuffer._index);
    // Copy content to final buffer
    slice.copy(finalBuffer, finalBuffer._index);
    // Update internal position
    self.position = self.position + finalBuffer.length;
    // Check if we don't have a file at all
    if(finalLength == 0 && finalBuffer.length == 0) return callback(MongoError.create(***REMOVED***message: "File does not exist", driver:true***REMOVED***), null);
    // Else return data
    return callback(null, finalBuffer);
  ***REMOVED***

  // Read the next chunk
  slice = self.currentChunk.readSlice(self.currentChunk.length() - self.currentChunk.position);
  // Copy content to final buffer
  slice.copy(finalBuffer, finalBuffer._index);
  // Update index position
  finalBuffer._index += slice.length;

  // Load next chunk and read more
  nthChunk(self, self.currentChunk.chunkNumber + 1, function(err, chunk) ***REMOVED***
    if(err) return callback(err);

    if(chunk.length() > 0) ***REMOVED***
      self.currentChunk = chunk;
      self.read(length, finalBuffer, callback);
    ***REMOVED*** else ***REMOVED***
      if(finalBuffer._index > 0) ***REMOVED***
        callback(null, finalBuffer)
      ***REMOVED*** else ***REMOVED***
        callback(MongoError.create(***REMOVED***message: "no chunks found for file, possibly corrupt", driver:true***REMOVED***), null);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***);
***REMOVED***

define.classMethod('read', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * The tell callback format.
 * @callback GridStore~tellCallback
 * @param ***REMOVED***MongoError***REMOVED*** error An error instance representing the error during the execution.
 * @param ***REMOVED***number***REMOVED*** position The current read position in the GridStore.
 */

/**
 * Retrieves the position of the read/write head of this file.
 *
 * @method
 * @param ***REMOVED***number***REMOVED*** [length] the number of characters to read. Reads all the characters from the read/write head to the EOF if not specified.
 * @param ***REMOVED***(string|Buffer)***REMOVED*** [buffer] a string to hold temporary data. This is used for storing the string data read so far when recursively calling this method.
 * @param ***REMOVED***GridStore~tellCallback***REMOVED*** [callback] the command callback.
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 * @deprecated Use GridFSBucket API instead
 */
GridStore.prototype.tell = function(callback) ***REMOVED***
  var self = this;
  // We provided a callback leg
  if(typeof callback == 'function') return callback(null, this.position);
  // Return promise
  return new self.promiseLibrary(function(resolve) ***REMOVED***
    resolve(self.position);
  ***REMOVED***);
***REMOVED***;

define.classMethod('tell', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * The tell callback format.
 * @callback GridStore~gridStoreCallback
 * @param ***REMOVED***MongoError***REMOVED*** error An error instance representing the error during the execution.
 * @param ***REMOVED***GridStore***REMOVED*** gridStore The gridStore.
 */

/**
 * Moves the read/write head to a new location.
 *
 * There are 3 signatures for this method
 *
 * Seek Location Modes
 *  - **GridStore.IO_SEEK_SET**, **(default)** set the position from the start of the file.
 *  - **GridStore.IO_SEEK_CUR**, set the position from the current position in the file.
 *  - **GridStore.IO_SEEK_END**, set the position from the end of the file.
 *
 * @method
 * @param ***REMOVED***number***REMOVED*** [position] the position to seek to
 * @param ***REMOVED***number***REMOVED*** [seekLocation] seek mode. Use one of the Seek Location modes.
 * @param ***REMOVED***GridStore~gridStoreCallback***REMOVED*** [callback] the command callback.
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 * @deprecated Use GridFSBucket API instead
 */
GridStore.prototype.seek = function(position, seekLocation, callback) ***REMOVED***
  var self = this;

  var args = Array.prototype.slice.call(arguments, 1);
  callback = args.pop();
  if(typeof callback != 'function') args.push(callback);
  seekLocation = args.length ? args.shift() : null;

  // We provided a callback leg
  if(typeof callback == 'function') return seek(self, position, seekLocation, callback);
  // Return promise
  return new self.promiseLibrary(function(resolve, reject) ***REMOVED***
    seek(self, position, seekLocation, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***)
  ***REMOVED***);
***REMOVED***

var seek = function(self, position, seekLocation, callback) ***REMOVED***
  // Seek only supports read mode
  if(self.mode != 'r') ***REMOVED***
    return callback(MongoError.create(***REMOVED***message: "seek is only supported for mode r", driver:true***REMOVED***))
  ***REMOVED***

  var seekLocationFinal = seekLocation == null ? GridStore.IO_SEEK_SET : seekLocation;
  var finalPosition = position;
  var targetPosition = 0;

  // Calculate the position
  if(seekLocationFinal == GridStore.IO_SEEK_CUR) ***REMOVED***
    targetPosition = self.position + finalPosition;
  ***REMOVED*** else if(seekLocationFinal == GridStore.IO_SEEK_END) ***REMOVED***
    targetPosition = self.length + finalPosition;
  ***REMOVED*** else ***REMOVED***
    targetPosition = finalPosition;
  ***REMOVED***

  // Get the chunk
  var newChunkNumber = Math.floor(targetPosition/self.chunkSize);
  var seekChunk = function() ***REMOVED***
    nthChunk(self, newChunkNumber, function(err, chunk) ***REMOVED***
      if(err) return callback(err, null);
      if(chunk == null) return callback(new Error('no chunk found'));

      // Set the current chunk
      self.currentChunk = chunk;
      self.position = targetPosition;
      self.currentChunk.position = (self.position % self.chunkSize);
      callback(err, self);
    ***REMOVED***);
  ***REMOVED***;

  seekChunk();
***REMOVED***

define.classMethod('seek', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * @ignore
 */
var _open = function(self, options, callback) ***REMOVED***
  var collection = self.collection();
  // Create the query
  var query = self.referenceBy == REFERENCE_BY_ID ? ***REMOVED***_id:self.fileId***REMOVED*** : ***REMOVED***filename:self.filename***REMOVED***;
  query = null == self.fileId && self.filename == null ? null : query;
  options.readPreference = self.readPreference;

  // Fetch the chunks
  if(query != null) ***REMOVED***
    collection.findOne(query, options, function(err, doc) ***REMOVED***
      if(err) return error(err);

      // Check if the collection for the files exists otherwise prepare the new one
      if(doc != null) ***REMOVED***
        self.fileId = doc._id;
        // Prefer a new filename over the existing one if this is a write
        self.filename = ((self.mode == 'r') || (self.filename == undefined)) ? doc.filename : self.filename;
        self.contentType = doc.contentType;
        self.internalChunkSize = doc.chunkSize;
        self.uploadDate = doc.uploadDate;
        self.aliases = doc.aliases;
        self.length = doc.length;
        self.metadata = doc.metadata;
        self.internalMd5 = doc.md5;
      ***REMOVED*** else if (self.mode != 'r') ***REMOVED***
        self.fileId = self.fileId == null ? new ObjectID() : self.fileId;
        self.contentType = GridStore.DEFAULT_CONTENT_TYPE;
        self.internalChunkSize = self.internalChunkSize == null ? Chunk.DEFAULT_CHUNK_SIZE : self.internalChunkSize;
        self.length = 0;
      ***REMOVED*** else ***REMOVED***
        self.length = 0;
        var txtId = self.fileId._bsontype == "ObjectID" ? self.fileId.toHexString() : self.fileId;
        return error(MongoError.create(***REMOVED***message: f("file with id %s not opened for writing", (self.referenceBy == REFERENCE_BY_ID ? txtId : self.filename)), driver:true***REMOVED***), self);
      ***REMOVED***

      // Process the mode of the object
      if(self.mode == "r") ***REMOVED***
        nthChunk(self, 0, options, function(err, chunk) ***REMOVED***
          if(err) return error(err);
          self.currentChunk = chunk;
          self.position = 0;
          callback(null, self);
        ***REMOVED***);
      ***REMOVED*** else if(self.mode == "w" && doc) ***REMOVED***
        // Delete any existing chunks
        deleteChunks(self, options, function(err) ***REMOVED***
          if(err) return error(err);
          self.currentChunk = new Chunk(self, ***REMOVED***'n':0***REMOVED***, self.writeConcern);
          self.contentType = self.options['content_type'] == null ? self.contentType : self.options['content_type'];
          self.internalChunkSize = self.options['chunk_size'] == null ? self.internalChunkSize : self.options['chunk_size'];
          self.metadata = self.options['metadata'] == null ? self.metadata : self.options['metadata'];
          self.aliases = self.options['aliases'] == null ? self.aliases : self.options['aliases'];
          self.position = 0;
          callback(null, self);
        ***REMOVED***);
      ***REMOVED*** else if(self.mode == "w") ***REMOVED***
        self.currentChunk = new Chunk(self, ***REMOVED***'n':0***REMOVED***, self.writeConcern);
        self.contentType = self.options['content_type'] == null ? self.contentType : self.options['content_type'];
        self.internalChunkSize = self.options['chunk_size'] == null ? self.internalChunkSize : self.options['chunk_size'];
        self.metadata = self.options['metadata'] == null ? self.metadata : self.options['metadata'];
        self.aliases = self.options['aliases'] == null ? self.aliases : self.options['aliases'];
        self.position = 0;
        callback(null, self);
      ***REMOVED*** else if(self.mode == "w+") ***REMOVED***
        nthChunk(self, lastChunkNumber(self), options, function(err, chunk) ***REMOVED***
          if(err) return error(err);
          // Set the current chunk
          self.currentChunk = chunk == null ? new Chunk(self, ***REMOVED***'n':0***REMOVED***, self.writeConcern) : chunk;
          self.currentChunk.position = self.currentChunk.data.length();
          self.metadata = self.options['metadata'] == null ? self.metadata : self.options['metadata'];
          self.aliases = self.options['aliases'] == null ? self.aliases : self.options['aliases'];
          self.position = self.length;
          callback(null, self);
        ***REMOVED***);
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED*** else ***REMOVED***
    // Write only mode
    self.fileId = null == self.fileId ? new ObjectID() : self.fileId;
    self.contentType = GridStore.DEFAULT_CONTENT_TYPE;
    self.internalChunkSize = self.internalChunkSize == null ? Chunk.DEFAULT_CHUNK_SIZE : self.internalChunkSize;
    self.length = 0;

    // No file exists set up write mode
    if(self.mode == "w") ***REMOVED***
      // Delete any existing chunks
      deleteChunks(self, options, function(err) ***REMOVED***
        if(err) return error(err);
        self.currentChunk = new Chunk(self, ***REMOVED***'n':0***REMOVED***, self.writeConcern);
        self.contentType = self.options['content_type'] == null ? self.contentType : self.options['content_type'];
        self.internalChunkSize = self.options['chunk_size'] == null ? self.internalChunkSize : self.options['chunk_size'];
        self.metadata = self.options['metadata'] == null ? self.metadata : self.options['metadata'];
        self.aliases = self.options['aliases'] == null ? self.aliases : self.options['aliases'];
        self.position = 0;
        callback(null, self);
      ***REMOVED***);
    ***REMOVED*** else if(self.mode == "w+") ***REMOVED***
      nthChunk(self, lastChunkNumber(self), options, function(err, chunk) ***REMOVED***
        if(err) return error(err);
        // Set the current chunk
        self.currentChunk = chunk == null ? new Chunk(self, ***REMOVED***'n':0***REMOVED***, self.writeConcern) : chunk;
        self.currentChunk.position = self.currentChunk.data.length();
        self.metadata = self.options['metadata'] == null ? self.metadata : self.options['metadata'];
        self.aliases = self.options['aliases'] == null ? self.aliases : self.options['aliases'];
        self.position = self.length;
        callback(null, self);
      ***REMOVED***);
    ***REMOVED***
  ***REMOVED***

  // only pass error to callback once
  function error (err) ***REMOVED***
    if(error.err) return;
    callback(error.err = err);
  ***REMOVED***
***REMOVED***;

/**
 * @ignore
 */
var writeBuffer = function(self, buffer, close, callback) ***REMOVED***
  if(typeof close === "function") ***REMOVED*** callback = close; close = null; ***REMOVED***
  var finalClose = typeof close == 'boolean' ? close : false;

  if(self.mode != "w") ***REMOVED***
    callback(MongoError.create(***REMOVED***message: f("file with id %s not opened for writing", (self.referenceBy == REFERENCE_BY_ID ? self.referenceBy : self.filename)), driver:true***REMOVED***), null);
  ***REMOVED*** else ***REMOVED***
    if(self.currentChunk.position + buffer.length >= self.chunkSize) ***REMOVED***
      // Write out the current Chunk and then keep writing until we have less data left than a chunkSize left
      // to a new chunk (recursively)
      var previousChunkNumber = self.currentChunk.chunkNumber;
      var leftOverDataSize = self.chunkSize - self.currentChunk.position;
      var firstChunkData = buffer.slice(0, leftOverDataSize);
      var leftOverData = buffer.slice(leftOverDataSize);
      // A list of chunks to write out
      var chunksToWrite = [self.currentChunk.write(firstChunkData)];
      // If we have more data left than the chunk size let's keep writing new chunks
      while(leftOverData.length >= self.chunkSize) ***REMOVED***
        // Create a new chunk and write to it
        var newChunk = new Chunk(self, ***REMOVED***'n': (previousChunkNumber + 1)***REMOVED***, self.writeConcern);
        firstChunkData = leftOverData.slice(0, self.chunkSize);
        leftOverData = leftOverData.slice(self.chunkSize);
        // Update chunk number
        previousChunkNumber = previousChunkNumber + 1;
        // Write data
        newChunk.write(firstChunkData);
        // Push chunk to save list
        chunksToWrite.push(newChunk);
      ***REMOVED***

      // Set current chunk with remaining data
      self.currentChunk = new Chunk(self, ***REMOVED***'n': (previousChunkNumber + 1)***REMOVED***, self.writeConcern);
      // If we have left over data write it
      if(leftOverData.length > 0) self.currentChunk.write(leftOverData);

      // Update the position for the gridstore
      self.position = self.position + buffer.length;
      // Total number of chunks to write
      var numberOfChunksToWrite = chunksToWrite.length;

      for(var i = 0; i < chunksToWrite.length; i++) ***REMOVED***
        chunksToWrite[i].save(***REMOVED******REMOVED***, function(err) ***REMOVED***
          if(err) return callback(err);

          numberOfChunksToWrite = numberOfChunksToWrite - 1;

          if(numberOfChunksToWrite <= 0) ***REMOVED***
            // We care closing the file before returning
            if(finalClose) ***REMOVED***
              return self.close(function(err) ***REMOVED***
                callback(err, self);
              ***REMOVED***);
            ***REMOVED***

            // Return normally
            return callback(null, self);
          ***REMOVED***
        ***REMOVED***);
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
      // Update the position for the gridstore
      self.position = self.position + buffer.length;
      // We have less data than the chunk size just write it and callback
      self.currentChunk.write(buffer);
      // We care closing the file before returning
      if(finalClose) ***REMOVED***
        return self.close(function(err) ***REMOVED***
          callback(err, self);
        ***REMOVED***);
      ***REMOVED***
      // Return normally
      return callback(null, self);
    ***REMOVED***
  ***REMOVED***
***REMOVED***;

/**
 * Creates a mongoDB object representation of this object.
 *
 *        <pre><code>
 *        ***REMOVED***
 *          '_id' : , // ***REMOVED***number***REMOVED*** id for this file
 *          'filename' : , // ***REMOVED***string***REMOVED*** name for this file
 *          'contentType' : , // ***REMOVED***string***REMOVED*** mime type for this file
 *          'length' : , // ***REMOVED***number***REMOVED*** size of this file?
 *          'chunksize' : , // ***REMOVED***number***REMOVED*** chunk size used by this file
 *          'uploadDate' : , // ***REMOVED***Date***REMOVED***
 *          'aliases' : , // ***REMOVED***array of string***REMOVED***
 *          'metadata' : , // ***REMOVED***string***REMOVED***
 *        ***REMOVED***
 *        </code></pre>
 *
 * @ignore
 */
var buildMongoObject = function(self, callback) ***REMOVED***
  // Calcuate the length
  var mongoObject = ***REMOVED***
    '_id': self.fileId,
    'filename': self.filename,
    'contentType': self.contentType,
    'length': self.position ? self.position : 0,
    'chunkSize': self.chunkSize,
    'uploadDate': self.uploadDate,
    'aliases': self.aliases,
    'metadata': self.metadata
  ***REMOVED***;

  var md5Command = ***REMOVED***filemd5:self.fileId, root:self.root***REMOVED***;
  self.db.command(md5Command, function(err, results) ***REMOVED***
    if(err) return callback(err);

    mongoObject.md5 = results.md5;
    callback(null, mongoObject);
  ***REMOVED***);
***REMOVED***;

/**
 * Gets the nth chunk of this file.
 * @ignore
 */
var nthChunk = function(self, chunkNumber, options, callback) ***REMOVED***
  if(typeof options == 'function') ***REMOVED***
    callback = options;
    options = ***REMOVED******REMOVED***;
  ***REMOVED***

  options = options || self.writeConcern;
  options.readPreference = self.readPreference;
  // Get the nth chunk
  self.chunkCollection().findOne(***REMOVED***'files_id':self.fileId, 'n':chunkNumber***REMOVED***, options, function(err, chunk) ***REMOVED***
    if(err) return callback(err);

    var finalChunk = chunk == null ? ***REMOVED******REMOVED*** : chunk;
    callback(null, new Chunk(self, finalChunk, self.writeConcern));
  ***REMOVED***);
***REMOVED***;

/**
 * @ignore
 */
var lastChunkNumber = function(self) ***REMOVED***
  return Math.floor((self.length ? self.length - 1 : 0)/self.chunkSize);
***REMOVED***;

/**
 * Deletes all the chunks of this file in the database.
 *
 * @ignore
 */
var deleteChunks = function(self, options, callback) ***REMOVED***
  if(typeof options == 'function') ***REMOVED***
    callback = options;
    options = ***REMOVED******REMOVED***;
  ***REMOVED***

  options = options || self.writeConcern;

  if(self.fileId != null) ***REMOVED***
    self.chunkCollection().remove(***REMOVED***'files_id':self.fileId***REMOVED***, options, function(err) ***REMOVED***
      if(err) return callback(err, false);
      callback(null, true);
    ***REMOVED***);
  ***REMOVED*** else ***REMOVED***
    callback(null, true);
  ***REMOVED***
***REMOVED***;

/**
* The collection to be used for holding the files and chunks collection.
*
* @classconstant DEFAULT_ROOT_COLLECTION
**/
GridStore.DEFAULT_ROOT_COLLECTION = 'fs';

/**
* Default file mime type
*
* @classconstant DEFAULT_CONTENT_TYPE
**/
GridStore.DEFAULT_CONTENT_TYPE = 'binary/octet-stream';

/**
* Seek mode where the given length is absolute.
*
* @classconstant IO_SEEK_SET
**/
GridStore.IO_SEEK_SET = 0;

/**
* Seek mode where the given length is an offset to the current read/write head.
*
* @classconstant IO_SEEK_CUR
**/
GridStore.IO_SEEK_CUR = 1;

/**
* Seek mode where the given length is an offset to the end of the file.
*
* @classconstant IO_SEEK_END
**/
GridStore.IO_SEEK_END = 2;

/**
 * Checks if a file exists in the database.
 *
 * @method
 * @static
 * @param ***REMOVED***Db***REMOVED*** db the database to query.
 * @param ***REMOVED***string***REMOVED*** name The name of the file to look for.
 * @param ***REMOVED***string***REMOVED*** [rootCollection] The root collection that holds the files and chunks collection. Defaults to *****REMOVED***GridStore.DEFAULT_ROOT_COLLECTION***REMOVED*****.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(ReadPreference|string)***REMOVED*** [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param ***REMOVED***object***REMOVED*** [options.promiseLibrary=null] A Promise library class the application wishes to use such as Bluebird, must be ES6 compatible
 * @param ***REMOVED***GridStore~resultCallback***REMOVED*** [callback] result from exists.
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 * @deprecated Use GridFSBucket API instead
 */
GridStore.exist = function(db, fileIdObject, rootCollection, options, callback) ***REMOVED***
  var args = Array.prototype.slice.call(arguments, 2);
  callback = args.pop();
  if(typeof callback != 'function') args.push(callback);
  rootCollection = args.length ? args.shift() : null;
  options = args.length ? args.shift() : ***REMOVED******REMOVED***;
  options = options || ***REMOVED******REMOVED***;

  // Get the promiseLibrary
  var promiseLibrary = options.promiseLibrary;

  // No promise library selected fall back
  if(!promiseLibrary) ***REMOVED***
    promiseLibrary = typeof global.Promise == 'function' ?
      global.Promise : require('es6-promise').Promise;
  ***REMOVED***

  // We provided a callback leg
  if(typeof callback == 'function') return exists(db, fileIdObject, rootCollection, options, callback);
  // Return promise
  return new promiseLibrary(function(resolve, reject) ***REMOVED***
    exists(db, fileIdObject, rootCollection, options, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***)
  ***REMOVED***);
***REMOVED***;

var exists = function(db, fileIdObject, rootCollection, options, callback) ***REMOVED***
  // Establish read preference
  var readPreference = options.readPreference || ReadPreference.PRIMARY;
  // Fetch collection
  var rootCollectionFinal = rootCollection != null ? rootCollection : GridStore.DEFAULT_ROOT_COLLECTION;
  db.collection(rootCollectionFinal + ".files", function(err, collection) ***REMOVED***
    if(err) return callback(err);

    // Build query
    var query = (typeof fileIdObject == 'string' || Object.prototype.toString.call(fileIdObject) == '[object RegExp]' )
      ? ***REMOVED***'filename':fileIdObject***REMOVED***
      : ***REMOVED***'_id':fileIdObject***REMOVED***;    // Attempt to locate file

    // We have a specific query
    if(fileIdObject != null
      && typeof fileIdObject == 'object'
      && Object.prototype.toString.call(fileIdObject) != '[object RegExp]') ***REMOVED***
      query = fileIdObject;
    ***REMOVED***

    // Check if the entry exists
    collection.findOne(query, ***REMOVED***readPreference:readPreference***REMOVED***, function(err, item) ***REMOVED***
      if(err) return callback(err);
      callback(null, item == null ? false : true);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

define.staticMethod('exist', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Gets the list of files stored in the GridFS.
 *
 * @method
 * @static
 * @param ***REMOVED***Db***REMOVED*** db the database to query.
 * @param ***REMOVED***string***REMOVED*** [rootCollection] The root collection that holds the files and chunks collection. Defaults to *****REMOVED***GridStore.DEFAULT_ROOT_COLLECTION***REMOVED*****.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(ReadPreference|string)***REMOVED*** [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param ***REMOVED***object***REMOVED*** [options.promiseLibrary=null] A Promise library class the application wishes to use such as Bluebird, must be ES6 compatible
 * @param ***REMOVED***GridStore~resultCallback***REMOVED*** [callback] result from exists.
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 * @deprecated Use GridFSBucket API instead
 */
GridStore.list = function(db, rootCollection, options, callback) ***REMOVED***
  var args = Array.prototype.slice.call(arguments, 1);
  callback = args.pop();
  if(typeof callback != 'function') args.push(callback);
  rootCollection = args.length ? args.shift() : null;
  options = args.length ? args.shift() : ***REMOVED******REMOVED***;
  options = options || ***REMOVED******REMOVED***;

  // Get the promiseLibrary
  var promiseLibrary = options.promiseLibrary;

  // No promise library selected fall back
  if(!promiseLibrary) ***REMOVED***
    promiseLibrary = typeof global.Promise == 'function' ?
      global.Promise : require('es6-promise').Promise;
  ***REMOVED***

  // We provided a callback leg
  if(typeof callback == 'function') return list(db, rootCollection, options, callback);
  // Return promise
  return new promiseLibrary(function(resolve, reject) ***REMOVED***
    list(db, rootCollection, options, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***)
  ***REMOVED***);
***REMOVED***;

var list = function(db, rootCollection, options, callback) ***REMOVED***
  // Ensure we have correct values
  if(rootCollection != null && typeof rootCollection == 'object') ***REMOVED***
    options = rootCollection;
    rootCollection = null;
  ***REMOVED***

  // Establish read preference
  var readPreference = options.readPreference || ReadPreference.PRIMARY;
  // Check if we are returning by id not filename
  var byId = options['id'] != null ? options['id'] : false;
  // Fetch item
  var rootCollectionFinal = rootCollection != null ? rootCollection : GridStore.DEFAULT_ROOT_COLLECTION;
  var items = [];
  db.collection((rootCollectionFinal + ".files"), function(err, collection) ***REMOVED***
    if(err) return callback(err);

    collection.find(***REMOVED******REMOVED***, ***REMOVED***readPreference:readPreference***REMOVED***, function(err, cursor) ***REMOVED***
      if(err) return callback(err);

      cursor.each(function(err, item) ***REMOVED***
        if(item != null) ***REMOVED***
          items.push(byId ? item._id : item.filename);
        ***REMOVED*** else ***REMOVED***
          callback(err, items);
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

define.staticMethod('list', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Reads the contents of a file.
 *
 * This method has the following signatures
 *
 * (db, name, callback)
 * (db, name, length, callback)
 * (db, name, length, offset, callback)
 * (db, name, length, offset, options, callback)
 *
 * @method
 * @static
 * @param ***REMOVED***Db***REMOVED*** db the database to query.
 * @param ***REMOVED***string***REMOVED*** name The name of the file.
 * @param ***REMOVED***number***REMOVED*** [length] The size of data to read.
 * @param ***REMOVED***number***REMOVED*** [offset] The offset from the head of the file of which to start reading from.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(ReadPreference|string)***REMOVED*** [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param ***REMOVED***object***REMOVED*** [options.promiseLibrary=null] A Promise library class the application wishes to use such as Bluebird, must be ES6 compatible
 * @param ***REMOVED***GridStore~readCallback***REMOVED*** [callback] the command callback.
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 * @deprecated Use GridFSBucket API instead
 */
GridStore.read = function(db, name, length, offset, options, callback) ***REMOVED***
  var args = Array.prototype.slice.call(arguments, 2);
  callback = args.pop();
  if(typeof callback != 'function') args.push(callback);
  length = args.length ? args.shift() : null;
  offset = args.length ? args.shift() : null;
  options = args.length ? args.shift() : null;
  options = options || ***REMOVED******REMOVED***;

  // Get the promiseLibrary
  var promiseLibrary = options ? options.promiseLibrary : null;

  // No promise library selected fall back
  if(!promiseLibrary) ***REMOVED***
    promiseLibrary = typeof global.Promise == 'function' ?
      global.Promise : require('es6-promise').Promise;
  ***REMOVED***

  // We provided a callback leg
  if(typeof callback == 'function') return readStatic(db, name, length, offset, options, callback);
  // Return promise
  return new promiseLibrary(function(resolve, reject) ***REMOVED***
    readStatic(db, name, length, offset, options, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***)
  ***REMOVED***);
***REMOVED***;

var readStatic = function(db, name, length, offset, options, callback) ***REMOVED***
  new GridStore(db, name, "r", options).open(function(err, gridStore) ***REMOVED***
    if(err) return callback(err);
    // Make sure we are not reading out of bounds
    if(offset && offset >= gridStore.length) return callback("offset larger than size of file", null);
    if(length && length > gridStore.length) return callback("length is larger than the size of the file", null);
    if(offset && length && (offset + length) > gridStore.length) return callback("offset and length is larger than the size of the file", null);

    if(offset != null) ***REMOVED***
      gridStore.seek(offset, function(err, gridStore) ***REMOVED***
        if(err) return callback(err);
        gridStore.read(length, callback);
      ***REMOVED***);
    ***REMOVED*** else ***REMOVED***
      gridStore.read(length, callback);
    ***REMOVED***
  ***REMOVED***);
***REMOVED***

define.staticMethod('read', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Read the entire file as a list of strings splitting by the provided separator.
 *
 * @method
 * @static
 * @param ***REMOVED***Db***REMOVED*** db the database to query.
 * @param ***REMOVED***(String|object)***REMOVED*** name the name of the file.
 * @param ***REMOVED***string***REMOVED*** [separator] The character to be recognized as the newline separator.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(ReadPreference|string)***REMOVED*** [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param ***REMOVED***object***REMOVED*** [options.promiseLibrary=null] A Promise library class the application wishes to use such as Bluebird, must be ES6 compatible
 * @param ***REMOVED***GridStore~readlinesCallback***REMOVED*** [callback] the command callback.
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 * @deprecated Use GridFSBucket API instead
 */
GridStore.readlines = function(db, name, separator, options, callback) ***REMOVED***
  var args = Array.prototype.slice.call(arguments, 2);
  callback = args.pop();
  if(typeof callback != 'function') args.push(callback);
  separator = args.length ? args.shift() : null;
  options = args.length ? args.shift() : null;
  options = options || ***REMOVED******REMOVED***;

  // Get the promiseLibrary
  var promiseLibrary = options ? options.promiseLibrary : null;

  // No promise library selected fall back
  if(!promiseLibrary) ***REMOVED***
    promiseLibrary = typeof global.Promise == 'function' ?
      global.Promise : require('es6-promise').Promise;
  ***REMOVED***

  // We provided a callback leg
  if(typeof callback == 'function') return readlinesStatic(db, name, separator, options, callback);
  // Return promise
  return new promiseLibrary(function(resolve, reject) ***REMOVED***
    readlinesStatic(db, name, separator, options, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***)
  ***REMOVED***);
***REMOVED***;

var readlinesStatic = function(db, name, separator, options, callback) ***REMOVED***
  var finalSeperator = separator == null ? "\n" : separator;
  new GridStore(db, name, "r", options).open(function(err, gridStore) ***REMOVED***
    if(err) return callback(err);
    gridStore.readlines(finalSeperator, callback);
  ***REMOVED***);
***REMOVED***

define.staticMethod('readlines', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Deletes the chunks and metadata information of a file from GridFS.
 *
 * @method
 * @static
 * @param ***REMOVED***Db***REMOVED*** db The database to query.
 * @param ***REMOVED***(string|array)***REMOVED*** names The name/names of the files to delete.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***object***REMOVED*** [options.promiseLibrary=null] A Promise library class the application wishes to use such as Bluebird, must be ES6 compatible
 * @param ***REMOVED***GridStore~resultCallback***REMOVED*** [callback] the command callback.
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 * @deprecated Use GridFSBucket API instead
 */
GridStore.unlink = function(db, names, options, callback) ***REMOVED***
  var self = this;
  var args = Array.prototype.slice.call(arguments, 2);
  callback = args.pop();
  if(typeof callback != 'function') args.push(callback);
  options = args.length ? args.shift() : ***REMOVED******REMOVED***;
  options = options || ***REMOVED******REMOVED***;

  // Get the promiseLibrary
  var promiseLibrary = options.promiseLibrary;

  // No promise library selected fall back
  if(!promiseLibrary) ***REMOVED***
    promiseLibrary = typeof global.Promise == 'function' ?
      global.Promise : require('es6-promise').Promise;
  ***REMOVED***

  // We provided a callback leg
  if(typeof callback == 'function') return unlinkStatic(self, db, names, options, callback);

  // Return promise
  return new promiseLibrary(function(resolve, reject) ***REMOVED***
    unlinkStatic(self, db, names, options, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***)
  ***REMOVED***);
***REMOVED***;

var unlinkStatic = function(self, db, names, options, callback) ***REMOVED***
  // Get the write concern
  var writeConcern = _getWriteConcern(db, options);

  // List of names
  if(names.constructor == Array) ***REMOVED***
    var tc = 0;
    for(var i = 0; i < names.length; i++) ***REMOVED***
      ++tc;
      GridStore.unlink(db, names[i], options, function() ***REMOVED***
        if(--tc == 0) ***REMOVED***
          callback(null, self);
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    new GridStore(db, names, "w", options).open(function(err, gridStore) ***REMOVED***
      if(err) return callback(err);
      deleteChunks(gridStore, function(err) ***REMOVED***
        if(err) return callback(err);
        gridStore.collection(function(err, collection) ***REMOVED***
          if(err) return callback(err);
          collection.remove(***REMOVED***'_id':gridStore.fileId***REMOVED***, writeConcern, function(err) ***REMOVED***
            callback(err, self);
          ***REMOVED***);
        ***REMOVED***);
      ***REMOVED***);
    ***REMOVED***);
  ***REMOVED***
***REMOVED***

define.staticMethod('unlink', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 *  @ignore
 */
var _writeNormal = function(self, data, close, callback) ***REMOVED***
  // If we have a buffer write it using the writeBuffer method
  if(Buffer.isBuffer(data)) ***REMOVED***
    return writeBuffer(self, data, close, callback);
  ***REMOVED*** else ***REMOVED***
    return writeBuffer(self, new Buffer(data, 'binary'), close, callback);
  ***REMOVED***
***REMOVED***

/**
 * @ignore
 */
var _setWriteConcernHash = function(options) ***REMOVED***
  var finalOptions = ***REMOVED******REMOVED***;
  if(options.w != null) finalOptions.w = options.w;
  if(options.journal == true) finalOptions.j = options.journal;
  if(options.j == true) finalOptions.j = options.j;
  if(options.fsync == true) finalOptions.fsync = options.fsync;
  if(options.wtimeout != null) finalOptions.wtimeout = options.wtimeout;
  return finalOptions;
***REMOVED***

/**
 * @ignore
 */
var _getWriteConcern = function(self, options) ***REMOVED***
  // Final options
  var finalOptions = ***REMOVED***w:1***REMOVED***;
  options = options || ***REMOVED******REMOVED***;

  // Local options verification
  if(options.w != null || typeof options.j == 'boolean' || typeof options.journal == 'boolean' || typeof options.fsync == 'boolean') ***REMOVED***
    finalOptions = _setWriteConcernHash(options);
  ***REMOVED*** else if(options.safe != null && typeof options.safe == 'object') ***REMOVED***
    finalOptions = _setWriteConcernHash(options.safe);
  ***REMOVED*** else if(typeof options.safe == "boolean") ***REMOVED***
    finalOptions = ***REMOVED***w: (options.safe ? 1 : 0)***REMOVED***;
  ***REMOVED*** else if(self.options.w != null || typeof self.options.j == 'boolean' || typeof self.options.journal == 'boolean' || typeof self.options.fsync == 'boolean') ***REMOVED***
    finalOptions = _setWriteConcernHash(self.options);
  ***REMOVED*** else if(self.safe && (self.safe.w != null || typeof self.safe.j == 'boolean' || typeof self.safe.journal == 'boolean' || typeof self.safe.fsync == 'boolean')) ***REMOVED***
    finalOptions = _setWriteConcernHash(self.safe);
  ***REMOVED*** else if(typeof self.safe == "boolean") ***REMOVED***
    finalOptions = ***REMOVED***w: (self.safe ? 1 : 0)***REMOVED***;
  ***REMOVED***

  // Ensure we don't have an invalid combination of write concerns
  if(finalOptions.w < 1
    && (finalOptions.journal == true || finalOptions.j == true || finalOptions.fsync == true)) throw MongoError.create(***REMOVED***message: "No acknowledgement using w < 1 cannot be combined with journal:true or fsync:true", driver:true***REMOVED***);

  // Return the options
  return finalOptions;
***REMOVED***

/**
 * Create a new GridStoreStream instance (INTERNAL TYPE, do not instantiate directly)
 *
 * @class
 * @extends external:Duplex
 * @return ***REMOVED***GridStoreStream***REMOVED*** a GridStoreStream instance.
 * @deprecated Use GridFSBucket API instead
 */
var GridStoreStream = function(gs) ***REMOVED***
  // Initialize the duplex stream
  Duplex.call(this);

  // Get the gridstore
  this.gs = gs;

  // End called
  this.endCalled = false;

  // If we have a seek
  this.totalBytesToRead = this.gs.length - this.gs.position;
  this.seekPosition = this.gs.position;
***REMOVED***

//
// Inherit duplex
inherits(GridStoreStream, Duplex);

GridStoreStream.prototype._pipe = GridStoreStream.prototype.pipe;

// Set up override
GridStoreStream.prototype.pipe = function(destination) ***REMOVED***
  var self = this;

  // Only open gridstore if not already open
  if(!self.gs.isOpen) ***REMOVED***
    self.gs.open(function(err) ***REMOVED***
      if(err) return self.emit('error', err);
      self.totalBytesToRead = self.gs.length - self.gs.position;
      self._pipe.apply(self, [destination]);
    ***REMOVED***);
  ***REMOVED*** else ***REMOVED***
    self.totalBytesToRead = self.gs.length - self.gs.position;
    self._pipe.apply(self, [destination]);
  ***REMOVED***

  return destination;
***REMOVED***

// Called by stream
GridStoreStream.prototype._read = function() ***REMOVED***
  var self = this;

  var read = function() ***REMOVED***
    // Read data
    self.gs.read(length, function(err, buffer) ***REMOVED***
      if(err && !self.endCalled) return self.emit('error', err);

      // Stream is closed
      if(self.endCalled || buffer == null) return self.push(null);
      // Remove bytes read
      if(buffer.length <= self.totalBytesToRead) ***REMOVED***
        self.totalBytesToRead = self.totalBytesToRead - buffer.length;
        self.push(buffer);
      ***REMOVED*** else if(buffer.length > self.totalBytesToRead) ***REMOVED***
        self.totalBytesToRead = self.totalBytesToRead - buffer._index;
        self.push(buffer.slice(0, buffer._index));
      ***REMOVED***

      // Finished reading
      if(self.totalBytesToRead <= 0) ***REMOVED***
        self.endCalled = true;
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***

  // Set read length
  var length = self.gs.length < self.gs.chunkSize ? self.gs.length - self.seekPosition : self.gs.chunkSize;
  if(!self.gs.isOpen) ***REMOVED***
    self.gs.open(function(err) ***REMOVED***
      self.totalBytesToRead = self.gs.length - self.gs.position;
      if(err) return self.emit('error', err);
      read();
    ***REMOVED***);
  ***REMOVED*** else ***REMOVED***
    read();
  ***REMOVED***
***REMOVED***

GridStoreStream.prototype.destroy = function() ***REMOVED***
  this.pause();
  this.endCalled = true;
  this.gs.close();
  this.emit('end');
***REMOVED***

GridStoreStream.prototype.write = function(chunk) ***REMOVED***
  var self = this;
  if(self.endCalled) return self.emit('error', MongoError.create(***REMOVED***message: 'attempting to write to stream after end called', driver:true***REMOVED***))
  // Do we have to open the gridstore
  if(!self.gs.isOpen) ***REMOVED***
    self.gs.open(function() ***REMOVED***
      self.gs.isOpen = true;
      self.gs.write(chunk, function() ***REMOVED***
        process.nextTick(function() ***REMOVED***
          self.emit('drain');
        ***REMOVED***);
      ***REMOVED***);
    ***REMOVED***);
    return false;
  ***REMOVED*** else ***REMOVED***
    self.gs.write(chunk, function() ***REMOVED***
      self.emit('drain');
    ***REMOVED***);
    return true;
  ***REMOVED***
***REMOVED***

GridStoreStream.prototype.end = function(chunk, encoding, callback) ***REMOVED***
  var self = this;
  var args = Array.prototype.slice.call(arguments, 0);
  callback = args.pop();
  if(typeof callback != 'function') args.push(callback);
  chunk = args.length ? args.shift() : null;
  encoding = args.length ? args.shift() : null;
  self.endCalled = true;

  if(chunk) ***REMOVED***
    self.gs.write(chunk, function() ***REMOVED***
      self.gs.close(function() ***REMOVED***
        if(typeof callback == 'function') callback();
        self.emit('end')
      ***REMOVED***);
    ***REMOVED***);
  ***REMOVED***

  self.gs.close(function() ***REMOVED***
    if(typeof callback == 'function') callback();
    self.emit('end')
  ***REMOVED***);
***REMOVED***

/**
 * The read() method pulls some data out of the internal buffer and returns it. If there is no data available, then it will return null.
 * @function external:Duplex#read
 * @param ***REMOVED***number***REMOVED*** size Optional argument to specify how much data to read.
 * @return ***REMOVED***(String | Buffer | null)***REMOVED***
 */

/**
 * Call this function to cause the stream to return strings of the specified encoding instead of Buffer objects.
 * @function external:Duplex#setEncoding
 * @param ***REMOVED***string***REMOVED*** encoding The encoding to use.
 * @return ***REMOVED***null***REMOVED***
 */

/**
 * This method will cause the readable stream to resume emitting data events.
 * @function external:Duplex#resume
 * @return ***REMOVED***null***REMOVED***
 */

/**
 * This method will cause a stream in flowing-mode to stop emitting data events. Any data that becomes available will remain in the internal buffer.
 * @function external:Duplex#pause
 * @return ***REMOVED***null***REMOVED***
 */

/**
 * This method pulls all the data out of a readable stream, and writes it to the supplied destination, automatically managing the flow so that the destination is not overwhelmed by a fast readable stream.
 * @function external:Duplex#pipe
 * @param ***REMOVED***Writable***REMOVED*** destination The destination for writing data
 * @param ***REMOVED***object***REMOVED*** [options] Pipe options
 * @return ***REMOVED***null***REMOVED***
 */

/**
 * This method will remove the hooks set up for a previous pipe() call.
 * @function external:Duplex#unpipe
 * @param ***REMOVED***Writable***REMOVED*** [destination] The destination for writing data
 * @return ***REMOVED***null***REMOVED***
 */

/**
 * This is useful in certain cases where a stream is being consumed by a parser, which needs to "un-consume" some data that it has optimistically pulled out of the source, so that the stream can be passed on to some other party.
 * @function external:Duplex#unshift
 * @param ***REMOVED***(Buffer|string)***REMOVED*** chunk Chunk of data to unshift onto the read queue.
 * @return ***REMOVED***null***REMOVED***
 */

/**
 * Versions of Node prior to v0.10 had streams that did not implement the entire Streams API as it is today. (See "Compatibility" below for more information.)
 * @function external:Duplex#wrap
 * @param ***REMOVED***Stream***REMOVED*** stream An "old style" readable stream.
 * @return ***REMOVED***null***REMOVED***
 */

/**
 * This method writes some data to the underlying system, and calls the supplied callback once the data has been fully handled.
 * @function external:Duplex#write
 * @param ***REMOVED***(string|Buffer)***REMOVED*** chunk The data to write
 * @param ***REMOVED***string***REMOVED*** encoding The encoding, if chunk is a String
 * @param ***REMOVED***function***REMOVED*** callback Callback for when this chunk of data is flushed
 * @return ***REMOVED***boolean***REMOVED***
 */

/**
 * Call this method when no more data will be written to the stream. If supplied, the callback is attached as a listener on the finish event.
 * @function external:Duplex#end
 * @param ***REMOVED***(string|Buffer)***REMOVED*** chunk The data to write
 * @param ***REMOVED***string***REMOVED*** encoding The encoding, if chunk is a String
 * @param ***REMOVED***function***REMOVED*** callback Callback for when this chunk of data is flushed
 * @return ***REMOVED***null***REMOVED***
 */

/**
 * GridStoreStream stream data event, fired for each document in the cursor.
 *
 * @event GridStoreStream#data
 * @type ***REMOVED***object***REMOVED***
 */

/**
 * GridStoreStream stream end event
 *
 * @event GridStoreStream#end
 * @type ***REMOVED***null***REMOVED***
 */

/**
 * GridStoreStream stream close event
 *
 * @event GridStoreStream#close
 * @type ***REMOVED***null***REMOVED***
 */

/**
 * GridStoreStream stream readable event
 *
 * @event GridStoreStream#readable
 * @type ***REMOVED***null***REMOVED***
 */

/**
 * GridStoreStream stream drain event
 *
 * @event GridStoreStream#drain
 * @type ***REMOVED***null***REMOVED***
 */

/**
 * GridStoreStream stream finish event
 *
 * @event GridStoreStream#finish
 * @type ***REMOVED***null***REMOVED***
 */

/**
 * GridStoreStream stream pipe event
 *
 * @event GridStoreStream#pipe
 * @type ***REMOVED***null***REMOVED***
 */

/**
 * GridStoreStream stream unpipe event
 *
 * @event GridStoreStream#unpipe
 * @type ***REMOVED***null***REMOVED***
 */

/**
 * GridStoreStream stream error event
 *
 * @event GridStoreStream#error
 * @type ***REMOVED***null***REMOVED***
 */

/**
 * @ignore
 */
module.exports = GridStore;
