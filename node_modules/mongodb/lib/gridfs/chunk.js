"use strict";

var Binary = require('mongodb-core').BSON.Binary,
  ObjectID = require('mongodb-core').BSON.ObjectID;

/**
 * Class for representing a single chunk in GridFS.
 *
 * @class
 *
 * @param file ***REMOVED***GridStore***REMOVED*** The ***REMOVED***@link GridStore***REMOVED*** object holding this chunk.
 * @param mongoObject ***REMOVED***object***REMOVED*** The mongo object representation of this chunk.
 *
 * @throws Error when the type of data field for ***REMOVED***@link mongoObject***REMOVED*** is not
 *     supported. Currently supported types for data field are instances of
 *     ***REMOVED***@link String***REMOVED***, ***REMOVED***@link Array***REMOVED***, ***REMOVED***@link Binary***REMOVED*** and ***REMOVED***@link Binary***REMOVED***
 *     from the bson module
 *
 * @see Chunk#buildMongoObject
 */
var Chunk = function(file, mongoObject, writeConcern) ***REMOVED***
  if(!(this instanceof Chunk)) return new Chunk(file, mongoObject);

  this.file = file;
  var mongoObjectFinal = mongoObject == null ? ***REMOVED******REMOVED*** : mongoObject;
  this.writeConcern = writeConcern || ***REMOVED***w:1***REMOVED***;
  this.objectId = mongoObjectFinal._id == null ? new ObjectID() : mongoObjectFinal._id;
  this.chunkNumber = mongoObjectFinal.n == null ? 0 : mongoObjectFinal.n;
  this.data = new Binary();

  if(typeof mongoObjectFinal.data == "string") ***REMOVED***
    var buffer = new Buffer(mongoObjectFinal.data.length);
    buffer.write(mongoObjectFinal.data, 0, mongoObjectFinal.data.length, 'binary');
    this.data = new Binary(buffer);
  ***REMOVED*** else if(Array.isArray(mongoObjectFinal.data)) ***REMOVED***
    buffer = new Buffer(mongoObjectFinal.data.length);
    var data = mongoObjectFinal.data.join('');
    buffer.write(data, 0, data.length, 'binary');
    this.data = new Binary(buffer);
  ***REMOVED*** else if(mongoObjectFinal.data && mongoObjectFinal.data._bsontype === 'Binary') ***REMOVED***
    this.data = mongoObjectFinal.data;
  ***REMOVED*** else if(!Buffer.isBuffer(mongoObjectFinal.data) && !(mongoObjectFinal.data == null))***REMOVED***
    throw Error("Illegal chunk format");
  ***REMOVED***

  // Update position
  this.internalPosition = 0;
***REMOVED***;

/**
 * Writes a data to this object and advance the read/write head.
 *
 * @param data ***REMOVED***string***REMOVED*** the data to write
 * @param callback ***REMOVED***function(*, GridStore)***REMOVED*** This will be called after executing
 *     this method. The first parameter will contain null and the second one
 *     will contain a reference to this object.
 */
Chunk.prototype.write = function(data, callback) ***REMOVED***
  this.data.write(data, this.internalPosition, data.length, 'binary');
  this.internalPosition = this.data.length();
  if(callback != null) return callback(null, this);
  return this;
***REMOVED***;

/**
 * Reads data and advances the read/write head.
 *
 * @param length ***REMOVED***number***REMOVED*** The length of data to read.
 *
 * @return ***REMOVED***string***REMOVED*** The data read if the given length will not exceed the end of
 *     the chunk. Returns an empty String otherwise.
 */
Chunk.prototype.read = function(length) ***REMOVED***
  // Default to full read if no index defined
  length = length == null || length == 0 ? this.length() : length;

  if(this.length() - this.internalPosition + 1 >= length) ***REMOVED***
    var data = this.data.read(this.internalPosition, length);
    this.internalPosition = this.internalPosition + length;
    return data;
  ***REMOVED*** else ***REMOVED***
    return '';
  ***REMOVED***
***REMOVED***;

Chunk.prototype.readSlice = function(length) ***REMOVED***
  if ((this.length() - this.internalPosition) >= length) ***REMOVED***
    var data = null;
    if (this.data.buffer != null) ***REMOVED*** //Pure BSON
      data = this.data.buffer.slice(this.internalPosition, this.internalPosition + length);
    ***REMOVED*** else ***REMOVED*** //Native BSON
      data = new Buffer(length);
      length = this.data.readInto(data, this.internalPosition);
    ***REMOVED***
    this.internalPosition = this.internalPosition + length;
    return data;
  ***REMOVED*** else ***REMOVED***
    return null;
  ***REMOVED***
***REMOVED***;

/**
 * Checks if the read/write head is at the end.
 *
 * @return ***REMOVED***boolean***REMOVED*** Whether the read/write head has reached the end of this
 *     chunk.
 */
Chunk.prototype.eof = function() ***REMOVED***
  return this.internalPosition == this.length() ? true : false;
***REMOVED***;

/**
 * Reads one character from the data of this chunk and advances the read/write
 * head.
 *
 * @return ***REMOVED***string***REMOVED*** a single character data read if the the read/write head is
 *     not at the end of the chunk. Returns an empty String otherwise.
 */
Chunk.prototype.getc = function() ***REMOVED***
  return this.read(1);
***REMOVED***;

/**
 * Clears the contents of the data in this chunk and resets the read/write head
 * to the initial position.
 */
Chunk.prototype.rewind = function() ***REMOVED***
  this.internalPosition = 0;
  this.data = new Binary();
***REMOVED***;

/**
 * Saves this chunk to the database. Also overwrites existing entries having the
 * same id as this chunk.
 *
 * @param callback ***REMOVED***function(*, GridStore)***REMOVED*** This will be called after executing
 *     this method. The first parameter will contain null and the second one
 *     will contain a reference to this object.
 */
Chunk.prototype.save = function(options, callback) ***REMOVED***
  var self = this;
  if(typeof options == 'function') ***REMOVED***
    callback = options;
    options = ***REMOVED******REMOVED***;
  ***REMOVED***

  self.file.chunkCollection(function(err, collection) ***REMOVED***
    if(err) return callback(err);

    // Merge the options
    var writeOptions = ***REMOVED*** upsert: true ***REMOVED***;
    for(var name in options) writeOptions[name] = options[name];
    for(name in self.writeConcern) writeOptions[name] = self.writeConcern[name];

    if(self.data.length() > 0) ***REMOVED***
      self.buildMongoObject(function(mongoObject) ***REMOVED***
        var options = ***REMOVED***forceServerObjectId:true***REMOVED***;
        for(var name in self.writeConcern) ***REMOVED***
          options[name] = self.writeConcern[name];
        ***REMOVED***

        collection.replaceOne(***REMOVED***'_id':self.objectId***REMOVED***, mongoObject, writeOptions, function(err) ***REMOVED***
          callback(err, self);
        ***REMOVED***);
      ***REMOVED***);
    ***REMOVED*** else ***REMOVED***
      callback(null, self);
    ***REMOVED***
    // ***REMOVED***);
  ***REMOVED***);
***REMOVED***;

/**
 * Creates a mongoDB object representation of this chunk.
 *
 * @param callback ***REMOVED***function(Object)***REMOVED*** This will be called after executing this
 *     method. The object will be passed to the first parameter and will have
 *     the structure:
 *
 *        <pre><code>
 *        ***REMOVED***
 *          '_id' : , // ***REMOVED***number***REMOVED*** id for this chunk
 *          'files_id' : , // ***REMOVED***number***REMOVED*** foreign key to the file collection
 *          'n' : , // ***REMOVED***number***REMOVED*** chunk number
 *          'data' : , // ***REMOVED***bson#Binary***REMOVED*** the chunk data itself
 *        ***REMOVED***
 *        </code></pre>
 *
 * @see <a href="http://www.mongodb.org/display/DOCS/GridFS+Specification#GridFSSpecification-***REMOVED******REMOVED***chunks***REMOVED******REMOVED***">MongoDB GridFS Chunk Object Structure</a>
 */
Chunk.prototype.buildMongoObject = function(callback) ***REMOVED***
  var mongoObject = ***REMOVED***
    'files_id': this.file.fileId,
    'n': this.chunkNumber,
    'data': this.data***REMOVED***;
  // If we are saving using a specific ObjectId
  if(this.objectId != null) mongoObject._id = this.objectId;

  callback(mongoObject);
***REMOVED***;

/**
 * @return ***REMOVED***number***REMOVED*** the length of the data
 */
Chunk.prototype.length = function() ***REMOVED***
  return this.data.length();
***REMOVED***;

/**
 * The position of the read/write head
 * @name position
 * @lends Chunk#
 * @field
 */
Object.defineProperty(Chunk.prototype, "position", ***REMOVED*** enumerable: true
  , get: function () ***REMOVED***
      return this.internalPosition;
    ***REMOVED***
  , set: function(value) ***REMOVED***
      this.internalPosition = value;
    ***REMOVED***
***REMOVED***);

/**
 * The default chunk size
 * @constant
 */
Chunk.DEFAULT_CHUNK_SIZE = 1024 * 255;

module.exports = Chunk;
