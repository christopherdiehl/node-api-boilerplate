/*!
 * Module dependencies.
 */

var EmbeddedDocument = require('./embedded');
var Document = require('../document');
var ObjectId = require('./objectid');
var utils = require('../utils');
var isMongooseObject = utils.isMongooseObject;

/**
 * Mongoose Array constructor.
 *
 * ####NOTE:
 *
 * _Values always have to be passed to the constructor to initialize, otherwise `MongooseArray#push` will mark the array as modified._
 *
 * @param ***REMOVED***Array***REMOVED*** values
 * @param ***REMOVED***String***REMOVED*** path
 * @param ***REMOVED***Document***REMOVED*** doc parent document
 * @api private
 * @inherits Array
 * @see http://bit.ly/f6CnZU
 */

function MongooseArray(values, path, doc) ***REMOVED***
  var arr = [].concat(values);

  var keysMA = Object.keys(MongooseArray.mixin);
  var numKeys = keysMA.length;
  for (var i = 0; i < numKeys; ++i) ***REMOVED***
    arr[keysMA[i]] = MongooseArray.mixin[keysMA[i]];
  ***REMOVED***

  arr._path = path;
  arr.isMongooseArray = true;
  arr.validators = [];
  arr._atomics = ***REMOVED******REMOVED***;
  arr._schema = void 0;

  // Because doc comes from the context of another function, doc === global
  // can happen if there was a null somewhere up the chain (see #3020)
  // RB Jun 17, 2015 updated to check for presence of expected paths instead
  // to make more proof against unusual node environments
  if (doc && doc instanceof Document) ***REMOVED***
    arr._parent = doc;
    arr._schema = doc.schema.path(path);
  ***REMOVED***

  return arr;
***REMOVED***

MongooseArray.mixin = ***REMOVED***
  /*!
   * ignore
   */
  toBSON: function() ***REMOVED***
    return this.toObject(***REMOVED*** transform: false, virtuals: false ***REMOVED***);
  ***REMOVED***,

  /**
   * Stores a queue of atomic operations to perform
   *
   * @property _atomics
   * @api private
   */

  _atomics: undefined,

  /**
   * Parent owner document
   *
   * @property _parent
   * @api private
   * @receiver MongooseArray
   */

  _parent: undefined,

  /**
   * Casts a member based on this arrays schema.
   *
   * @param ***REMOVED***any***REMOVED*** value
   * @return value the casted value
   * @method _cast
   * @api private
   * @receiver MongooseArray
   */

  _cast: function(value) ***REMOVED***
    var populated = false;
    var Model;

    if (this._parent) ***REMOVED***
      populated = this._parent.populated(this._path, true);
    ***REMOVED***

    if (populated && value !== null && value !== undefined) ***REMOVED***
      // cast to the populated Models schema
      Model = populated.options.model;

      // only objects are permitted so we can safely assume that
      // non-objects are to be interpreted as _id
      if (Buffer.isBuffer(value) ||
          value instanceof ObjectId || !utils.isObject(value)) ***REMOVED***
        value = ***REMOVED***_id: value***REMOVED***;
      ***REMOVED***

      // gh-2399
      // we should cast model only when it's not a discriminator
      var isDisc = value.schema && value.schema.discriminatorMapping &&
          value.schema.discriminatorMapping.key !== undefined;
      if (!isDisc) ***REMOVED***
        value = new Model(value);
      ***REMOVED***
      return this._schema.caster.cast(value, this._parent, true);
    ***REMOVED***

    return this._schema.caster.cast(value, this._parent, false);
  ***REMOVED***,

  /**
   * Marks this array as modified.
   *
   * If it bubbles up from an embedded document change, then it takes the following arguments (otherwise, takes 0 arguments)
   *
   * @param ***REMOVED***EmbeddedDocument***REMOVED*** embeddedDoc the embedded doc that invoked this method on the Array
   * @param ***REMOVED***String***REMOVED*** embeddedPath the path which changed in the embeddedDoc
   * @method _markModified
   * @api private
   * @receiver MongooseArray
   */

  _markModified: function(elem, embeddedPath) ***REMOVED***
    var parent = this._parent,
        dirtyPath;

    if (parent) ***REMOVED***
      dirtyPath = this._path;

      if (arguments.length) ***REMOVED***
        if (embeddedPath != null) ***REMOVED***
          // an embedded doc bubbled up the change
          dirtyPath = dirtyPath + '.' + this.indexOf(elem) + '.' + embeddedPath;
        ***REMOVED*** else ***REMOVED***
          // directly set an index
          dirtyPath = dirtyPath + '.' + elem;
        ***REMOVED***
      ***REMOVED***

      parent.markModified(dirtyPath);
    ***REMOVED***

    return this;
  ***REMOVED***,

  /**
   * Register an atomic operation with the parent.
   *
   * @param ***REMOVED***Array***REMOVED*** op operation
   * @param ***REMOVED***any***REMOVED*** val
   * @method _registerAtomic
   * @api private
   * @receiver MongooseArray
   */

  _registerAtomic: function(op, val) ***REMOVED***
    if (op === '$set') ***REMOVED***
      // $set takes precedence over all other ops.
      // mark entire array modified.
      this._atomics = ***REMOVED***$set: val***REMOVED***;
      return this;
    ***REMOVED***

    var atomics = this._atomics;

    // reset pop/shift after save
    if (op === '$pop' && !('$pop' in atomics)) ***REMOVED***
      var _this = this;
      this._parent.once('save', function() ***REMOVED***
        _this._popped = _this._shifted = null;
      ***REMOVED***);
    ***REMOVED***

    // check for impossible $atomic combos (Mongo denies more than one
    // $atomic op on a single path
    if (this._atomics.$set ||
        Object.keys(atomics).length && !(op in atomics)) ***REMOVED***
      // a different op was previously registered.
      // save the entire thing.
      this._atomics = ***REMOVED***$set: this***REMOVED***;
      return this;
    ***REMOVED***

    var selector;

    if (op === '$pullAll' || op === '$pushAll' || op === '$addToSet') ***REMOVED***
      atomics[op] || (atomics[op] = []);
      atomics[op] = atomics[op].concat(val);
    ***REMOVED*** else if (op === '$pullDocs') ***REMOVED***
      var pullOp = atomics['$pull'] || (atomics['$pull'] = ***REMOVED******REMOVED***);
      if (val[0] instanceof EmbeddedDocument) ***REMOVED***
        selector = pullOp['$or'] || (pullOp['$or'] = []);
        Array.prototype.push.apply(selector, val.map(function(v) ***REMOVED***
          return v.toObject(***REMOVED***transform: false, virtuals: false***REMOVED***);
        ***REMOVED***));
      ***REMOVED*** else ***REMOVED***
        selector = pullOp['_id'] || (pullOp['_id'] = ***REMOVED***$in: []***REMOVED***);
        selector['$in'] = selector['$in'].concat(val);
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
      atomics[op] = val;
    ***REMOVED***

    return this;
  ***REMOVED***,

  /**
   * Depopulates stored atomic operation values as necessary for direct insertion to MongoDB.
   *
   * If no atomics exist, we return all array values after conversion.
   *
   * @return ***REMOVED***Array***REMOVED***
   * @method $__getAtomics
   * @memberOf MongooseArray
   * @api private
   */

  $__getAtomics: function() ***REMOVED***
    var ret = [];
    var keys = Object.keys(this._atomics);
    var i = keys.length;

    if (i === 0) ***REMOVED***
      ret[0] = ['$set', this.toObject(***REMOVED***depopulate: 1, transform: false, _isNested: true, virtuals: false***REMOVED***)];
      return ret;
    ***REMOVED***

    while (i--) ***REMOVED***
      var op = keys[i];
      var val = this._atomics[op];

      // the atomic values which are arrays are not MongooseArrays. we
      // need to convert their elements as if they were MongooseArrays
      // to handle populated arrays versus DocumentArrays properly.
      if (isMongooseObject(val)) ***REMOVED***
        val = val.toObject(***REMOVED***depopulate: 1, transform: false, _isNested: true, virtuals: false***REMOVED***);
      ***REMOVED*** else if (Array.isArray(val)) ***REMOVED***
        val = this.toObject.call(val, ***REMOVED***depopulate: 1, transform: false, _isNested: true***REMOVED***);
      ***REMOVED*** else if (val.valueOf) ***REMOVED***
        val = val.valueOf();
      ***REMOVED***

      if (op === '$addToSet') ***REMOVED***
        val = ***REMOVED***$each: val***REMOVED***;
      ***REMOVED***

      ret.push([op, val]);
    ***REMOVED***

    return ret;
  ***REMOVED***,

  /**
   * Returns the number of pending atomic operations to send to the db for this array.
   *
   * @api private
   * @return ***REMOVED***Number***REMOVED***
   * @method hasAtomics
   * @receiver MongooseArray
   */

  hasAtomics: function hasAtomics() ***REMOVED***
    if (!(this._atomics && this._atomics.constructor.name === 'Object')) ***REMOVED***
      return 0;
    ***REMOVED***

    return Object.keys(this._atomics).length;
  ***REMOVED***,

  /**
   * Internal helper for .map()
   *
   * @api private
   * @return ***REMOVED***Number***REMOVED***
   * @method _mapCast
   * @receiver MongooseArray
   */
  _mapCast: function(val, index) ***REMOVED***
    return this._cast(val, this.length + index);
  ***REMOVED***,

  /**
   * Wraps [`Array#push`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/push) with proper change tracking.
   *
   * @param ***REMOVED***Object***REMOVED*** [args...]
   * @api public
   * @method push
   * @receiver MongooseArray
   */

  push: function() ***REMOVED***
    var values = [].map.call(arguments, this._mapCast, this);
    values = this._schema.applySetters(values, this._parent, undefined,
        undefined, ***REMOVED***skipDocumentArrayCast: true***REMOVED***);
    var ret = [].push.apply(this, values);

    // $pushAll might be fibbed (could be $push). But it makes it easier to
    // handle what could have been $push, $pushAll combos
    this._registerAtomic('$pushAll', values);
    this._markModified();
    return ret;
  ***REMOVED***,

  /**
   * Pushes items to the array non-atomically.
   *
   * ####NOTE:
   *
   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._
   *
   * @param ***REMOVED***any***REMOVED*** [args...]
   * @api public
   * @method nonAtomicPush
   * @receiver MongooseArray
   */

  nonAtomicPush: function() ***REMOVED***
    var values = [].map.call(arguments, this._mapCast, this);
    var ret = [].push.apply(this, values);
    this._registerAtomic('$set', this);
    this._markModified();
    return ret;
  ***REMOVED***,

  /**
   * Pops the array atomically at most one time per document `save()`.
   *
   * #### NOTE:
   *
   * _Calling this mulitple times on an array before saving sends the same command as calling it once._
   * _This update is implemented using the MongoDB [$pop](http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pop) method which enforces this restriction._
   *
   *      doc.array = [1,2,3];
   *
   *      var popped = doc.array.$pop();
   *      console.log(popped); // 3
   *      console.log(doc.array); // [1,2]
   *
   *      // no affect
   *      popped = doc.array.$pop();
   *      console.log(doc.array); // [1,2]
   *
   *      doc.save(function (err) ***REMOVED***
   *        if (err) return handleError(err);
   *
   *        // we saved, now $pop works again
   *        popped = doc.array.$pop();
   *        console.log(popped); // 2
   *        console.log(doc.array); // [1]
   *      ***REMOVED***)
   *
   * @api public
   * @method $pop
   * @memberOf MongooseArray
   * @see mongodb http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pop
   * @method $pop
   * @receiver MongooseArray
   */

  $pop: function() ***REMOVED***
    this._registerAtomic('$pop', 1);
    this._markModified();

    // only allow popping once
    if (this._popped) ***REMOVED***
      return;
    ***REMOVED***
    this._popped = true;

    return [].pop.call(this);
  ***REMOVED***,

  /**
   * Wraps [`Array#pop`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/pop) with proper change tracking.
   *
   * ####Note:
   *
   * _marks the entire array as modified which will pass the entire thing to $set potentially overwritting any changes that happen between when you retrieved the object and when you save it._
   *
   * @see MongooseArray#$pop #types_array_MongooseArray-%24pop
   * @api public
   * @method pop
   * @receiver MongooseArray
   */

  pop: function() ***REMOVED***
    var ret = [].pop.call(this);
    this._registerAtomic('$set', this);
    this._markModified();
    return ret;
  ***REMOVED***,

  /**
   * Atomically shifts the array at most one time per document `save()`.
   *
   * ####NOTE:
   *
   * _Calling this mulitple times on an array before saving sends the same command as calling it once._
   * _This update is implemented using the MongoDB [$pop](http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pop) method which enforces this restriction._
   *
   *      doc.array = [1,2,3];
   *
   *      var shifted = doc.array.$shift();
   *      console.log(shifted); // 1
   *      console.log(doc.array); // [2,3]
   *
   *      // no affect
   *      shifted = doc.array.$shift();
   *      console.log(doc.array); // [2,3]
   *
   *      doc.save(function (err) ***REMOVED***
   *        if (err) return handleError(err);
   *
   *        // we saved, now $shift works again
   *        shifted = doc.array.$shift();
   *        console.log(shifted ); // 2
   *        console.log(doc.array); // [3]
   *      ***REMOVED***)
   *
   * @api public
   * @memberOf MongooseArray
   * @method $shift
   * @see mongodb http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pop
   */

  $shift: function $shift() ***REMOVED***
    this._registerAtomic('$pop', -1);
    this._markModified();

    // only allow shifting once
    if (this._shifted) ***REMOVED***
      return;
    ***REMOVED***
    this._shifted = true;

    return [].shift.call(this);
  ***REMOVED***,

  /**
   * Wraps [`Array#shift`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/unshift) with proper change tracking.
   *
   * ####Example:
   *
   *     doc.array = [2,3];
   *     var res = doc.array.shift();
   *     console.log(res) // 2
   *     console.log(doc.array) // [3]
   *
   * ####Note:
   *
   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._
   *
   * @api public
   * @method shift
   * @receiver MongooseArray
   */

  shift: function() ***REMOVED***
    var ret = [].shift.call(this);
    this._registerAtomic('$set', this);
    this._markModified();
    return ret;
  ***REMOVED***,

  /**
   * Pulls items from the array atomically. Equality is determined by casting
   * the provided value to an embedded document and comparing using
   * [the `Document.equals()` function.](./api.html#document_Document-equals)
   *
   * ####Examples:
   *
   *     doc.array.pull(ObjectId)
   *     doc.array.pull(***REMOVED*** _id: 'someId' ***REMOVED***)
   *     doc.array.pull(36)
   *     doc.array.pull('tag 1', 'tag 2')
   *
   * To remove a document from a subdocument array we may pass an object with a matching `_id`.
   *
   *     doc.subdocs.push(***REMOVED*** _id: 4815162342 ***REMOVED***)
   *     doc.subdocs.pull(***REMOVED*** _id: 4815162342 ***REMOVED***) // removed
   *
   * Or we may passing the _id directly and let mongoose take care of it.
   *
   *     doc.subdocs.push(***REMOVED*** _id: 4815162342 ***REMOVED***)
   *     doc.subdocs.pull(4815162342); // works
   *
   * The first pull call will result in a atomic operation on the database, if pull is called repeatedly without saving the document, a $set operation is used on the complete array instead, overwriting possible changes that happened on the database in the meantime.
   *
   * @param ***REMOVED***any***REMOVED*** [args...]
   * @see mongodb http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pull
   * @api public
   * @method pull
   * @receiver MongooseArray
   */

  pull: function() ***REMOVED***
    var values = [].map.call(arguments, this._cast, this),
        cur = this._parent.get(this._path),
        i = cur.length,
        mem;

    while (i--) ***REMOVED***
      mem = cur[i];
      if (mem instanceof Document) ***REMOVED***
        var some = values.some(function(v) ***REMOVED***
          return mem.equals(v);
        ***REMOVED***);
        if (some) ***REMOVED***
          [].splice.call(cur, i, 1);
        ***REMOVED***
      ***REMOVED*** else if (~cur.indexOf.call(values, mem)) ***REMOVED***
        [].splice.call(cur, i, 1);
      ***REMOVED***
    ***REMOVED***

    if (values[0] instanceof EmbeddedDocument) ***REMOVED***
      this._registerAtomic('$pullDocs', values.map(function(v) ***REMOVED***
        return v._id || v;
      ***REMOVED***));
    ***REMOVED*** else ***REMOVED***
      this._registerAtomic('$pullAll', values);
    ***REMOVED***

    this._markModified();
    return this;
  ***REMOVED***,

  /**
   * Wraps [`Array#splice`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/splice) with proper change tracking and casting.
   *
   * ####Note:
   *
   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._
   *
   * @api public
   * @method splice
   * @receiver MongooseArray
   */

  splice: function splice() ***REMOVED***
    var ret, vals, i;

    if (arguments.length) ***REMOVED***
      vals = [];
      for (i = 0; i < arguments.length; ++i) ***REMOVED***
        vals[i] = i < 2
            ? arguments[i]
            : this._cast(arguments[i], arguments[0] + (i - 2));
      ***REMOVED***
      ret = [].splice.apply(this, vals);
      this._registerAtomic('$set', this);
      this._markModified();
    ***REMOVED***

    return ret;
  ***REMOVED***,

  /**
   * Wraps [`Array#unshift`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/unshift) with proper change tracking.
   *
   * ####Note:
   *
   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._
   *
   * @api public
   * @method unshift
   * @receiver MongooseArray
   */

  unshift: function() ***REMOVED***
    var values = [].map.call(arguments, this._cast, this);
    values = this._schema.applySetters(values, this._parent);
    [].unshift.apply(this, values);
    this._registerAtomic('$set', this);
    this._markModified();
    return this.length;
  ***REMOVED***,

  /**
   * Wraps [`Array#sort`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/sort) with proper change tracking.
   *
   * ####NOTE:
   *
   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._
   *
   * @api public
   * @method sort
   * @receiver MongooseArray
   */

  sort: function() ***REMOVED***
    var ret = [].sort.apply(this, arguments);
    this._registerAtomic('$set', this);
    this._markModified();
    return ret;
  ***REMOVED***,

  /**
   * Adds values to the array if not already present.
   *
   * ####Example:
   *
   *     console.log(doc.array) // [2,3,4]
   *     var added = doc.array.addToSet(4,5);
   *     console.log(doc.array) // [2,3,4,5]
   *     console.log(added)     // [5]
   *
   * @param ***REMOVED***any***REMOVED*** [args...]
   * @return ***REMOVED***Array***REMOVED*** the values that were added
   * @receiver MongooseArray
   * @api public
   * @method addToSet
   */

  addToSet: function addToSet() ***REMOVED***
    var values = [].map.call(arguments, this._mapCast, this);
    values = this._schema.applySetters(values, this._parent);
    var added = [];
    var type = '';
    if (values[0] instanceof EmbeddedDocument) ***REMOVED***
      type = 'doc';
    ***REMOVED*** else if (values[0] instanceof Date) ***REMOVED***
      type = 'date';
    ***REMOVED***

    values.forEach(function(v) ***REMOVED***
      var found;
      switch (type) ***REMOVED***
        case 'doc':
          found = this.some(function(doc) ***REMOVED***
            return doc.equals(v);
          ***REMOVED***);
          break;
        case 'date':
          var val = +v;
          found = this.some(function(d) ***REMOVED***
            return +d === val;
          ***REMOVED***);
          break;
        default:
          found = ~this.indexOf(v);
      ***REMOVED***

      if (!found) ***REMOVED***
        [].push.call(this, v);
        this._registerAtomic('$addToSet', v);
        this._markModified();
        [].push.call(added, v);
      ***REMOVED***
    ***REMOVED***, this);

    return added;
  ***REMOVED***,

  /**
   * Sets the casted `val` at index `i` and marks the array modified.
   *
   * ####Example:
   *
   *     // given documents based on the following
   *     var Doc = mongoose.model('Doc', new Schema(***REMOVED*** array: [Number] ***REMOVED***));
   *
   *     var doc = new Doc(***REMOVED*** array: [2,3,4] ***REMOVED***)
   *
   *     console.log(doc.array) // [2,3,4]
   *
   *     doc.array.set(1,"5");
   *     console.log(doc.array); // [2,5,4] // properly cast to number
   *     doc.save() // the change is saved
   *
   *     // VS not using array#set
   *     doc.array[1] = "5";
   *     console.log(doc.array); // [2,"5",4] // no casting
   *     doc.save() // change is not saved
   *
   * @return ***REMOVED***Array***REMOVED*** this
   * @api public
   * @method set
   * @receiver MongooseArray
   */

  set: function set(i, val) ***REMOVED***
    var value = this._cast(val, i);
    value = this._schema.caster instanceof EmbeddedDocument ?
        value :
        this._schema.caster.applySetters(val, this._parent)
    ;
    this[i] = value;
    this._markModified(i);
    return this;
  ***REMOVED***,

  /**
   * Returns a native js Array.
   *
   * @param ***REMOVED***Object***REMOVED*** options
   * @return ***REMOVED***Array***REMOVED***
   * @api public
   * @method toObject
   * @receiver MongooseArray
   */

  toObject: function(options) ***REMOVED***
    if (options && options.depopulate) ***REMOVED***
      options._isNested = true;
      return this.map(function(doc) ***REMOVED***
        return doc instanceof Document
            ? doc.toObject(options)
            : doc;
      ***REMOVED***);
    ***REMOVED***

    return this.slice();
  ***REMOVED***,

  /**
   * Helper for console.log
   *
   * @api public
   * @method inspect
   * @receiver MongooseArray
   */

  inspect: function() ***REMOVED***
    return JSON.stringify(this);
  ***REMOVED***,

  /**
   * Return the index of `obj` or `-1` if not found.
   *
   * @param ***REMOVED***Object***REMOVED*** obj the item to look for
   * @return ***REMOVED***Number***REMOVED***
   * @api public
   * @method indexOf
   * @receiver MongooseArray
   */

  indexOf: function indexOf(obj) ***REMOVED***
    if (obj instanceof ObjectId) ***REMOVED***
      obj = obj.toString();
    ***REMOVED***
    for (var i = 0, len = this.length; i < len; ++i) ***REMOVED***
      if (obj == this[i]) ***REMOVED***
        return i;
      ***REMOVED***
    ***REMOVED***
    return -1;
  ***REMOVED***
***REMOVED***;

/**
 * Alias of [pull](#types_array_MongooseArray-pull)
 *
 * @see MongooseArray#pull #types_array_MongooseArray-pull
 * @see mongodb http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pull
 * @api public
 * @memberOf MongooseArray
 * @method remove
 */

MongooseArray.mixin.remove = MongooseArray.mixin.pull;

/*!
 * Module exports.
 */

module.exports = exports = MongooseArray;
