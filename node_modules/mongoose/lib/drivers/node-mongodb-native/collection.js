/*!
 * Module dependencies.
 */

var MongooseCollection = require('../../collection'),
    Collection = require('mongodb').Collection,
    utils = require('../../utils');

/**
 * A [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) collection implementation.
 *
 * All methods methods from the [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) driver are copied and wrapped in queue management.
 *
 * @inherits Collection
 * @api private
 */

function NativeCollection() ***REMOVED***
  this.collection = null;
  MongooseCollection.apply(this, arguments);
***REMOVED***

/*!
 * Inherit from abstract Collection.
 */

NativeCollection.prototype.__proto__ = MongooseCollection.prototype;

/**
 * Called when the connection opens.
 *
 * @api private
 */

NativeCollection.prototype.onOpen = function() ***REMOVED***
  var _this = this;

  // always get a new collection in case the user changed host:port
  // of parent db instance when re-opening the connection.

  if (!_this.opts.capped.size) ***REMOVED***
    // non-capped
    callback(null, _this.conn.db.collection(_this.name));
    return _this.collection;
  ***REMOVED***

  // capped
  return _this.conn.db.collection(_this.name, function(err, c) ***REMOVED***
    if (err) return callback(err);

    // discover if this collection exists and if it is capped
    _this.conn.db.listCollections(***REMOVED***name: _this.name***REMOVED***).toArray(function(err, docs) ***REMOVED***
      if (err) ***REMOVED***
        return callback(err);
      ***REMOVED***
      var doc = docs[0];
      var exists = !!doc;

      if (exists) ***REMOVED***
        if (doc.options && doc.options.capped) ***REMOVED***
          callback(null, c);
        ***REMOVED*** else ***REMOVED***
          var msg = 'A non-capped collection exists with the name: ' + _this.name + '\n\n'
              + ' To use this collection as a capped collection, please '
              + 'first convert it.\n'
              + ' http://www.mongodb.org/display/DOCS/Capped+Collections#CappedCollections-Convertingacollectiontocapped';
          err = new Error(msg);
          callback(err);
        ***REMOVED***
      ***REMOVED*** else ***REMOVED***
        // create
        var opts = utils.clone(_this.opts.capped);
        opts.capped = true;
        _this.conn.db.createCollection(_this.name, opts, callback);
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***);

  function callback(err, collection) ***REMOVED***
    if (err) ***REMOVED***
      // likely a strict mode error
      _this.conn.emit('error', err);
    ***REMOVED*** else ***REMOVED***
      _this.collection = collection;
      MongooseCollection.prototype.onOpen.call(_this);
    ***REMOVED***
  ***REMOVED***
***REMOVED***;

/**
 * Called when the connection closes
 *
 * @api private
 */

NativeCollection.prototype.onClose = function() ***REMOVED***
  MongooseCollection.prototype.onClose.call(this);
***REMOVED***;

/*!
 * Copy the collection methods and make them subject to queues
 */

function iter(i) ***REMOVED***
  NativeCollection.prototype[i] = function() ***REMOVED***
    if (this.buffer) ***REMOVED***
      this.addQueue(i, arguments);
      return;
    ***REMOVED***

    var collection = this.collection,
        args = arguments,
        _this = this,
        debug = _this.conn.base.options.debug;

    if (debug) ***REMOVED***
      if (typeof debug === 'function') ***REMOVED***
        debug.apply(debug,
          [_this.name, i].concat(utils.args(args, 0, args.length - 1)));
      ***REMOVED*** else ***REMOVED***
        this.$print(_this.name, i, args);
      ***REMOVED***
    ***REMOVED***

    try ***REMOVED***
      return collection[i].apply(collection, args);
    ***REMOVED*** catch (error) ***REMOVED***
      // Collection operation may throw because of max bson size, catch it here
      // See gh-3906
      if (args.length > 0 &&
          typeof args[args.length - 1] === 'function') ***REMOVED***
        args[args.length - 1](error);
      ***REMOVED*** else ***REMOVED***
        throw error;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***;
***REMOVED***

for (var i in Collection.prototype) ***REMOVED***
  // Janky hack to work around gh-3005 until we can get rid of the mongoose
  // collection abstraction
  try ***REMOVED***
    if (typeof Collection.prototype[i] !== 'function') ***REMOVED***
      continue;
    ***REMOVED***
  ***REMOVED*** catch (e) ***REMOVED***
    continue;
  ***REMOVED***

  iter(i);
***REMOVED***

/**
 * Debug print helper
 *
 * @api public
 * @method $print
 */

NativeCollection.prototype.$print = function(name, i, args) ***REMOVED***
  var moduleName = '\x1B[0;36mMongoose:\x1B[0m ';
  var functionCall = [name, i].join('.');
  var _args = [];
  for (var j = args.length - 1; j >= 0; --j) ***REMOVED***
    if (this.$format(args[j]) || _args.length) ***REMOVED***
      _args.unshift(this.$format(args[j]));
    ***REMOVED***
  ***REMOVED***
  var params = '(' + _args.join(', ') + ')';

  console.error(moduleName + functionCall + params);
***REMOVED***;

/**
 * Formatter for debug print args
 *
 * @api public
 * @method $format
 */

NativeCollection.prototype.$format = function(arg) ***REMOVED***
  var type = typeof arg;
  if (type === 'function' || type === 'undefined') return '';
  return format(arg);
***REMOVED***;

/*!
 * Debug print helper
 */

function map(o) ***REMOVED***
  return format(o, true);
***REMOVED***
function formatObjectId(x, key) ***REMOVED***
  var representation = 'ObjectId("' + x[key].toHexString() + '")';
  x[key] = ***REMOVED***inspect: function() ***REMOVED*** return representation; ***REMOVED******REMOVED***;
***REMOVED***
function formatDate(x, key) ***REMOVED***
  var representation = 'new Date("' + x[key].toUTCString() + '")';
  x[key] = ***REMOVED***inspect: function() ***REMOVED*** return representation; ***REMOVED******REMOVED***;
***REMOVED***
function format(obj, sub) ***REMOVED***
  if (obj && typeof obj.toBSON === 'function') ***REMOVED***
    obj = obj.toBSON();
  ***REMOVED***
  var x = utils.clone(obj, ***REMOVED***retainKeyOrder: 1, transform: false***REMOVED***);
  var representation;

  if (x != null) ***REMOVED***
    if (x.constructor.name === 'Binary') ***REMOVED***
      x = 'BinData(' + x.sub_type + ', "' + x.toString('base64') + '")';
    ***REMOVED*** else if (x.constructor.name === 'ObjectID') ***REMOVED***
      representation = 'ObjectId("' + x.toHexString() + '")';
      x = ***REMOVED***inspect: function() ***REMOVED*** return representation; ***REMOVED******REMOVED***;
    ***REMOVED*** else if (x.constructor.name === 'Date') ***REMOVED***
      representation = 'new Date("' + x.toUTCString() + '")';
      x = ***REMOVED***inspect: function() ***REMOVED*** return representation; ***REMOVED******REMOVED***;
    ***REMOVED*** else if (x.constructor.name === 'Object') ***REMOVED***
      var keys = Object.keys(x);
      var numKeys = keys.length;
      var key;
      for (var i = 0; i < numKeys; ++i) ***REMOVED***
        key = keys[i];
        if (x[key]) ***REMOVED***
          if (typeof x[key].toBSON === 'function') ***REMOVED***
            x[key] = x[key].toBSON();
          ***REMOVED***
          if (x[key].constructor.name === 'Binary') ***REMOVED***
            x[key] = 'BinData(' + x[key].sub_type + ', "' +
              x[key].buffer.toString('base64') + '")';
          ***REMOVED*** else if (x[key].constructor.name === 'Object') ***REMOVED***
            x[key] = format(x[key], true);
          ***REMOVED*** else if (x[key].constructor.name === 'ObjectID') ***REMOVED***
            formatObjectId(x, key);
          ***REMOVED*** else if (x[key].constructor.name === 'Date') ***REMOVED***
            formatDate(x, key);
          ***REMOVED*** else if (Array.isArray(x[key])) ***REMOVED***
            x[key] = x[key].map(map);
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
    if (sub) return x;
  ***REMOVED***

  return require('util')
  .inspect(x, false, 10, true)
  .replace(/\n/g, '')
  .replace(/\s***REMOVED***2,***REMOVED***/g, ' ');
***REMOVED***

/**
 * Retreives information about this collections indexes.
 *
 * @param ***REMOVED***Function***REMOVED*** callback
 * @method getIndexes
 * @api public
 */

NativeCollection.prototype.getIndexes = NativeCollection.prototype.indexInformation;

/*!
 * Module exports.
 */

module.exports = NativeCollection;
