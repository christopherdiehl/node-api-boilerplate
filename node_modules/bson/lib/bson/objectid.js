/**
 * Machine id.
 *
 * Create a random 3-byte value (i.e. unique for this
 * process). Other drivers use a md5 of the machine id here, but
 * that would mean an asyc call to gethostname, so we don't bother.
 * @ignore
 */
var MACHINE_ID = parseInt(Math.random() * 0xFFFFFF, 10);

// Regular expression that checks for hex value
var checkForHexRegExp = new RegExp("^[0-9a-fA-F]***REMOVED***24***REMOVED***$");
var hasBufferType = false;

// Check if buffer exists
try ***REMOVED***
  if(Buffer && Buffer.from) hasBufferType = true;
***REMOVED*** catch(err) ***REMOVED******REMOVED***;

/**
* Create a new ObjectID instance
*
* @class
* @param ***REMOVED***(string|number)***REMOVED*** id Can be a 24 byte hex string, 12 byte binary string or a Number.
* @property ***REMOVED***number***REMOVED*** generationTime The generation time of this ObjectId instance
* @return ***REMOVED***ObjectID***REMOVED*** instance of ObjectID.
*/
var ObjectID = function ObjectID(id) ***REMOVED***
  // Duck-typing to support ObjectId from different npm packages
  if(id instanceof ObjectID) return id;
  if(!(this instanceof ObjectID)) return new ObjectID(id);

  this._bsontype = 'ObjectID';

  // The most common usecase (blank id, new objectId instance)
  if(id == null || typeof id == 'number') ***REMOVED***
    // Generate a new id
    this.id = this.generate(id);
    // If we are caching the hex string
    if(ObjectID.cacheHexString) this.__id = this.toString('hex');
    // Return the object
    return;
  ***REMOVED***

  // Check if the passed in id is valid
  var valid = ObjectID.isValid(id);

  // Throw an error if it's not a valid setup
  if(!valid && id != null)***REMOVED***
    throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");
  ***REMOVED*** else if(valid && typeof id == 'string' && id.length == 24 && hasBufferType) ***REMOVED***
    return new ObjectID(Buffer.from(id, 'hex'));
  ***REMOVED*** else if(valid && typeof id == 'string' && id.length == 24) ***REMOVED***
    return ObjectID.createFromHexString(id);
  ***REMOVED*** else if(id != null && id.length === 12) ***REMOVED***
    // assume 12 byte string
    this.id = id;
  ***REMOVED*** else if(id != null && id.toHexString) ***REMOVED***
    // Duck-typing to support ObjectId from different npm packages
    return id;
  ***REMOVED*** else ***REMOVED***
    throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");
  ***REMOVED***

  if(ObjectID.cacheHexString) this.__id = this.toString('hex');
***REMOVED***;

// Allow usage of ObjectId as well as ObjectID
var ObjectId = ObjectID;

// Precomputed hex table enables speedy hex string conversion
var hexTable = [];
for (var i = 0; i < 256; i++) ***REMOVED***
  hexTable[i] = (i <= 15 ? '0' : '') + i.toString(16);
***REMOVED***

/**
* Return the ObjectID id as a 24 byte hex string representation
*
* @method
* @return ***REMOVED***string***REMOVED*** return the 24 byte hex string representation.
*/
ObjectID.prototype.toHexString = function() ***REMOVED***
  if(ObjectID.cacheHexString && this.__id) return this.__id;

  var hexString = '';
  if(!this.id || !this.id.length) ***REMOVED***
    throw new Error('invalid ObjectId, ObjectId.id must be either a string or a Buffer, but is [' + JSON.stringify(this.id) + ']');
  ***REMOVED***

  if(this.id instanceof _Buffer) ***REMOVED***
    hexString = convertToHex(this.id);
    if(ObjectID.cacheHexString) this.__id = hexString;
    return hexString;
  ***REMOVED***

  for (var i = 0; i < this.id.length; i++) ***REMOVED***
    hexString += hexTable[this.id.charCodeAt(i)];
  ***REMOVED***

  if(ObjectID.cacheHexString) this.__id = hexString;
  return hexString;
***REMOVED***;

/**
* Update the ObjectID index used in generating new ObjectID's on the driver
*
* @method
* @return ***REMOVED***number***REMOVED*** returns next index value.
* @ignore
*/
ObjectID.prototype.get_inc = function() ***REMOVED***
  return ObjectID.index = (ObjectID.index + 1) % 0xFFFFFF;
***REMOVED***;

/**
* Update the ObjectID index used in generating new ObjectID's on the driver
*
* @method
* @return ***REMOVED***number***REMOVED*** returns next index value.
* @ignore
*/
ObjectID.prototype.getInc = function() ***REMOVED***
  return this.get_inc();
***REMOVED***;

/**
* Generate a 12 byte id buffer used in ObjectID's
*
* @method
* @param ***REMOVED***number***REMOVED*** [time] optional parameter allowing to pass in a second based timestamp.
* @return ***REMOVED***Buffer***REMOVED*** return the 12 byte id buffer string.
*/
ObjectID.prototype.generate = function(time) ***REMOVED***
  if ('number' != typeof time) ***REMOVED***
    time = ~~(Date.now()/1000);
  ***REMOVED***

  // Use pid
  var pid = (typeof process === 'undefined' ? Math.floor(Math.random() * 100000) : process.pid) % 0xFFFF;
  var inc = this.get_inc();
  // Buffer used
  var buffer = new Buffer(12);
  // Encode time
  buffer[3] = time & 0xff;
  buffer[2] = (time >> 8) & 0xff;
  buffer[1] = (time >> 16) & 0xff;
  buffer[0] = (time >> 24) & 0xff;
  // Encode machine
  buffer[6] = MACHINE_ID & 0xff;
  buffer[5] = (MACHINE_ID >> 8) & 0xff;
  buffer[4] = (MACHINE_ID >> 16) & 0xff;
  // Encode pid
  buffer[8] = pid & 0xff;
  buffer[7] = (pid >> 8) & 0xff;
  // Encode index
  buffer[11] = inc & 0xff;
  buffer[10] = (inc >> 8) & 0xff;
  buffer[9] = (inc >> 16) & 0xff;
  // Return the buffer
  return buffer;
***REMOVED***;

/**
* Converts the id into a 24 byte hex string for printing
*
* @param ***REMOVED***String***REMOVED*** format The Buffer toString format parameter.
* @return ***REMOVED***String***REMOVED*** return the 24 byte hex string representation.
* @ignore
*/
ObjectID.prototype.toString = function(format) ***REMOVED***
  // Is the id a buffer then use the buffer toString method to return the format
  if(this.id && this.id.copy) ***REMOVED***
    return this.id.toString(typeof format === 'string' ? format : 'hex');
  ***REMOVED***

  // if(this.buffer )
  return this.toHexString();
***REMOVED***;

/**
* Converts to a string representation of this Id.
*
* @return ***REMOVED***String***REMOVED*** return the 24 byte hex string representation.
* @ignore
*/
ObjectID.prototype.inspect = ObjectID.prototype.toString;

/**
* Converts to its JSON representation.
*
* @return ***REMOVED***String***REMOVED*** return the 24 byte hex string representation.
* @ignore
*/
ObjectID.prototype.toJSON = function() ***REMOVED***
  return this.toHexString();
***REMOVED***;

/**
* Compares the equality of this ObjectID with `otherID`.
*
* @method
* @param ***REMOVED***object***REMOVED*** otherID ObjectID instance to compare against.
* @return ***REMOVED***boolean***REMOVED*** the result of comparing two ObjectID's
*/
ObjectID.prototype.equals = function equals (otherId) ***REMOVED***
  var id;

  if(otherId instanceof ObjectID) ***REMOVED***
    return this.toString() == otherId.toString();
  ***REMOVED*** else if(typeof otherId == 'string' && ObjectID.isValid(otherId) && otherId.length == 12 && this.id instanceof _Buffer) ***REMOVED***
    return otherId === this.id.toString('binary');
  ***REMOVED*** else if(typeof otherId == 'string' && ObjectID.isValid(otherId) && otherId.length == 24) ***REMOVED***
    return otherId.toLowerCase() === this.toHexString();
  ***REMOVED*** else if(typeof otherId == 'string' && ObjectID.isValid(otherId) && otherId.length == 12) ***REMOVED***
    return otherId === this.id;
  ***REMOVED*** else if(otherId != null && (otherId instanceof ObjectID || otherId.toHexString)) ***REMOVED***
    return otherId.toHexString() === this.toHexString();
  ***REMOVED*** else ***REMOVED***
    return false;
  ***REMOVED***
***REMOVED***

/**
* Returns the generation date (accurate up to the second) that this ID was generated.
*
* @method
* @return ***REMOVED***date***REMOVED*** the generation date
*/
ObjectID.prototype.getTimestamp = function() ***REMOVED***
  var timestamp = new Date();
  var time = this.id[3] | this.id[2] << 8 | this.id[1] << 16 | this.id[0] << 24;
  timestamp.setTime(Math.floor(time) * 1000);
  return timestamp;
***REMOVED***

/**
* @ignore
*/
ObjectID.index = ~~(Math.random() * 0xFFFFFF);

/**
* @ignore
*/
ObjectID.createPk = function createPk () ***REMOVED***
  return new ObjectID();
***REMOVED***;

/**
* Creates an ObjectID from a second based number, with the rest of the ObjectID zeroed out. Used for comparisons or sorting the ObjectID.
*
* @method
* @param ***REMOVED***number***REMOVED*** time an integer number representing a number of seconds.
* @return ***REMOVED***ObjectID***REMOVED*** return the created ObjectID
*/
ObjectID.createFromTime = function createFromTime (time) ***REMOVED***
  var buffer = new Buffer([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
  // Encode time into first 4 bytes
  buffer[3] = time & 0xff;
  buffer[2] = (time >> 8) & 0xff;
  buffer[1] = (time >> 16) & 0xff;
  buffer[0] = (time >> 24) & 0xff;
  // Return the new objectId
  return new ObjectID(buffer);
***REMOVED***;

// Lookup tables
var encodeLookup = '0123456789abcdef'.split('')
var decodeLookup = []
var i = 0
while (i < 10) decodeLookup[0x30 + i] = i++
while (i < 16) decodeLookup[0x41 - 10 + i] = decodeLookup[0x61 - 10 + i] = i++

var _Buffer = Buffer;
var convertToHex = function(bytes) ***REMOVED***
  return bytes.toString('hex');
***REMOVED***

/**
* Creates an ObjectID from a hex string representation of an ObjectID.
*
* @method
* @param ***REMOVED***string***REMOVED*** hexString create a ObjectID from a passed in 24 byte hexstring.
* @return ***REMOVED***ObjectID***REMOVED*** return the created ObjectID
*/
ObjectID.createFromHexString = function createFromHexString (string) ***REMOVED***
  // Throw an error if it's not a valid setup
  if(typeof string === 'undefined' || string != null && string.length != 24) ***REMOVED***
    throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");
  ***REMOVED***

  // Use Buffer.from method if available
  if(hasBufferType) return new ObjectID(Buffer.from(string, 'hex'));

  // Calculate lengths
  var array = new _Buffer(12);
  var n = 0;
  var i = 0;

  while (i < 24) ***REMOVED***
    array[n++] = decodeLookup[string.charCodeAt(i++)] << 4 | decodeLookup[string.charCodeAt(i++)]
  ***REMOVED***

  return new ObjectID(array);
***REMOVED***;

/**
* Checks if a value is a valid bson ObjectId
*
* @method
* @return ***REMOVED***boolean***REMOVED*** return true if the value is a valid bson ObjectId, return false otherwise.
*/
ObjectID.isValid = function isValid(id) ***REMOVED***
  if(id == null) return false;

  if(typeof id == 'number') ***REMOVED***
    return true;
  ***REMOVED***

  if(typeof id == 'string') ***REMOVED***
    return id.length == 12 || (id.length == 24 && checkForHexRegExp.test(id));
  ***REMOVED***

  if(id instanceof ObjectID) ***REMOVED***
    return true;
  ***REMOVED***

  if(id instanceof _Buffer) ***REMOVED***
    return true;
  ***REMOVED***

  // Duck-Typing detection of ObjectId like objects
  if(id.toHexString) ***REMOVED***
    return id.id.length == 12 || (id.id.length == 24 && checkForHexRegExp.test(id.id));
  ***REMOVED***

  return false;
***REMOVED***;

/**
* @ignore
*/
Object.defineProperty(ObjectID.prototype, "generationTime", ***REMOVED***
   enumerable: true
 , get: function () ***REMOVED***
     return this.id[3] | this.id[2] << 8 | this.id[1] << 16 | this.id[0] << 24;
   ***REMOVED***
 , set: function (value) ***REMOVED***
     // Encode time into first 4 bytes
     this.id[3] = value & 0xff;
     this.id[2] = (value >> 8) & 0xff;
     this.id[1] = (value >> 16) & 0xff;
     this.id[0] = (value >> 24) & 0xff;
   ***REMOVED***
***REMOVED***);

/**
 * Expose.
 */
module.exports = ObjectID;
module.exports.ObjectID = ObjectID;
module.exports.ObjectId = ObjectID;
