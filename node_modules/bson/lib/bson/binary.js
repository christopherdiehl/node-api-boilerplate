/**
 * Module dependencies.
 * @ignore
 */

// Test if we're in Node via presence of "global" not absence of "window"
// to support hybrid environments like Electron
if(typeof global !== 'undefined') ***REMOVED***
  var Buffer = require('buffer').Buffer; // TODO just use global Buffer
***REMOVED***

/**
 * A class representation of the BSON Binary type.
 *
 * Sub types
 *  - **BSON.BSON_BINARY_SUBTYPE_DEFAULT**, default BSON type.
 *  - **BSON.BSON_BINARY_SUBTYPE_FUNCTION**, BSON function type.
 *  - **BSON.BSON_BINARY_SUBTYPE_BYTE_ARRAY**, BSON byte array type.
 *  - **BSON.BSON_BINARY_SUBTYPE_UUID**, BSON uuid type.
 *  - **BSON.BSON_BINARY_SUBTYPE_MD5**, BSON md5 type.
 *  - **BSON.BSON_BINARY_SUBTYPE_USER_DEFINED**, BSON user defined type.
 *
 * @class
 * @param ***REMOVED***Buffer***REMOVED*** buffer a buffer object containing the binary data.
 * @param ***REMOVED***Number***REMOVED*** [subType] the option binary type.
 * @return ***REMOVED***Binary***REMOVED***
 */
function Binary(buffer, subType) ***REMOVED***
  if(!(this instanceof Binary)) return new Binary(buffer, subType);

  this._bsontype = 'Binary';

  if(buffer instanceof Number) ***REMOVED***
    this.sub_type = buffer;
    this.position = 0;
  ***REMOVED*** else ***REMOVED***
    this.sub_type = subType == null ? BSON_BINARY_SUBTYPE_DEFAULT : subType;
    this.position = 0;
  ***REMOVED***

  if(buffer != null && !(buffer instanceof Number)) ***REMOVED***
    // Only accept Buffer, Uint8Array or Arrays
    if(typeof buffer == 'string') ***REMOVED***
      // Different ways of writing the length of the string for the different types
      if(typeof Buffer != 'undefined') ***REMOVED***
        this.buffer = new Buffer(buffer);
      ***REMOVED*** else if(typeof Uint8Array != 'undefined' || (Object.prototype.toString.call(buffer) == '[object Array]')) ***REMOVED***
        this.buffer = writeStringToArray(buffer);
      ***REMOVED*** else ***REMOVED***
        throw new Error("only String, Buffer, Uint8Array or Array accepted");
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
      this.buffer = buffer;
    ***REMOVED***
    this.position = buffer.length;
  ***REMOVED*** else ***REMOVED***
    if(typeof Buffer != 'undefined') ***REMOVED***
      this.buffer =  new Buffer(Binary.BUFFER_SIZE);
    ***REMOVED*** else if(typeof Uint8Array != 'undefined')***REMOVED***
      this.buffer = new Uint8Array(new ArrayBuffer(Binary.BUFFER_SIZE));
    ***REMOVED*** else ***REMOVED***
      this.buffer = new Array(Binary.BUFFER_SIZE);
    ***REMOVED***
    // Set position to start of buffer
    this.position = 0;
  ***REMOVED***
***REMOVED***;

/**
 * Updates this binary with byte_value.
 *
 * @method
 * @param ***REMOVED***string***REMOVED*** byte_value a single byte we wish to write.
 */
Binary.prototype.put = function put(byte_value) ***REMOVED***
  // If it's a string and a has more than one character throw an error
  if(byte_value['length'] != null && typeof byte_value != 'number' && byte_value.length != 1) throw new Error("only accepts single character String, Uint8Array or Array");
  if(typeof byte_value != 'number' && byte_value < 0 || byte_value > 255) throw new Error("only accepts number in a valid unsigned byte range 0-255");

  // Decode the byte value once
  var decoded_byte = null;
  if(typeof byte_value == 'string') ***REMOVED***
    decoded_byte = byte_value.charCodeAt(0);
  ***REMOVED*** else if(byte_value['length'] != null) ***REMOVED***
    decoded_byte = byte_value[0];
  ***REMOVED*** else ***REMOVED***
    decoded_byte = byte_value;
  ***REMOVED***

  if(this.buffer.length > this.position) ***REMOVED***
    this.buffer[this.position++] = decoded_byte;
  ***REMOVED*** else ***REMOVED***
    if(typeof Buffer != 'undefined' && Buffer.isBuffer(this.buffer)) ***REMOVED***
      // Create additional overflow buffer
      var buffer = new Buffer(Binary.BUFFER_SIZE + this.buffer.length);
      // Combine the two buffers together
      this.buffer.copy(buffer, 0, 0, this.buffer.length);
      this.buffer = buffer;
      this.buffer[this.position++] = decoded_byte;
    ***REMOVED*** else ***REMOVED***
      var buffer = null;
      // Create a new buffer (typed or normal array)
      if(Object.prototype.toString.call(this.buffer) == '[object Uint8Array]') ***REMOVED***
        buffer = new Uint8Array(new ArrayBuffer(Binary.BUFFER_SIZE + this.buffer.length));
      ***REMOVED*** else ***REMOVED***
        buffer = new Array(Binary.BUFFER_SIZE + this.buffer.length);
      ***REMOVED***

      // We need to copy all the content to the new array
      for(var i = 0; i < this.buffer.length; i++) ***REMOVED***
        buffer[i] = this.buffer[i];
      ***REMOVED***

      // Reassign the buffer
      this.buffer = buffer;
      // Write the byte
      this.buffer[this.position++] = decoded_byte;
    ***REMOVED***
  ***REMOVED***
***REMOVED***;

/**
 * Writes a buffer or string to the binary.
 *
 * @method
 * @param ***REMOVED***(Buffer|string)***REMOVED*** string a string or buffer to be written to the Binary BSON object.
 * @param ***REMOVED***number***REMOVED*** offset specify the binary of where to write the content.
 * @return ***REMOVED***null***REMOVED***
 */
Binary.prototype.write = function write(string, offset) ***REMOVED***
  offset = typeof offset == 'number' ? offset : this.position;

  // If the buffer is to small let's extend the buffer
  if(this.buffer.length < offset + string.length) ***REMOVED***
    var buffer = null;
    // If we are in node.js
    if(typeof Buffer != 'undefined' && Buffer.isBuffer(this.buffer)) ***REMOVED***
      buffer = new Buffer(this.buffer.length + string.length);
      this.buffer.copy(buffer, 0, 0, this.buffer.length);
    ***REMOVED*** else if(Object.prototype.toString.call(this.buffer) == '[object Uint8Array]') ***REMOVED***
      // Create a new buffer
      buffer = new Uint8Array(new ArrayBuffer(this.buffer.length + string.length))
      // Copy the content
      for(var i = 0; i < this.position; i++) ***REMOVED***
        buffer[i] = this.buffer[i];
      ***REMOVED***
    ***REMOVED***

    // Assign the new buffer
    this.buffer = buffer;
  ***REMOVED***

  if(typeof Buffer != 'undefined' && Buffer.isBuffer(string) && Buffer.isBuffer(this.buffer)) ***REMOVED***
    string.copy(this.buffer, offset, 0, string.length);
    this.position = (offset + string.length) > this.position ? (offset + string.length) : this.position;
    // offset = string.length
  ***REMOVED*** else if(typeof Buffer != 'undefined' && typeof string == 'string' && Buffer.isBuffer(this.buffer)) ***REMOVED***
    this.buffer.write(string, offset, 'binary');
    this.position = (offset + string.length) > this.position ? (offset + string.length) : this.position;
    // offset = string.length;
  ***REMOVED*** else if(Object.prototype.toString.call(string) == '[object Uint8Array]'
    || Object.prototype.toString.call(string) == '[object Array]' && typeof string != 'string') ***REMOVED***
    for(var i = 0; i < string.length; i++) ***REMOVED***
      this.buffer[offset++] = string[i];
    ***REMOVED***

    this.position = offset > this.position ? offset : this.position;
  ***REMOVED*** else if(typeof string == 'string') ***REMOVED***
    for(var i = 0; i < string.length; i++) ***REMOVED***
      this.buffer[offset++] = string.charCodeAt(i);
    ***REMOVED***

    this.position = offset > this.position ? offset : this.position;
  ***REMOVED***
***REMOVED***;

/**
 * Reads **length** bytes starting at **position**.
 *
 * @method
 * @param ***REMOVED***number***REMOVED*** position read from the given position in the Binary.
 * @param ***REMOVED***number***REMOVED*** length the number of bytes to read.
 * @return ***REMOVED***Buffer***REMOVED***
 */
Binary.prototype.read = function read(position, length) ***REMOVED***
  length = length && length > 0
    ? length
    : this.position;

  // Let's return the data based on the type we have
  if(this.buffer['slice']) ***REMOVED***
    return this.buffer.slice(position, position + length);
  ***REMOVED*** else ***REMOVED***
    // Create a buffer to keep the result
    var buffer = typeof Uint8Array != 'undefined' ? new Uint8Array(new ArrayBuffer(length)) : new Array(length);
    for(var i = 0; i < length; i++) ***REMOVED***
      buffer[i] = this.buffer[position++];
    ***REMOVED***
  ***REMOVED***
  // Return the buffer
  return buffer;
***REMOVED***;

/**
 * Returns the value of this binary as a string.
 *
 * @method
 * @return ***REMOVED***string***REMOVED***
 */
Binary.prototype.value = function value(asRaw) ***REMOVED***
  asRaw = asRaw == null ? false : asRaw;

  // Optimize to serialize for the situation where the data == size of buffer
  if(asRaw && typeof Buffer != 'undefined' && Buffer.isBuffer(this.buffer) && this.buffer.length == this.position)
    return this.buffer;

  // If it's a node.js buffer object
  if(typeof Buffer != 'undefined' && Buffer.isBuffer(this.buffer)) ***REMOVED***
    return asRaw ? this.buffer.slice(0, this.position) : this.buffer.toString('binary', 0, this.position);
  ***REMOVED*** else ***REMOVED***
    if(asRaw) ***REMOVED***
      // we support the slice command use it
      if(this.buffer['slice'] != null) ***REMOVED***
        return this.buffer.slice(0, this.position);
      ***REMOVED*** else ***REMOVED***
        // Create a new buffer to copy content to
        var newBuffer = Object.prototype.toString.call(this.buffer) == '[object Uint8Array]' ? new Uint8Array(new ArrayBuffer(this.position)) : new Array(this.position);
        // Copy content
        for(var i = 0; i < this.position; i++) ***REMOVED***
          newBuffer[i] = this.buffer[i];
        ***REMOVED***
        // Return the buffer
        return newBuffer;
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
      return convertArraytoUtf8BinaryString(this.buffer, 0, this.position);
    ***REMOVED***
  ***REMOVED***
***REMOVED***;

/**
 * Length.
 *
 * @method
 * @return ***REMOVED***number***REMOVED*** the length of the binary.
 */
Binary.prototype.length = function length() ***REMOVED***
  return this.position;
***REMOVED***;

/**
 * @ignore
 */
Binary.prototype.toJSON = function() ***REMOVED***
  return this.buffer != null ? this.buffer.toString('base64') : '';
***REMOVED***

/**
 * @ignore
 */
Binary.prototype.toString = function(format) ***REMOVED***
  return this.buffer != null ? this.buffer.slice(0, this.position).toString(format) : '';
***REMOVED***

/**
 * Binary default subtype
 * @ignore
 */
var BSON_BINARY_SUBTYPE_DEFAULT = 0;

/**
 * @ignore
 */
var writeStringToArray = function(data) ***REMOVED***
  // Create a buffer
  var buffer = typeof Uint8Array != 'undefined' ? new Uint8Array(new ArrayBuffer(data.length)) : new Array(data.length);
  // Write the content to the buffer
  for(var i = 0; i < data.length; i++) ***REMOVED***
    buffer[i] = data.charCodeAt(i);
  ***REMOVED***
  // Write the string to the buffer
  return buffer;
***REMOVED***

/**
 * Convert Array ot Uint8Array to Binary String
 *
 * @ignore
 */
var convertArraytoUtf8BinaryString = function(byteArray, startIndex, endIndex) ***REMOVED***
  var result = "";
  for(var i = startIndex; i < endIndex; i++) ***REMOVED***
   result = result + String.fromCharCode(byteArray[i]);
  ***REMOVED***
  return result;
***REMOVED***;

Binary.BUFFER_SIZE = 256;

/**
 * Default BSON type
 *
 * @classconstant SUBTYPE_DEFAULT
 **/
Binary.SUBTYPE_DEFAULT = 0;
/**
 * Function BSON type
 *
 * @classconstant SUBTYPE_DEFAULT
 **/
Binary.SUBTYPE_FUNCTION = 1;
/**
 * Byte Array BSON type
 *
 * @classconstant SUBTYPE_DEFAULT
 **/
Binary.SUBTYPE_BYTE_ARRAY = 2;
/**
 * OLD UUID BSON type
 *
 * @classconstant SUBTYPE_DEFAULT
 **/
Binary.SUBTYPE_UUID_OLD = 3;
/**
 * UUID BSON type
 *
 * @classconstant SUBTYPE_DEFAULT
 **/
Binary.SUBTYPE_UUID = 4;
/**
 * MD5 BSON type
 *
 * @classconstant SUBTYPE_DEFAULT
 **/
Binary.SUBTYPE_MD5 = 5;
/**
 * User BSON type
 *
 * @classconstant SUBTYPE_DEFAULT
 **/
Binary.SUBTYPE_USER_DEFINED = 128;

/**
 * Expose.
 */
module.exports = Binary;
module.exports.Binary = Binary;
