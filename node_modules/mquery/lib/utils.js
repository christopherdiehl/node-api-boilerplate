'use strict';

/*!
 * Module dependencies.
 */

var RegExpClone = require('regexp-clone')

/**
 * Clones objects
 *
 * @param ***REMOVED***Object***REMOVED*** obj the object to clone
 * @param ***REMOVED***Object***REMOVED*** options
 * @return ***REMOVED***Object***REMOVED*** the cloned object
 * @api private
 */

var clone = exports.clone = function clone (obj, options) ***REMOVED***
  if (obj === undefined || obj === null)
    return obj;

  if (Array.isArray(obj))
    return exports.cloneArray(obj, options);

  if (obj.constructor) ***REMOVED***
    if (/ObjectI[dD]$/.test(obj.constructor.name)) ***REMOVED***
      return 'function' == typeof obj.clone
        ? obj.clone()
        : new obj.constructor(obj.id);
    ***REMOVED***

    if ('ReadPreference' === obj._type && obj.isValid && obj.toObject) ***REMOVED***
      return 'function' == typeof obj.clone
        ? obj.clone()
        : new obj.constructor(obj.mode, clone(obj.tags, options));
    ***REMOVED***

    if ('Binary' == obj._bsontype && obj.buffer && obj.value) ***REMOVED***
      return 'function' == typeof obj.clone
        ? obj.clone()
        : new obj.constructor(obj.value(true), obj.sub_type);
    ***REMOVED***

    if ('Date' === obj.constructor.name || 'Function' === obj.constructor.name)
      return new obj.constructor(+obj);

    if ('RegExp' === obj.constructor.name)
      return RegExpClone(obj);

    if ('Buffer' === obj.constructor.name)
      return exports.cloneBuffer(obj);
  ***REMOVED***

  if (isObject(obj))
    return exports.cloneObject(obj, options);

  if (obj.valueOf)
    return obj.valueOf();
***REMOVED***;

/*!
 * ignore
 */

var cloneObject = exports.cloneObject = function cloneObject (obj, options) ***REMOVED***
  var retainKeyOrder = options && options.retainKeyOrder
    , minimize = options && options.minimize
    , ret = ***REMOVED******REMOVED***
    , hasKeys
    , keys
    , val
    , k
    , i

  if (retainKeyOrder) ***REMOVED***
    for (k in obj) ***REMOVED***
      val = clone(obj[k], options);

      if (!minimize || ('undefined' !== typeof val)) ***REMOVED***
        hasKeys || (hasKeys = true);
        ret[k] = val;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    // faster

    keys = Object.keys(obj);
    i = keys.length;

    while (i--) ***REMOVED***
      k = keys[i];
      val = clone(obj[k], options);

      if (!minimize || ('undefined' !== typeof val)) ***REMOVED***
        if (!hasKeys) hasKeys = true;
        ret[k] = val;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  return minimize
    ? hasKeys && ret
    : ret;
***REMOVED***;

var cloneArray = exports.cloneArray = function cloneArray (arr, options) ***REMOVED***
  var ret = [];
  for (var i = 0, l = arr.length; i < l; i++)
    ret.push(clone(arr[i], options));
  return ret;
***REMOVED***;

/**
 * process.nextTick helper.
 *
 * Wraps the given `callback` in a try/catch. If an error is
 * caught it will be thrown on nextTick.
 *
 * node-mongodb-native had a habit of state corruption when
 * an error was immediately thrown from within a collection
 * method (find, update, etc) callback.
 *
 * @param ***REMOVED***Function***REMOVED*** [callback]
 * @api private
 */

var tick = exports.tick = function tick (callback) ***REMOVED***
  if ('function' !== typeof callback) return;
  return function () ***REMOVED***
    // callbacks should always be fired on the next
    // turn of the event loop. A side benefit is
    // errors thrown from executing the callback
    // will not cause drivers state to be corrupted
    // which has historically been a problem.
    var args = arguments;
    soon(function()***REMOVED***
      callback.apply(this, args);
    ***REMOVED***);
  ***REMOVED***
***REMOVED***

/**
 * Merges `from` into `to` without overwriting existing properties.
 *
 * @param ***REMOVED***Object***REMOVED*** to
 * @param ***REMOVED***Object***REMOVED*** from
 * @api private
 */

var merge = exports.merge = function merge (to, from) ***REMOVED***
  var keys = Object.keys(from)
    , i = keys.length
    , key

  while (i--) ***REMOVED***
    key = keys[i];
    if ('undefined' === typeof to[key]) ***REMOVED***
      to[key] = from[key];
    ***REMOVED*** else ***REMOVED***
      if (exports.isObject(from[key])) ***REMOVED***
        merge(to[key], from[key]);
      ***REMOVED*** else ***REMOVED***
        to[key] = from[key];
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***

/**
 * Same as merge but clones the assigned values.
 *
 * @param ***REMOVED***Object***REMOVED*** to
 * @param ***REMOVED***Object***REMOVED*** from
 * @api private
 */

var mergeClone = exports.mergeClone = function mergeClone (to, from) ***REMOVED***
  var keys = Object.keys(from)
    , i = keys.length
    , key

  while (i--) ***REMOVED***
    key = keys[i];
    if ('undefined' === typeof to[key]) ***REMOVED***
      // make sure to retain key order here because of a bug handling the $each
      // operator in mongodb 2.4.4
      to[key] = clone(from[key], ***REMOVED*** retainKeyOrder : 1***REMOVED***);
    ***REMOVED*** else ***REMOVED***
      if (exports.isObject(from[key])) ***REMOVED***
        mergeClone(to[key], from[key]);
      ***REMOVED*** else ***REMOVED***
        // make sure to retain key order here because of a bug handling the
        // $each operator in mongodb 2.4.4
        to[key] = clone(from[key], ***REMOVED*** retainKeyOrder : 1***REMOVED***);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***

/**
 * Read pref helper (mongo 2.2 drivers support this)
 *
 * Allows using aliases instead of full preference names:
 *
 *     p   primary
 *     pp  primaryPreferred
 *     s   secondary
 *     sp  secondaryPreferred
 *     n   nearest
 *
 * @param ***REMOVED***String***REMOVED*** pref
 */

exports.readPref = function readPref (pref) ***REMOVED***
  switch (pref) ***REMOVED***
    case 'p':
      pref = 'primary';
      break;
    case 'pp':
      pref = 'primaryPreferred';
      break;
    case 's':
      pref = 'secondary';
      break;
    case 'sp':
      pref = 'secondaryPreferred';
      break;
    case 'n':
      pref = 'nearest';
      break;
  ***REMOVED***

  return pref;
***REMOVED***

/**
 * Object.prototype.toString.call helper
 */

var _toString = Object.prototype.toString;
var toString = exports.toString = function (arg) ***REMOVED***
  return _toString.call(arg);
***REMOVED***

/**
 * Determines if `arg` is an object.
 *
 * @param ***REMOVED***Object|Array|String|Function|RegExp|any***REMOVED*** arg
 * @return ***REMOVED***Boolean***REMOVED***
 */

var isObject = exports.isObject = function (arg) ***REMOVED***
  return '[object Object]' == exports.toString(arg);
***REMOVED***

/**
 * Determines if `arg` is an array.
 *
 * @param ***REMOVED***Object***REMOVED***
 * @return ***REMOVED***Boolean***REMOVED***
 * @see nodejs utils
 */

var isArray = exports.isArray = function (arg) ***REMOVED***
  return Array.isArray(arg) ||
    'object' == typeof arg && '[object Array]' == exports.toString(arg);
***REMOVED***

/**
 * Object.keys helper
 */

exports.keys = Object.keys || function (obj) ***REMOVED***
  var keys = [];
  for (var k in obj) if (obj.hasOwnProperty(k)) ***REMOVED***
    keys.push(k);
  ***REMOVED***
  return keys;
***REMOVED***

/**
 * Basic Object.create polyfill.
 * Only one argument is supported.
 *
 * Based on https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/create
 */

exports.create = 'function' == typeof Object.create
  ? Object.create
  : create;

function create (proto) ***REMOVED***
  if (arguments.length > 1) ***REMOVED***
    throw new Error("Adding properties is not supported")
  ***REMOVED***

  function F () ***REMOVED******REMOVED***
  F.prototype = proto;
  return new F;
***REMOVED***

/**
 * inheritance
 */

exports.inherits = function (ctor, superCtor) ***REMOVED***
  ctor.prototype = exports.create(superCtor.prototype);
  ctor.prototype.constructor = ctor;
***REMOVED***

/**
 * nextTick helper
 * compat with node 0.10 which behaves differently than previous versions
 */

var soon = exports.soon = 'function' == typeof setImmediate
  ? setImmediate
  : process.nextTick;

/**
 * Clones the contents of a buffer.
 *
 * @param ***REMOVED***Buffer***REMOVED*** buff
 * @return ***REMOVED***Buffer***REMOVED***
 */

exports.cloneBuffer = function (buff) ***REMOVED***
  var dupe = new Buffer(buff.length);
  buff.copy(dupe, 0, 0, buff.length);
  return dupe;
***REMOVED***;

/**
 * Check if this object is an arguments object
 *
 * @param ***REMOVED***Any***REMOVED*** v
 * @return ***REMOVED***Boolean***REMOVED***
 */

exports.isArgumentsObject = function(v) ***REMOVED***
  return Object.prototype.toString.call(v) === '[object Arguments]';
***REMOVED***;
