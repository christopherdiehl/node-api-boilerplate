'use strict';

var test = require('tape');
var qs = require('../');
var iconv = require('iconv-lite');

test('stringify()', function (t) ***REMOVED***
    t.test('stringifies a querystring object', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** a: 'b' ***REMOVED***), 'a=b');
        st.equal(qs.stringify(***REMOVED*** a: 1 ***REMOVED***), 'a=1');
        st.equal(qs.stringify(***REMOVED*** a: 1, b: 2 ***REMOVED***), 'a=1&b=2');
        st.equal(qs.stringify(***REMOVED*** a: 'A_Z' ***REMOVED***), 'a=A_Z');
        st.equal(qs.stringify(***REMOVED*** a: '‚Ç¨' ***REMOVED***), 'a=%E2%82%AC');
        st.equal(qs.stringify(***REMOVED*** a: 'ÓÄÄ' ***REMOVED***), 'a=%EE%80%80');
        st.equal(qs.stringify(***REMOVED*** a: '◊ê' ***REMOVED***), 'a=%D7%90');
        st.equal(qs.stringify(***REMOVED*** a: 'êê∑' ***REMOVED***), 'a=%F0%90%90%B7');
        st.end();
    ***REMOVED***);

    t.test('stringifies a nested object', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** a: ***REMOVED*** b: 'c' ***REMOVED*** ***REMOVED***), 'a%5Bb%5D=c');
        st.equal(qs.stringify(***REMOVED*** a: ***REMOVED*** b: ***REMOVED*** c: ***REMOVED*** d: 'e' ***REMOVED*** ***REMOVED*** ***REMOVED*** ***REMOVED***), 'a%5Bb%5D%5Bc%5D%5Bd%5D=e');
        st.end();
    ***REMOVED***);

    t.test('stringifies a nested object with dots notation', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** a: ***REMOVED*** b: 'c' ***REMOVED*** ***REMOVED***, ***REMOVED*** allowDots: true ***REMOVED***), 'a.b=c');
        st.equal(qs.stringify(***REMOVED*** a: ***REMOVED*** b: ***REMOVED*** c: ***REMOVED*** d: 'e' ***REMOVED*** ***REMOVED*** ***REMOVED*** ***REMOVED***, ***REMOVED*** allowDots: true ***REMOVED***), 'a.b.c.d=e');
        st.end();
    ***REMOVED***);

    t.test('stringifies an array value', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** a: ['b', 'c', 'd'] ***REMOVED***), 'a%5B0%5D=b&a%5B1%5D=c&a%5B2%5D=d');
        st.end();
    ***REMOVED***);

    t.test('omits nulls when asked', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** a: 'b', c: null ***REMOVED***, ***REMOVED*** skipNulls: true ***REMOVED***), 'a=b');
        st.end();
    ***REMOVED***);


    t.test('omits nested nulls when asked', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** a: ***REMOVED*** b: 'c', d: null ***REMOVED*** ***REMOVED***, ***REMOVED*** skipNulls: true ***REMOVED***), 'a%5Bb%5D=c');
        st.end();
    ***REMOVED***);

    t.test('omits array indices when asked', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** a: ['b', 'c', 'd'] ***REMOVED***, ***REMOVED*** indices: false ***REMOVED***), 'a=b&a=c&a=d');
        st.end();
    ***REMOVED***);

    t.test('stringifies a nested array value', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** a: ***REMOVED*** b: ['c', 'd'] ***REMOVED*** ***REMOVED***), 'a%5Bb%5D%5B0%5D=c&a%5Bb%5D%5B1%5D=d');
        st.end();
    ***REMOVED***);

    t.test('stringifies a nested array value with dots notation', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** a: ***REMOVED*** b: ['c', 'd'] ***REMOVED*** ***REMOVED***, ***REMOVED*** allowDots: true, encode: false ***REMOVED***), 'a.b[0]=c&a.b[1]=d');
        st.end();
    ***REMOVED***);

    t.test('stringifies an object inside an array', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** a: [***REMOVED*** b: 'c' ***REMOVED***] ***REMOVED***), 'a%5B0%5D%5Bb%5D=c');
        st.equal(qs.stringify(***REMOVED*** a: [***REMOVED*** b: ***REMOVED*** c: [1] ***REMOVED*** ***REMOVED***] ***REMOVED***), 'a%5B0%5D%5Bb%5D%5Bc%5D%5B0%5D=1');
        st.end();
    ***REMOVED***);

    t.test('stringifies an array with mixed objects and primitives', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** a: [***REMOVED*** b: 1 ***REMOVED***, 2, 3] ***REMOVED***, ***REMOVED*** encode: false ***REMOVED***), 'a[0][b]=1&a[1]=2&a[2]=3');
        st.end();
    ***REMOVED***);

    t.test('stringifies an object inside an array with dots notation', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** a: [***REMOVED*** b: 'c' ***REMOVED***] ***REMOVED***, ***REMOVED*** allowDots: true, encode: false ***REMOVED***), 'a[0].b=c');
        st.equal(qs.stringify(***REMOVED*** a: [***REMOVED*** b: ***REMOVED*** c: [1] ***REMOVED*** ***REMOVED***] ***REMOVED***, ***REMOVED*** allowDots: true, encode: false ***REMOVED***), 'a[0].b.c[0]=1');
        st.end();
    ***REMOVED***);

    t.test('does not omit object keys when indices = false', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** a: [***REMOVED*** b: 'c' ***REMOVED***] ***REMOVED***, ***REMOVED*** indices: false ***REMOVED***), 'a%5Bb%5D=c');
        st.end();
    ***REMOVED***);

    t.test('uses indices notation for arrays when indices=true', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** a: ['b', 'c'] ***REMOVED***, ***REMOVED*** indices: true ***REMOVED***), 'a%5B0%5D=b&a%5B1%5D=c');
        st.end();
    ***REMOVED***);

    t.test('uses indices notation for arrays when no arrayFormat is specified', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** a: ['b', 'c'] ***REMOVED***), 'a%5B0%5D=b&a%5B1%5D=c');
        st.end();
    ***REMOVED***);

    t.test('uses indices notation for arrays when no arrayFormat=indices', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** a: ['b', 'c'] ***REMOVED***, ***REMOVED*** arrayFormat: 'indices' ***REMOVED***), 'a%5B0%5D=b&a%5B1%5D=c');
        st.end();
    ***REMOVED***);

    t.test('uses repeat notation for arrays when no arrayFormat=repeat', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** a: ['b', 'c'] ***REMOVED***, ***REMOVED*** arrayFormat: 'repeat' ***REMOVED***), 'a=b&a=c');
        st.end();
    ***REMOVED***);

    t.test('uses brackets notation for arrays when no arrayFormat=brackets', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** a: ['b', 'c'] ***REMOVED***, ***REMOVED*** arrayFormat: 'brackets' ***REMOVED***), 'a%5B%5D=b&a%5B%5D=c');
        st.end();
    ***REMOVED***);

    t.test('stringifies a complicated object', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** a: ***REMOVED*** b: 'c', d: 'e' ***REMOVED*** ***REMOVED***), 'a%5Bb%5D=c&a%5Bd%5D=e');
        st.end();
    ***REMOVED***);

    t.test('stringifies an empty value', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** a: '' ***REMOVED***), 'a=');
        st.equal(qs.stringify(***REMOVED*** a: null ***REMOVED***, ***REMOVED*** strictNullHandling: true ***REMOVED***), 'a');

        st.equal(qs.stringify(***REMOVED*** a: '', b: '' ***REMOVED***), 'a=&b=');
        st.equal(qs.stringify(***REMOVED*** a: null, b: '' ***REMOVED***, ***REMOVED*** strictNullHandling: true ***REMOVED***), 'a&b=');

        st.equal(qs.stringify(***REMOVED*** a: ***REMOVED*** b: '' ***REMOVED*** ***REMOVED***), 'a%5Bb%5D=');
        st.equal(qs.stringify(***REMOVED*** a: ***REMOVED*** b: null ***REMOVED*** ***REMOVED***, ***REMOVED*** strictNullHandling: true ***REMOVED***), 'a%5Bb%5D');
        st.equal(qs.stringify(***REMOVED*** a: ***REMOVED*** b: null ***REMOVED*** ***REMOVED***, ***REMOVED*** strictNullHandling: false ***REMOVED***), 'a%5Bb%5D=');

        st.end();
    ***REMOVED***);

    t.test('stringifies an empty object', function (st) ***REMOVED***
        var obj = Object.create(null);
        obj.a = 'b';
        st.equal(qs.stringify(obj), 'a=b');
        st.end();
    ***REMOVED***);

    t.test('returns an empty string for invalid input', function (st) ***REMOVED***
        st.equal(qs.stringify(undefined), '');
        st.equal(qs.stringify(false), '');
        st.equal(qs.stringify(null), '');
        st.equal(qs.stringify(''), '');
        st.end();
    ***REMOVED***);

    t.test('stringifies an object with an empty object as a child', function (st) ***REMOVED***
        var obj = ***REMOVED***
            a: Object.create(null)
        ***REMOVED***;

        obj.a.b = 'c';
        st.equal(qs.stringify(obj), 'a%5Bb%5D=c');
        st.end();
    ***REMOVED***);

    t.test('drops keys with a value of undefined', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** a: undefined ***REMOVED***), '');

        st.equal(qs.stringify(***REMOVED*** a: ***REMOVED*** b: undefined, c: null ***REMOVED*** ***REMOVED***, ***REMOVED*** strictNullHandling: true ***REMOVED***), 'a%5Bc%5D');
        st.equal(qs.stringify(***REMOVED*** a: ***REMOVED*** b: undefined, c: null ***REMOVED*** ***REMOVED***, ***REMOVED*** strictNullHandling: false ***REMOVED***), 'a%5Bc%5D=');
        st.equal(qs.stringify(***REMOVED*** a: ***REMOVED*** b: undefined, c: '' ***REMOVED*** ***REMOVED***), 'a%5Bc%5D=');
        st.end();
    ***REMOVED***);

    t.test('url encodes values', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** a: 'b c' ***REMOVED***), 'a=b%20c');
        st.end();
    ***REMOVED***);

    t.test('stringifies a date', function (st) ***REMOVED***
        var now = new Date();
        var str = 'a=' + encodeURIComponent(now.toISOString());
        st.equal(qs.stringify(***REMOVED*** a: now ***REMOVED***), str);
        st.end();
    ***REMOVED***);

    t.test('stringifies the weird object from qs', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** 'my weird field': '~q1!2"\'w$5&7/z8)?' ***REMOVED***), 'my%20weird%20field=~q1%212%22%27w%245%267%2Fz8%29%3F');
        st.end();
    ***REMOVED***);

    t.test('skips properties that are part of the object prototype', function (st) ***REMOVED***
        Object.prototype.crash = 'test';
        st.equal(qs.stringify(***REMOVED*** a: 'b' ***REMOVED***), 'a=b');
        st.equal(qs.stringify(***REMOVED*** a: ***REMOVED*** b: 'c' ***REMOVED*** ***REMOVED***), 'a%5Bb%5D=c');
        delete Object.prototype.crash;
        st.end();
    ***REMOVED***);

    t.test('stringifies boolean values', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** a: true ***REMOVED***), 'a=true');
        st.equal(qs.stringify(***REMOVED*** a: ***REMOVED*** b: true ***REMOVED*** ***REMOVED***), 'a%5Bb%5D=true');
        st.equal(qs.stringify(***REMOVED*** b: false ***REMOVED***), 'b=false');
        st.equal(qs.stringify(***REMOVED*** b: ***REMOVED*** c: false ***REMOVED*** ***REMOVED***), 'b%5Bc%5D=false');
        st.end();
    ***REMOVED***);

    t.test('stringifies buffer values', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** a: new Buffer('test') ***REMOVED***), 'a=test');
        st.equal(qs.stringify(***REMOVED*** a: ***REMOVED*** b: new Buffer('test') ***REMOVED*** ***REMOVED***), 'a%5Bb%5D=test');
        st.end();
    ***REMOVED***);

    t.test('stringifies an object using an alternative delimiter', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** a: 'b', c: 'd' ***REMOVED***, ***REMOVED*** delimiter: ';' ***REMOVED***), 'a=b;c=d');
        st.end();
    ***REMOVED***);

    t.test('doesn\'t blow up when Buffer global is missing', function (st) ***REMOVED***
        var tempBuffer = global.Buffer;
        delete global.Buffer;
        var result = qs.stringify(***REMOVED*** a: 'b', c: 'd' ***REMOVED***);
        global.Buffer = tempBuffer;
        st.equal(result, 'a=b&c=d');
        st.end();
    ***REMOVED***);

    t.test('selects properties when filter=array', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** a: 'b' ***REMOVED***, ***REMOVED*** filter: ['a'] ***REMOVED***), 'a=b');
        st.equal(qs.stringify(***REMOVED*** a: 1 ***REMOVED***, ***REMOVED*** filter: [] ***REMOVED***), '');
        st.equal(qs.stringify(***REMOVED*** a: ***REMOVED*** b: [1, 2, 3, 4], c: 'd' ***REMOVED***, c: 'f' ***REMOVED***, ***REMOVED*** filter: ['a', 'b', 0, 2] ***REMOVED***), 'a%5Bb%5D%5B0%5D=1&a%5Bb%5D%5B2%5D=3');
        st.end();
    ***REMOVED***);

    t.test('supports custom representations when filter=function', function (st) ***REMOVED***
        var calls = 0;
        var obj = ***REMOVED*** a: 'b', c: 'd', e: ***REMOVED*** f: new Date(1257894000000) ***REMOVED*** ***REMOVED***;
        var filterFunc = function (prefix, value) ***REMOVED***
            calls++;
            if (calls === 1) ***REMOVED***
                st.equal(prefix, '', 'prefix is empty');
                st.equal(value, obj);
            ***REMOVED*** else if (prefix === 'c') ***REMOVED***
                return;
            ***REMOVED*** else if (value instanceof Date) ***REMOVED***
                st.equal(prefix, 'e[f]');
                return value.getTime();
            ***REMOVED***
            return value;
        ***REMOVED***;

        st.equal(qs.stringify(obj, ***REMOVED*** filter: filterFunc ***REMOVED***), 'a=b&e%5Bf%5D=1257894000000');
        st.equal(calls, 5);
        st.end();
    ***REMOVED***);

    t.test('can disable uri encoding', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** a: 'b' ***REMOVED***, ***REMOVED*** encode: false ***REMOVED***), 'a=b');
        st.equal(qs.stringify(***REMOVED*** a: ***REMOVED*** b: 'c' ***REMOVED*** ***REMOVED***, ***REMOVED*** encode: false ***REMOVED***), 'a[b]=c');
        st.equal(qs.stringify(***REMOVED*** a: 'b', c: null ***REMOVED***, ***REMOVED*** strictNullHandling: true, encode: false ***REMOVED***), 'a=b&c');
        st.end();
    ***REMOVED***);

    t.test('can sort the keys', function (st) ***REMOVED***
        var sort = function (a, b) ***REMOVED*** return a.localeCompare(b); ***REMOVED***;
        st.equal(qs.stringify(***REMOVED*** a: 'c', z: 'y', b: 'f' ***REMOVED***, ***REMOVED*** sort: sort ***REMOVED***), 'a=c&b=f&z=y');
        st.equal(qs.stringify(***REMOVED*** a: 'c', z: ***REMOVED*** j: 'a', i: 'b' ***REMOVED***, b: 'f' ***REMOVED***, ***REMOVED*** sort: sort ***REMOVED***), 'a=c&b=f&z%5Bi%5D=b&z%5Bj%5D=a');
        st.end();
    ***REMOVED***);

    t.test('can sort the keys at depth 3 or more too', function (st) ***REMOVED***
        var sort = function (a, b) ***REMOVED*** return a.localeCompare(b); ***REMOVED***;
        st.equal(qs.stringify(***REMOVED*** a: 'a', z: ***REMOVED*** zj: ***REMOVED***zjb: 'zjb', zja: 'zja'***REMOVED***, zi: ***REMOVED***zib: 'zib', zia: 'zia'***REMOVED*** ***REMOVED***, b: 'b' ***REMOVED***, ***REMOVED*** sort: sort, encode: false ***REMOVED***), 'a=a&b=b&z[zi][zia]=zia&z[zi][zib]=zib&z[zj][zja]=zja&z[zj][zjb]=zjb');
        st.equal(qs.stringify(***REMOVED*** a: 'a', z: ***REMOVED*** zj: ***REMOVED***zjb: 'zjb', zja: 'zja'***REMOVED***, zi: ***REMOVED***zib: 'zib', zia: 'zia'***REMOVED*** ***REMOVED***, b: 'b' ***REMOVED***, ***REMOVED*** sort: null, encode: false ***REMOVED***), 'a=a&z[zj][zjb]=zjb&z[zj][zja]=zja&z[zi][zib]=zib&z[zi][zia]=zia&b=b');
        st.end();
    ***REMOVED***);

    t.test('can stringify with custom encoding', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** Áúå: 'Â§ßÈò™Â∫ú', '': ''***REMOVED***, ***REMOVED***
            encoder: function (str) ***REMOVED***
                if (str.length === 0) ***REMOVED***
                    return '';
                ***REMOVED***
                var buf = iconv.encode(str, 'shiftjis');
                var result = [];
                for (var i=0; i < buf.length; ++i) ***REMOVED***
                    result.push(buf.readUInt8(i).toString(16));
                ***REMOVED***
                return '%' + result.join('%');
            ***REMOVED***
        ***REMOVED***), '%8c%a7=%91%e5%8d%e3%95%7b&=');
        st.end();
    ***REMOVED***);

    t.test('throws error with wrong encoder', function (st) ***REMOVED***
        st.throws(function () ***REMOVED***
            qs.stringify(***REMOVED******REMOVED***, ***REMOVED***
                encoder: 'string'
            ***REMOVED***);
        ***REMOVED***, new TypeError('Encoder has to be a function.'));
        st.end();
    ***REMOVED***);

    t.test('can use custom encoder for a buffer object', ***REMOVED***
        skip: typeof Buffer === 'undefined'
    ***REMOVED***, function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** a: new Buffer([1]) ***REMOVED***, ***REMOVED***
            encoder: function (buffer) ***REMOVED***
                if (typeof buffer === 'string') ***REMOVED***
                    return buffer;
                ***REMOVED***
                return String.fromCharCode(buffer.readUInt8(0) + 97);
            ***REMOVED***
        ***REMOVED***), 'a=b');
        st.end();
    ***REMOVED***);
***REMOVED***);
