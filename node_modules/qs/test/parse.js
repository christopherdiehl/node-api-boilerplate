'use strict';

var test = require('tape');
var qs = require('../');
var iconv = require('iconv-lite');

test('parse()', function (t) ***REMOVED***
    t.test('parses a simple string', function (st) ***REMOVED***
        st.deepEqual(qs.parse('0=foo'), ***REMOVED*** '0': 'foo' ***REMOVED***);
        st.deepEqual(qs.parse('foo=c++'), ***REMOVED*** foo: 'c  ' ***REMOVED***);
        st.deepEqual(qs.parse('a[>=]=23'), ***REMOVED*** a: ***REMOVED*** '>=': '23' ***REMOVED*** ***REMOVED***);
        st.deepEqual(qs.parse('a[<=>]==23'), ***REMOVED*** a: ***REMOVED*** '<=>': '=23' ***REMOVED*** ***REMOVED***);
        st.deepEqual(qs.parse('a[==]=23'), ***REMOVED*** a: ***REMOVED*** '==': '23' ***REMOVED*** ***REMOVED***);
        st.deepEqual(qs.parse('foo', ***REMOVED*** strictNullHandling: true ***REMOVED***), ***REMOVED*** foo: null ***REMOVED***);
        st.deepEqual(qs.parse('foo'), ***REMOVED*** foo: '' ***REMOVED***);
        st.deepEqual(qs.parse('foo='), ***REMOVED*** foo: '' ***REMOVED***);
        st.deepEqual(qs.parse('foo=bar'), ***REMOVED*** foo: 'bar' ***REMOVED***);
        st.deepEqual(qs.parse(' foo = bar = baz '), ***REMOVED*** ' foo ': ' bar = baz ' ***REMOVED***);
        st.deepEqual(qs.parse('foo=bar=baz'), ***REMOVED*** foo: 'bar=baz' ***REMOVED***);
        st.deepEqual(qs.parse('foo=bar&bar=baz'), ***REMOVED*** foo: 'bar', bar: 'baz' ***REMOVED***);
        st.deepEqual(qs.parse('foo2=bar2&baz2='), ***REMOVED*** foo2: 'bar2', baz2: '' ***REMOVED***);
        st.deepEqual(qs.parse('foo=bar&baz', ***REMOVED*** strictNullHandling: true ***REMOVED***), ***REMOVED*** foo: 'bar', baz: null ***REMOVED***);
        st.deepEqual(qs.parse('foo=bar&baz'), ***REMOVED*** foo: 'bar', baz: '' ***REMOVED***);
        st.deepEqual(qs.parse('cht=p3&chd=t:60,40&chs=250x100&chl=Hello|World'), ***REMOVED***
            cht: 'p3',
            chd: 't:60,40',
            chs: '250x100',
            chl: 'Hello|World'
        ***REMOVED***);
        st.end();
    ***REMOVED***);

    t.test('allows enabling dot notation', function (st) ***REMOVED***
        st.deepEqual(qs.parse('a.b=c'), ***REMOVED*** 'a.b': 'c' ***REMOVED***);
        st.deepEqual(qs.parse('a.b=c', ***REMOVED*** allowDots: true ***REMOVED***), ***REMOVED*** a: ***REMOVED*** b: 'c' ***REMOVED*** ***REMOVED***);
        st.end();
    ***REMOVED***);

    t.deepEqual(qs.parse('a[b]=c'), ***REMOVED*** a: ***REMOVED*** b: 'c' ***REMOVED*** ***REMOVED***, 'parses a single nested string');
    t.deepEqual(qs.parse('a[b][c]=d'), ***REMOVED*** a: ***REMOVED*** b: ***REMOVED*** c: 'd' ***REMOVED*** ***REMOVED*** ***REMOVED***, 'parses a double nested string');
    t.deepEqual(
        qs.parse('a[b][c][d][e][f][g][h]=i'),
        ***REMOVED*** a: ***REMOVED*** b: ***REMOVED*** c: ***REMOVED*** d: ***REMOVED*** e: ***REMOVED*** f: ***REMOVED*** '[g][h]': 'i' ***REMOVED*** ***REMOVED*** ***REMOVED*** ***REMOVED*** ***REMOVED*** ***REMOVED*** ***REMOVED***,
        'defaults to a depth of 5'
    );

    t.test('only parses one level when depth = 1', function (st) ***REMOVED***
        st.deepEqual(qs.parse('a[b][c]=d', ***REMOVED*** depth: 1 ***REMOVED***), ***REMOVED*** a: ***REMOVED*** b: ***REMOVED*** '[c]': 'd' ***REMOVED*** ***REMOVED*** ***REMOVED***);
        st.deepEqual(qs.parse('a[b][c][d]=e', ***REMOVED*** depth: 1 ***REMOVED***), ***REMOVED*** a: ***REMOVED*** b: ***REMOVED*** '[c][d]': 'e' ***REMOVED*** ***REMOVED*** ***REMOVED***);
        st.end();
    ***REMOVED***);

    t.deepEqual(qs.parse('a=b&a=c'), ***REMOVED*** a: ['b', 'c'] ***REMOVED***, 'parses a simple array');

    t.test('parses an explicit array', function (st) ***REMOVED***
        st.deepEqual(qs.parse('a[]=b'), ***REMOVED*** a: ['b'] ***REMOVED***);
        st.deepEqual(qs.parse('a[]=b&a[]=c'), ***REMOVED*** a: ['b', 'c'] ***REMOVED***);
        st.deepEqual(qs.parse('a[]=b&a[]=c&a[]=d'), ***REMOVED*** a: ['b', 'c', 'd'] ***REMOVED***);
        st.end();
    ***REMOVED***);

    t.test('parses a mix of simple and explicit arrays', function (st) ***REMOVED***
        st.deepEqual(qs.parse('a=b&a[]=c'), ***REMOVED*** a: ['b', 'c'] ***REMOVED***);
        st.deepEqual(qs.parse('a[]=b&a=c'), ***REMOVED*** a: ['b', 'c'] ***REMOVED***);
        st.deepEqual(qs.parse('a[0]=b&a=c'), ***REMOVED*** a: ['b', 'c'] ***REMOVED***);
        st.deepEqual(qs.parse('a=b&a[0]=c'), ***REMOVED*** a: ['b', 'c'] ***REMOVED***);
        st.deepEqual(qs.parse('a[1]=b&a=c'), ***REMOVED*** a: ['b', 'c'] ***REMOVED***);
        st.deepEqual(qs.parse('a=b&a[1]=c'), ***REMOVED*** a: ['b', 'c'] ***REMOVED***);
        st.end();
    ***REMOVED***);

    t.test('parses a nested array', function (st) ***REMOVED***
        st.deepEqual(qs.parse('a[b][]=c&a[b][]=d'), ***REMOVED*** a: ***REMOVED*** b: ['c', 'd'] ***REMOVED*** ***REMOVED***);
        st.deepEqual(qs.parse('a[>=]=25'), ***REMOVED*** a: ***REMOVED*** '>=': '25' ***REMOVED*** ***REMOVED***);
        st.end();
    ***REMOVED***);

    t.test('allows to specify array indices', function (st) ***REMOVED***
        st.deepEqual(qs.parse('a[1]=c&a[0]=b&a[2]=d'), ***REMOVED*** a: ['b', 'c', 'd'] ***REMOVED***);
        st.deepEqual(qs.parse('a[1]=c&a[0]=b'), ***REMOVED*** a: ['b', 'c'] ***REMOVED***);
        st.deepEqual(qs.parse('a[1]=c'), ***REMOVED*** a: ['c'] ***REMOVED***);
        st.end();
    ***REMOVED***);

    t.test('limits specific array indices to 20', function (st) ***REMOVED***
        st.deepEqual(qs.parse('a[20]=a'), ***REMOVED*** a: ['a'] ***REMOVED***);
        st.deepEqual(qs.parse('a[21]=a'), ***REMOVED*** a: ***REMOVED*** '21': 'a' ***REMOVED*** ***REMOVED***);
        st.end();
    ***REMOVED***);

    t.deepEqual(qs.parse('a[12b]=c'), ***REMOVED*** a: ***REMOVED*** '12b': 'c' ***REMOVED*** ***REMOVED***, 'supports keys that begin with a number');

    t.test('supports encoded = signs', function (st) ***REMOVED***
        st.deepEqual(qs.parse('he%3Dllo=th%3Dere'), ***REMOVED*** 'he=llo': 'th=ere' ***REMOVED***);
        st.end();
    ***REMOVED***);

    t.test('is ok with url encoded strings', function (st) ***REMOVED***
        st.deepEqual(qs.parse('a[b%20c]=d'), ***REMOVED*** a: ***REMOVED*** 'b c': 'd' ***REMOVED*** ***REMOVED***);
        st.deepEqual(qs.parse('a[b]=c%20d'), ***REMOVED*** a: ***REMOVED*** b: 'c d' ***REMOVED*** ***REMOVED***);
        st.end();
    ***REMOVED***);

    t.test('allows brackets in the value', function (st) ***REMOVED***
        st.deepEqual(qs.parse('pets=["tobi"]'), ***REMOVED*** pets: '["tobi"]' ***REMOVED***);
        st.deepEqual(qs.parse('operators=[">=", "<="]'), ***REMOVED*** operators: '[">=", "<="]' ***REMOVED***);
        st.end();
    ***REMOVED***);

    t.test('allows empty values', function (st) ***REMOVED***
        st.deepEqual(qs.parse(''), ***REMOVED******REMOVED***);
        st.deepEqual(qs.parse(null), ***REMOVED******REMOVED***);
        st.deepEqual(qs.parse(undefined), ***REMOVED******REMOVED***);
        st.end();
    ***REMOVED***);

    t.test('transforms arrays to objects', function (st) ***REMOVED***
        st.deepEqual(qs.parse('foo[0]=bar&foo[bad]=baz'), ***REMOVED*** foo: ***REMOVED*** '0': 'bar', bad: 'baz' ***REMOVED*** ***REMOVED***);
        st.deepEqual(qs.parse('foo[bad]=baz&foo[0]=bar'), ***REMOVED*** foo: ***REMOVED*** bad: 'baz', '0': 'bar' ***REMOVED*** ***REMOVED***);
        st.deepEqual(qs.parse('foo[bad]=baz&foo[]=bar'), ***REMOVED*** foo: ***REMOVED*** bad: 'baz', '0': 'bar' ***REMOVED*** ***REMOVED***);
        st.deepEqual(qs.parse('foo[]=bar&foo[bad]=baz'), ***REMOVED*** foo: ***REMOVED*** '0': 'bar', bad: 'baz' ***REMOVED*** ***REMOVED***);
        st.deepEqual(qs.parse('foo[bad]=baz&foo[]=bar&foo[]=foo'), ***REMOVED*** foo: ***REMOVED*** bad: 'baz', '0': 'bar', '1': 'foo' ***REMOVED*** ***REMOVED***);
        st.deepEqual(qs.parse('foo[0][a]=a&foo[0][b]=b&foo[1][a]=aa&foo[1][b]=bb'), ***REMOVED*** foo: [***REMOVED*** a: 'a', b: 'b' ***REMOVED***, ***REMOVED*** a: 'aa', b: 'bb' ***REMOVED***] ***REMOVED***);
        st.deepEqual(qs.parse('a[]=b&a[t]=u&a[hasOwnProperty]=c'), ***REMOVED*** a: ***REMOVED*** '0': 'b', t: 'u', c: true ***REMOVED*** ***REMOVED***);
        st.deepEqual(qs.parse('a[]=b&a[hasOwnProperty]=c&a[x]=y'), ***REMOVED*** a: ***REMOVED*** '0': 'b', '1': 'c', x: 'y' ***REMOVED*** ***REMOVED***);
        st.end();
    ***REMOVED***);

    t.test('transforms arrays to objects (dot notation)', function (st) ***REMOVED***
        st.deepEqual(qs.parse('foo[0].baz=bar&fool.bad=baz', ***REMOVED*** allowDots: true ***REMOVED***), ***REMOVED*** foo: [***REMOVED*** baz: 'bar' ***REMOVED***], fool: ***REMOVED*** bad: 'baz' ***REMOVED*** ***REMOVED***);
        st.deepEqual(qs.parse('foo[0].baz=bar&fool.bad.boo=baz', ***REMOVED*** allowDots: true ***REMOVED***), ***REMOVED*** foo: [***REMOVED*** baz: 'bar' ***REMOVED***], fool: ***REMOVED*** bad: ***REMOVED*** boo: 'baz' ***REMOVED*** ***REMOVED*** ***REMOVED***);
        st.deepEqual(qs.parse('foo[0][0].baz=bar&fool.bad=baz', ***REMOVED*** allowDots: true ***REMOVED***), ***REMOVED*** foo: [[***REMOVED*** baz: 'bar' ***REMOVED***]], fool: ***REMOVED*** bad: 'baz' ***REMOVED*** ***REMOVED***);
        st.deepEqual(qs.parse('foo[0].baz[0]=15&foo[0].bar=2', ***REMOVED*** allowDots: true ***REMOVED***), ***REMOVED*** foo: [***REMOVED*** baz: ['15'], bar: '2' ***REMOVED***] ***REMOVED***);
        st.deepEqual(qs.parse('foo[0].baz[0]=15&foo[0].baz[1]=16&foo[0].bar=2', ***REMOVED*** allowDots: true ***REMOVED***), ***REMOVED*** foo: [***REMOVED*** baz: ['15', '16'], bar: '2' ***REMOVED***] ***REMOVED***);
        st.deepEqual(qs.parse('foo.bad=baz&foo[0]=bar', ***REMOVED*** allowDots: true ***REMOVED***), ***REMOVED*** foo: ***REMOVED*** bad: 'baz', '0': 'bar' ***REMOVED*** ***REMOVED***);
        st.deepEqual(qs.parse('foo.bad=baz&foo[]=bar', ***REMOVED*** allowDots: true ***REMOVED***), ***REMOVED*** foo: ***REMOVED*** bad: 'baz', '0': 'bar' ***REMOVED*** ***REMOVED***);
        st.deepEqual(qs.parse('foo[]=bar&foo.bad=baz', ***REMOVED*** allowDots: true ***REMOVED***), ***REMOVED*** foo: ***REMOVED*** '0': 'bar', bad: 'baz' ***REMOVED*** ***REMOVED***);
        st.deepEqual(qs.parse('foo.bad=baz&foo[]=bar&foo[]=foo', ***REMOVED*** allowDots: true ***REMOVED***), ***REMOVED*** foo: ***REMOVED*** bad: 'baz', '0': 'bar', '1': 'foo' ***REMOVED*** ***REMOVED***);
        st.deepEqual(qs.parse('foo[0].a=a&foo[0].b=b&foo[1].a=aa&foo[1].b=bb', ***REMOVED*** allowDots: true ***REMOVED***), ***REMOVED*** foo: [***REMOVED*** a: 'a', b: 'b' ***REMOVED***, ***REMOVED*** a: 'aa', b: 'bb' ***REMOVED***] ***REMOVED***);
        st.end();
    ***REMOVED***);

    t.deepEqual(qs.parse('a[b]=c&a=d'), ***REMOVED*** a: ***REMOVED*** b: 'c', d: true ***REMOVED*** ***REMOVED***, 'can add keys to objects');

    t.test('correctly prunes undefined values when converting an array to an object', function (st) ***REMOVED***
        st.deepEqual(qs.parse('a[2]=b&a[99999999]=c'), ***REMOVED*** a: ***REMOVED*** '2': 'b', '99999999': 'c' ***REMOVED*** ***REMOVED***);
        st.end();
    ***REMOVED***);

    t.test('supports malformed uri characters', function (st) ***REMOVED***
        st.deepEqual(qs.parse('***REMOVED***%:%***REMOVED***', ***REMOVED*** strictNullHandling: true ***REMOVED***), ***REMOVED*** '***REMOVED***%:%***REMOVED***': null ***REMOVED***);
        st.deepEqual(qs.parse('***REMOVED***%:%***REMOVED***='), ***REMOVED*** '***REMOVED***%:%***REMOVED***': '' ***REMOVED***);
        st.deepEqual(qs.parse('foo=%:%***REMOVED***'), ***REMOVED*** foo: '%:%***REMOVED***' ***REMOVED***);
        st.end();
    ***REMOVED***);

    t.test('doesn\'t produce empty keys', function (st) ***REMOVED***
        st.deepEqual(qs.parse('_r=1&'), ***REMOVED*** '_r': '1' ***REMOVED***);
        st.end();
    ***REMOVED***);

    t.test('cannot access Object prototype', function (st) ***REMOVED***
        qs.parse('constructor[prototype][bad]=bad');
        qs.parse('bad[constructor][prototype][bad]=bad');
        st.equal(typeof Object.prototype.bad, 'undefined');
        st.end();
    ***REMOVED***);

    t.test('parses arrays of objects', function (st) ***REMOVED***
        st.deepEqual(qs.parse('a[][b]=c'), ***REMOVED*** a: [***REMOVED*** b: 'c' ***REMOVED***] ***REMOVED***);
        st.deepEqual(qs.parse('a[0][b]=c'), ***REMOVED*** a: [***REMOVED*** b: 'c' ***REMOVED***] ***REMOVED***);
        st.end();
    ***REMOVED***);

    t.test('allows for empty strings in arrays', function (st) ***REMOVED***
        st.deepEqual(qs.parse('a[]=b&a[]=&a[]=c'), ***REMOVED*** a: ['b', '', 'c'] ***REMOVED***);
        st.deepEqual(qs.parse('a[0]=b&a[1]&a[2]=c&a[19]=', ***REMOVED*** strictNullHandling: true ***REMOVED***), ***REMOVED*** a: ['b', null, 'c', ''] ***REMOVED***);
        st.deepEqual(qs.parse('a[0]=b&a[1]=&a[2]=c&a[19]', ***REMOVED*** strictNullHandling: true ***REMOVED***), ***REMOVED*** a: ['b', '', 'c', null] ***REMOVED***);
        st.deepEqual(qs.parse('a[]=&a[]=b&a[]=c'), ***REMOVED*** a: ['', 'b', 'c'] ***REMOVED***);
        st.end();
    ***REMOVED***);

    t.test('compacts sparse arrays', function (st) ***REMOVED***
        st.deepEqual(qs.parse('a[10]=1&a[2]=2'), ***REMOVED*** a: ['2', '1'] ***REMOVED***);
        st.deepEqual(qs.parse('a[1][b][2][c]=1'), ***REMOVED*** a: [***REMOVED*** b: [***REMOVED*** c: '1' ***REMOVED***] ***REMOVED***] ***REMOVED***);
        st.deepEqual(qs.parse('a[1][2][3][c]=1'), ***REMOVED*** a: [[[***REMOVED*** c: '1' ***REMOVED***]]] ***REMOVED***);
        st.deepEqual(qs.parse('a[1][2][3][c][1]=1'), ***REMOVED*** a: [[[***REMOVED*** c: ['1'] ***REMOVED***]]] ***REMOVED***);
        st.end();
    ***REMOVED***);

    t.test('parses semi-parsed strings', function (st) ***REMOVED***
        st.deepEqual(qs.parse(***REMOVED*** 'a[b]': 'c' ***REMOVED***), ***REMOVED*** a: ***REMOVED*** b: 'c' ***REMOVED*** ***REMOVED***);
        st.deepEqual(qs.parse(***REMOVED*** 'a[b]': 'c', 'a[d]': 'e' ***REMOVED***), ***REMOVED*** a: ***REMOVED*** b: 'c', d: 'e' ***REMOVED*** ***REMOVED***);
        st.end();
    ***REMOVED***);

    t.test('parses buffers correctly', function (st) ***REMOVED***
        var b = new Buffer('test');
        st.deepEqual(qs.parse(***REMOVED*** a: b ***REMOVED***), ***REMOVED*** a: b ***REMOVED***);
        st.end();
    ***REMOVED***);

    t.test('continues parsing when no parent is found', function (st) ***REMOVED***
        st.deepEqual(qs.parse('[]=&a=b'), ***REMOVED*** '0': '', a: 'b' ***REMOVED***);
        st.deepEqual(qs.parse('[]&a=b', ***REMOVED*** strictNullHandling: true ***REMOVED***), ***REMOVED*** '0': null, a: 'b' ***REMOVED***);
        st.deepEqual(qs.parse('[foo]=bar'), ***REMOVED*** foo: 'bar' ***REMOVED***);
        st.end();
    ***REMOVED***);

    t.test('does not error when parsing a very long array', function (st) ***REMOVED***
        var str = 'a[]=a';
        while (Buffer.byteLength(str) < 128 * 1024) ***REMOVED***
            str = str + '&' + str;
        ***REMOVED***

        st.doesNotThrow(function () ***REMOVED*** qs.parse(str); ***REMOVED***);

        st.end();
    ***REMOVED***);

    t.test('should not throw when a native prototype has an enumerable property', ***REMOVED*** parallel: false ***REMOVED***, function (st) ***REMOVED***
        Object.prototype.crash = '';
        Array.prototype.crash = '';
        st.doesNotThrow(qs.parse.bind(null, 'a=b'));
        st.deepEqual(qs.parse('a=b'), ***REMOVED*** a: 'b' ***REMOVED***);
        st.doesNotThrow(qs.parse.bind(null, 'a[][b]=c'));
        st.deepEqual(qs.parse('a[][b]=c'), ***REMOVED*** a: [***REMOVED*** b: 'c' ***REMOVED***] ***REMOVED***);
        delete Object.prototype.crash;
        delete Array.prototype.crash;
        st.end();
    ***REMOVED***);

    t.test('parses a string with an alternative string delimiter', function (st) ***REMOVED***
        st.deepEqual(qs.parse('a=b;c=d', ***REMOVED*** delimiter: ';' ***REMOVED***), ***REMOVED*** a: 'b', c: 'd' ***REMOVED***);
        st.end();
    ***REMOVED***);

    t.test('parses a string with an alternative RegExp delimiter', function (st) ***REMOVED***
        st.deepEqual(qs.parse('a=b; c=d', ***REMOVED*** delimiter: /[;,] */ ***REMOVED***), ***REMOVED*** a: 'b', c: 'd' ***REMOVED***);
        st.end();
    ***REMOVED***);

    t.test('does not use non-splittable objects as delimiters', function (st) ***REMOVED***
        st.deepEqual(qs.parse('a=b&c=d', ***REMOVED*** delimiter: true ***REMOVED***), ***REMOVED*** a: 'b', c: 'd' ***REMOVED***);
        st.end();
    ***REMOVED***);

    t.test('allows overriding parameter limit', function (st) ***REMOVED***
        st.deepEqual(qs.parse('a=b&c=d', ***REMOVED*** parameterLimit: 1 ***REMOVED***), ***REMOVED*** a: 'b' ***REMOVED***);
        st.end();
    ***REMOVED***);

    t.test('allows setting the parameter limit to Infinity', function (st) ***REMOVED***
        st.deepEqual(qs.parse('a=b&c=d', ***REMOVED*** parameterLimit: Infinity ***REMOVED***), ***REMOVED*** a: 'b', c: 'd' ***REMOVED***);
        st.end();
    ***REMOVED***);

    t.test('allows overriding array limit', function (st) ***REMOVED***
        st.deepEqual(qs.parse('a[0]=b', ***REMOVED*** arrayLimit: -1 ***REMOVED***), ***REMOVED*** a: ***REMOVED*** '0': 'b' ***REMOVED*** ***REMOVED***);
        st.deepEqual(qs.parse('a[-1]=b', ***REMOVED*** arrayLimit: -1 ***REMOVED***), ***REMOVED*** a: ***REMOVED*** '-1': 'b' ***REMOVED*** ***REMOVED***);
        st.deepEqual(qs.parse('a[0]=b&a[1]=c', ***REMOVED*** arrayLimit: 0 ***REMOVED***), ***REMOVED*** a: ***REMOVED*** '0': 'b', '1': 'c' ***REMOVED*** ***REMOVED***);
        st.end();
    ***REMOVED***);

    t.test('allows disabling array parsing', function (st) ***REMOVED***
        st.deepEqual(qs.parse('a[0]=b&a[1]=c', ***REMOVED*** parseArrays: false ***REMOVED***), ***REMOVED*** a: ***REMOVED*** '0': 'b', '1': 'c' ***REMOVED*** ***REMOVED***);
        st.end();
    ***REMOVED***);

    t.test('parses an object', function (st) ***REMOVED***
        var input = ***REMOVED***
            'user[name]': ***REMOVED*** 'pop[bob]': 3 ***REMOVED***,
            'user[email]': null
        ***REMOVED***;

        var expected = ***REMOVED***
            user: ***REMOVED***
                name: ***REMOVED*** 'pop[bob]': 3 ***REMOVED***,
                email: null
            ***REMOVED***
        ***REMOVED***;

        var result = qs.parse(input);

        st.deepEqual(result, expected);
        st.end();
    ***REMOVED***);

    t.test('parses an object in dot notation', function (st) ***REMOVED***
        var input = ***REMOVED***
            'user.name': ***REMOVED*** 'pop[bob]': 3 ***REMOVED***,
            'user.email.': null
        ***REMOVED***;

        var expected = ***REMOVED***
            user: ***REMOVED***
                name: ***REMOVED*** 'pop[bob]': 3 ***REMOVED***,
                email: null
            ***REMOVED***
        ***REMOVED***;

        var result = qs.parse(input, ***REMOVED*** allowDots: true ***REMOVED***);

        st.deepEqual(result, expected);
        st.end();
    ***REMOVED***);

    t.test('parses an object and not child values', function (st) ***REMOVED***
        var input = ***REMOVED***
            'user[name]': ***REMOVED*** 'pop[bob]': ***REMOVED*** 'test': 3 ***REMOVED*** ***REMOVED***,
            'user[email]': null
        ***REMOVED***;

        var expected = ***REMOVED***
            user: ***REMOVED***
                name: ***REMOVED*** 'pop[bob]': ***REMOVED*** 'test': 3 ***REMOVED*** ***REMOVED***,
                email: null
            ***REMOVED***
        ***REMOVED***;

        var result = qs.parse(input);

        st.deepEqual(result, expected);
        st.end();
    ***REMOVED***);

    t.test('does not blow up when Buffer global is missing', function (st) ***REMOVED***
        var tempBuffer = global.Buffer;
        delete global.Buffer;
        var result = qs.parse('a=b&c=d');
        global.Buffer = tempBuffer;
        st.deepEqual(result, ***REMOVED*** a: 'b', c: 'd' ***REMOVED***);
        st.end();
    ***REMOVED***);

    t.test('does not crash when parsing circular references', function (st) ***REMOVED***
        var a = ***REMOVED******REMOVED***;
        a.b = a;

        var parsed;

        st.doesNotThrow(function () ***REMOVED***
            parsed = qs.parse(***REMOVED*** 'foo[bar]': 'baz', 'foo[baz]': a ***REMOVED***);
        ***REMOVED***);

        st.equal('foo' in parsed, true, 'parsed has "foo" property');
        st.equal('bar' in parsed.foo, true);
        st.equal('baz' in parsed.foo, true);
        st.equal(parsed.foo.bar, 'baz');
        st.deepEqual(parsed.foo.baz, a);
        st.end();
    ***REMOVED***);

    t.test('parses plain objects correctly', function (st) ***REMOVED***
        var a = Object.create(null);
        a.b = 'c';

        st.deepEqual(qs.parse(a), ***REMOVED*** b: 'c' ***REMOVED***);
        var result = qs.parse(***REMOVED*** a: a ***REMOVED***);
        st.equal('a' in result, true, 'result has "a" property');
        st.deepEqual(result.a, a);
        st.end();
    ***REMOVED***);

    t.test('parses dates correctly', function (st) ***REMOVED***
        var now = new Date();
        st.deepEqual(qs.parse(***REMOVED*** a: now ***REMOVED***), ***REMOVED*** a: now ***REMOVED***);
        st.end();
    ***REMOVED***);

    t.test('parses regular expressions correctly', function (st) ***REMOVED***
        var re = /^test$/;
        st.deepEqual(qs.parse(***REMOVED*** a: re ***REMOVED***), ***REMOVED*** a: re ***REMOVED***);
        st.end();
    ***REMOVED***);

    t.test('can allow overwriting prototype properties', function (st) ***REMOVED***
        st.deepEqual(qs.parse('a[hasOwnProperty]=b', ***REMOVED*** allowPrototypes: true ***REMOVED***), ***REMOVED*** a: ***REMOVED*** hasOwnProperty: 'b' ***REMOVED*** ***REMOVED***, ***REMOVED*** prototype: false ***REMOVED***);
        st.deepEqual(qs.parse('hasOwnProperty=b', ***REMOVED*** allowPrototypes: true ***REMOVED***), ***REMOVED*** hasOwnProperty: 'b' ***REMOVED***, ***REMOVED*** prototype: false ***REMOVED***);
        st.end();
    ***REMOVED***);

    t.test('can return plain objects', function (st) ***REMOVED***
        var expected = Object.create(null);
        expected.a = Object.create(null);
        expected.a.b = 'c';
        expected.a.hasOwnProperty = 'd';
        st.deepEqual(qs.parse('a[b]=c&a[hasOwnProperty]=d', ***REMOVED*** plainObjects: true ***REMOVED***), expected);
        st.deepEqual(qs.parse(null, ***REMOVED*** plainObjects: true ***REMOVED***), Object.create(null));
        var expectedArray = Object.create(null);
        expectedArray.a = Object.create(null);
        expectedArray.a['0'] = 'b';
        expectedArray.a.c = 'd';
        st.deepEqual(qs.parse('a[]=b&a[c]=d', ***REMOVED*** plainObjects: true ***REMOVED***), expectedArray);
        st.end();
    ***REMOVED***);

    t.test('can parse with custom encoding', function (st) ***REMOVED***
        st.deepEqual(qs.parse('%8c%a7=%91%e5%8d%e3%95%7b', ***REMOVED***
            decoder: function (str) ***REMOVED***
                var reg = /\%([0-9A-F]***REMOVED***2***REMOVED***)/ig;
                var result = [];
                var parts;
                var last = 0;
                while (parts = reg.exec(str)) ***REMOVED***
                    result.push(parseInt(parts[1], 16));
                    last = parts.index + parts[0].length;
                ***REMOVED***
                return iconv.decode(new Buffer(result), 'shift_jis').toString();
            ***REMOVED***
        ***REMOVED***), ***REMOVED*** 県: '大阪府' ***REMOVED***);
        st.end();
    ***REMOVED***);

    t.test('throws error with wrong decoder', function (st) ***REMOVED***
        st.throws(function () ***REMOVED***
            qs.parse(***REMOVED******REMOVED***, ***REMOVED***
                decoder: 'string'
            ***REMOVED***);
        ***REMOVED***, new TypeError('Decoder has to be a function.'));
        st.end();
    ***REMOVED***);
***REMOVED***);
