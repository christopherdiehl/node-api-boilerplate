/*!
 * proxy-addr
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */

'use strict'

/**
 * Module exports.
 */

module.exports = proxyaddr;
module.exports.all = alladdrs;
module.exports.compile = compile;

/**
 * Module dependencies.
 */

var forwarded = require('forwarded');
var ipaddr = require('ipaddr.js');

/**
 * Variables.
 */

var digitre = /^[0-9]+$/;
var isip = ipaddr.isValid;
var parseip = ipaddr.parse;

/**
 * Pre-defined IP ranges.
 */

var ipranges = ***REMOVED***
  linklocal: ['169.254.0.0/16', 'fe80::/10'],
  loopback: ['127.0.0.1/8', '::1/128'],
  uniquelocal: ['10.0.0.0/8', '172.16.0.0/12', '192.168.0.0/16', 'fc00::/7']
***REMOVED***;

/**
 * Get all addresses in the request, optionally stopping
 * at the first untrusted.
 *
 * @param ***REMOVED***Object***REMOVED*** request
 * @param ***REMOVED***Function|Array|String***REMOVED*** [trust]
 * @api public
 */

function alladdrs(req, trust) ***REMOVED***
  // get addresses
  var addrs = forwarded(req);

  if (!trust) ***REMOVED***
    // Return all addresses
    return addrs;
  ***REMOVED***

  if (typeof trust !== 'function') ***REMOVED***
    trust = compile(trust);
  ***REMOVED***

  for (var i = 0; i < addrs.length - 1; i++) ***REMOVED***
    if (trust(addrs[i], i)) continue;

    addrs.length = i + 1;
  ***REMOVED***

  return addrs;
***REMOVED***

/**
 * Compile argument into trust function.
 *
 * @param ***REMOVED***Array|String***REMOVED*** val
 * @api private
 */

function compile(val) ***REMOVED***
  if (!val) ***REMOVED***
    throw new TypeError('argument is required');
  ***REMOVED***

  var trust = typeof val === 'string'
    ? [val]
    : val;

  if (!Array.isArray(trust)) ***REMOVED***
    throw new TypeError('unsupported trust argument');
  ***REMOVED***

  for (var i = 0; i < trust.length; i++) ***REMOVED***
    val = trust[i];

    if (!ipranges.hasOwnProperty(val)) ***REMOVED***
      continue;
    ***REMOVED***

    // Splice in pre-defined range
    val = ipranges[val];
    trust.splice.apply(trust, [i, 1].concat(val));
    i += val.length - 1;
  ***REMOVED***

  return compileTrust(compileRangeSubnets(trust));
***REMOVED***

/**
 * Compile `arr` elements into range subnets.
 *
 * @param ***REMOVED***Array***REMOVED*** arr
 * @api private
 */

function compileRangeSubnets(arr) ***REMOVED***
  var rangeSubnets = new Array(arr.length);

  for (var i = 0; i < arr.length; i++) ***REMOVED***
    rangeSubnets[i] = parseipNotation(arr[i]);
  ***REMOVED***

  return rangeSubnets;
***REMOVED***

/**
 * Compile range subnet array into trust function.
 *
 * @param ***REMOVED***Array***REMOVED*** rangeSubnets
 * @api private
 */

function compileTrust(rangeSubnets) ***REMOVED***
  // Return optimized function based on length
  var len = rangeSubnets.length;
  return len === 0
    ? trustNone
    : len === 1
    ? trustSingle(rangeSubnets[0])
    : trustMulti(rangeSubnets);
***REMOVED***

/**
 * Parse IP notation string into range subnet.
 *
 * @param ***REMOVED***String***REMOVED*** note
 * @api private
 */

function parseipNotation(note) ***REMOVED***
  var pos = note.lastIndexOf('/');
  var str = pos !== -1
    ? note.substring(0, pos)
    : note;

  if (!isip(str)) ***REMOVED***
    throw new TypeError('invalid IP address: ' + str);
  ***REMOVED***

  var ip = parseip(str);

  if (pos === -1 && ip.kind() === 'ipv6' && ip.isIPv4MappedAddress()) ***REMOVED***
    // Store as IPv4
    ip = ip.toIPv4Address();
  ***REMOVED***

  var max = ip.kind() === 'ipv6'
    ? 128
    : 32;

  var range = pos !== -1
    ? note.substring(pos + 1, note.length)
    : null;

  if (range === null) ***REMOVED***
    range = max;
  ***REMOVED*** else if (digitre.test(range)) ***REMOVED***
    range = parseInt(range, 10);
  ***REMOVED*** else if (ip.kind() === 'ipv4' && isip(range)) ***REMOVED***
    range = parseNetmask(range);
  ***REMOVED*** else ***REMOVED***
    range = null;
  ***REMOVED***

  if (range <= 0 || range > max) ***REMOVED***
    throw new TypeError('invalid range on address: ' + note);
  ***REMOVED***

  return [ip, range];
***REMOVED***

/**
 * Parse netmask string into CIDR range.
 *
 * @param ***REMOVED***String***REMOVED*** netmask
 * @api private
 */

function parseNetmask(netmask) ***REMOVED***
  var ip = parseip(netmask);
  var kind = ip.kind();

  return kind === 'ipv4'
    ? ip.prefixLengthFromSubnetMask()
    : null;
***REMOVED***

/**
 * Determine address of proxied request.
 *
 * @param ***REMOVED***Object***REMOVED*** request
 * @param ***REMOVED***Function|Array|String***REMOVED*** trust
 * @api public
 */

function proxyaddr(req, trust) ***REMOVED***
  if (!req) ***REMOVED***
    throw new TypeError('req argument is required');
  ***REMOVED***

  if (!trust) ***REMOVED***
    throw new TypeError('trust argument is required');
  ***REMOVED***

  var addrs = alladdrs(req, trust);
  var addr = addrs[addrs.length - 1];

  return addr;
***REMOVED***

/**
 * Static trust function to trust nothing.
 *
 * @api private
 */

function trustNone() ***REMOVED***
  return false;
***REMOVED***

/**
 * Compile trust function for multiple subnets.
 *
 * @param ***REMOVED***Array***REMOVED*** subnets
 * @api private
 */

function trustMulti(subnets) ***REMOVED***
  return function trust(addr) ***REMOVED***
    if (!isip(addr)) return false;

    var ip = parseip(addr);
    var ipconv;
    var kind = ip.kind();

    for (var i = 0; i < subnets.length; i++) ***REMOVED***
      var subnet = subnets[i];
      var subnetip = subnet[0];
      var subnetkind = subnetip.kind();
      var subnetrange = subnet[1];
      var trusted = ip;

      if (kind !== subnetkind) ***REMOVED***
        if (subnetkind === 'ipv4' && !ip.isIPv4MappedAddress()) ***REMOVED***
          // Incompatible IP addresses
          continue;
        ***REMOVED***

        if (!ipconv) ***REMOVED***
          // Convert IP to match subnet IP kind
          ipconv = subnetkind === 'ipv4'
            ? ip.toIPv4Address()
            : ip.toIPv4MappedAddress();
        ***REMOVED***

        trusted = ipconv;
      ***REMOVED***

      if (trusted.match(subnetip, subnetrange)) ***REMOVED***
        return true;
      ***REMOVED***
    ***REMOVED***

    return false;
  ***REMOVED***;
***REMOVED***

/**
 * Compile trust function for single subnet.
 *
 * @param ***REMOVED***Object***REMOVED*** subnet
 * @api private
 */

function trustSingle(subnet) ***REMOVED***
  var subnetip = subnet[0];
  var subnetkind = subnetip.kind();
  var subnetisipv4 = subnetkind === 'ipv4';
  var subnetrange = subnet[1];

  return function trust(addr) ***REMOVED***
    if (!isip(addr)) return false;

    var ip = parseip(addr);
    var kind = ip.kind();

    if (kind !== subnetkind) ***REMOVED***
      if (subnetisipv4 && !ip.isIPv4MappedAddress()) ***REMOVED***
        // Incompatible IP addresses
        return false;
      ***REMOVED***

      // Convert IP to match subnet IP kind
      ip = subnetisipv4
        ? ip.toIPv4Address()
        : ip.toIPv4MappedAddress();
    ***REMOVED***

    return ip.match(subnetip, subnetrange);
  ***REMOVED***;
***REMOVED***
