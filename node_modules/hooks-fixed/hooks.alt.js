/**
 * Hooks are useful if we want to add a method that automatically has `pre` and `post` hooks.
 * For example, it would be convenient to have `pre` and `post` hooks for `save`.
 * _.extend(Model, mixins.hooks);
 * Model.hook('save', function () ***REMOVED***
 *  console.log('saving');
 * ***REMOVED***);
 * Model.pre('save', function (next, done) ***REMOVED***
 *  console.log('about to save');
 *  next();
 * ***REMOVED***);
 * Model.post('save', function (next, done) ***REMOVED***
 *  console.log('saved');
 *  next();
 * ***REMOVED***);
 *
 * var m = new Model();
 * m.save();
 * // about to save
 * // saving
 * // saved 
 */

// TODO Add in pre and post skipping options
module.exports = ***REMOVED***
  /**
   *  Declares a new hook to which you can add pres and posts
   *  @param ***REMOVED***String***REMOVED*** name of the function
   *  @param ***REMOVED***Function***REMOVED*** the method
   *  @param ***REMOVED***Function***REMOVED*** the error handler callback
   */
  hook: function (name, fn, err) ***REMOVED***
    if (arguments.length === 1 && typeof name === 'object') ***REMOVED***
      for (var k in name) ***REMOVED*** // `name` is a hash of hookName->hookFn
        this.hook(k, name[k]);
      ***REMOVED***
      return;
    ***REMOVED***

    if (!err) err = fn;

    var proto = this.prototype || this
      , pres = proto._pres = proto._pres || ***REMOVED******REMOVED***
      , posts = proto._posts = proto._posts || ***REMOVED******REMOVED***;
    pres[name] = pres[name] || [];
    posts[name] = posts[name] || [];

    function noop () ***REMOVED******REMOVED***

    proto[name] = function () ***REMOVED***
      var self = this
        , pres = this._pres[name]
        , posts = this._posts[name]
        , numAsyncPres = 0
        , hookArgs = [].slice.call(arguments)
        , preChain = pres.map( function (pre, i) ***REMOVED***
            var wrapper = function () ***REMOVED***
              if (arguments[0] instanceof Error)
                return err(arguments[0]);
              if (numAsyncPres) ***REMOVED***
                // arguments[1] === asyncComplete
                if (arguments.length)
                  hookArgs = [].slice.call(arguments, 2);
                pre.apply(self, 
                  [ preChain[i+1] || allPresInvoked, 
                    asyncComplete
                  ].concat(hookArgs)
                );
              ***REMOVED*** else ***REMOVED***
                if (arguments.length)
                  hookArgs = [].slice.call(arguments);
                pre.apply(self,
                  [ preChain[i+1] || allPresDone ].concat(hookArgs));
              ***REMOVED***
            ***REMOVED***; // end wrapper = function () ***REMOVED***...
            if (wrapper.isAsync = pre.isAsync)
              numAsyncPres++;
            return wrapper;
          ***REMOVED***); // end posts.map(...)
      function allPresInvoked () ***REMOVED***
        if (arguments[0] instanceof Error)
          err(arguments[0]);
      ***REMOVED***

      function allPresDone () ***REMOVED***
        if (arguments[0] instanceof Error)
          return err(arguments[0]);
        if (arguments.length)
          hookArgs = [].slice.call(arguments);
        fn.apply(self, hookArgs);
        var postChain = posts.map( function (post, i) ***REMOVED***
          var wrapper = function () ***REMOVED***
            if (arguments[0] instanceof Error)
              return err(arguments[0]);
            if (arguments.length)
              hookArgs = [].slice.call(arguments);
            post.apply(self,
              [ postChain[i+1] || noop].concat(hookArgs));
          ***REMOVED***; // end wrapper = function () ***REMOVED***...
          return wrapper;
        ***REMOVED***); // end posts.map(...)
        if (postChain.length) postChain[0]();
      ***REMOVED***

      if (numAsyncPres) ***REMOVED***
        complete = numAsyncPres;
        function asyncComplete () ***REMOVED***
          if (arguments[0] instanceof Error)
            return err(arguments[0]);
          --complete || allPresDone.call(this);
        ***REMOVED***
      ***REMOVED***
      (preChain[0] || allPresDone)();
    ***REMOVED***;

    return this;
  ***REMOVED***,

  pre: function (name, fn, isAsync) ***REMOVED***
    var proto = this.prototype
      , pres = proto._pres = proto._pres || ***REMOVED******REMOVED***;
    if (fn.isAsync = isAsync) ***REMOVED***
      this.prototype[name].numAsyncPres++;
    ***REMOVED***
    (pres[name] = pres[name] || []).push(fn);
    return this;
  ***REMOVED***,
  post: function (name, fn, isAsync) ***REMOVED***
    var proto = this.prototype
      , posts = proto._posts = proto._posts || ***REMOVED******REMOVED***;
    (posts[name] = posts[name] || []).push(fn);
    return this;
  ***REMOVED***
***REMOVED***;
