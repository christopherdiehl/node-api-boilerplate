/*!
 * bytes
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015 Jed Watson
 * MIT Licensed
 */

'use strict';

/**
 * Module exports.
 * @public
 */

module.exports = bytes;
module.exports.format = format;
module.exports.parse = parse;

/**
 * Module variables.
 * @private
 */

var formatThousandsRegExp = /\B(?=(\d***REMOVED***3***REMOVED***)+(?!\d))/g;

var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;

var map = ***REMOVED***
  b:  1,
  kb: 1 << 10,
  mb: 1 << 20,
  gb: 1 << 30,
  tb: ((1 << 30) * 1024)
***REMOVED***;

// TODO: use is-finite module?
var numberIsFinite = Number.isFinite || function (v) ***REMOVED*** return typeof v === 'number' && isFinite(v); ***REMOVED***;

var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb)$/i;

/**
 * Convert the given value in bytes into a string or parse to string to an integer in bytes.
 *
 * @param ***REMOVED***string|number***REMOVED*** value
 * @param ***REMOVED******REMOVED***
 *  case: [string],
 *  decimalPlaces: [number]
 *  fixedDecimals: [boolean]
 *  thousandsSeparator: [string]
 *  unitSeparator: [string]
 *  ***REMOVED******REMOVED*** [options] bytes options.
 *
 * @returns ***REMOVED***string|number|null***REMOVED***
 */

function bytes(value, options) ***REMOVED***
  if (typeof value === 'string') ***REMOVED***
    return parse(value);
  ***REMOVED***

  if (typeof value === 'number') ***REMOVED***
    return format(value, options);
  ***REMOVED***

  return null;
***REMOVED***

/**
 * Format the given value in bytes into a string.
 *
 * If the value is negative, it is kept as such. If it is a float,
 * it is rounded.
 *
 * @param ***REMOVED***number***REMOVED*** value
 * @param ***REMOVED***object***REMOVED*** [options]
 * @param ***REMOVED***number***REMOVED*** [options.decimalPlaces=2]
 * @param ***REMOVED***number***REMOVED*** [options.fixedDecimals=false]
 * @param ***REMOVED***string***REMOVED*** [options.thousandsSeparator=]
 * @param ***REMOVED***string***REMOVED*** [options.unitSeparator=]
 *
 * @returns ***REMOVED***string|null***REMOVED***
 * @public
 */

function format(value, options) ***REMOVED***
  if (!numberIsFinite(value)) ***REMOVED***
    return null;
  ***REMOVED***

  var mag = Math.abs(value);
  var thousandsSeparator = (options && options.thousandsSeparator) || '';
  var unitSeparator = (options && options.unitSeparator) || '';
  var decimalPlaces = (options && options.decimalPlaces !== undefined) ? options.decimalPlaces : 2;
  var fixedDecimals = Boolean(options && options.fixedDecimals);
  var unit = 'B';

  if (mag >= map.tb) ***REMOVED***
    unit = 'TB';
  ***REMOVED*** else if (mag >= map.gb) ***REMOVED***
    unit = 'GB';
  ***REMOVED*** else if (mag >= map.mb) ***REMOVED***
    unit = 'MB';
  ***REMOVED*** else if (mag >= map.kb) ***REMOVED***
    unit = 'kB';
  ***REMOVED***

  var val = value / map[unit.toLowerCase()];
  var str = val.toFixed(decimalPlaces);

  if (!fixedDecimals) ***REMOVED***
    str = str.replace(formatDecimalsRegExp, '$1');
  ***REMOVED***

  if (thousandsSeparator) ***REMOVED***
    str = str.replace(formatThousandsRegExp, thousandsSeparator);
  ***REMOVED***

  return str + unitSeparator + unit;
***REMOVED***

/**
 * Parse the string value into an integer in bytes.
 *
 * If no unit is given, it is assumed the value is in bytes.
 *
 * @param ***REMOVED***number|string***REMOVED*** val
 *
 * @returns ***REMOVED***number|null***REMOVED***
 * @public
 */

function parse(val) ***REMOVED***
  if (typeof val === 'number' && !isNaN(val)) ***REMOVED***
    return val;
  ***REMOVED***

  if (typeof val !== 'string') ***REMOVED***
    return null;
  ***REMOVED***

  // Test if the string passed is valid
  var results = parseRegExp.exec(val);
  var floatValue;
  var unit = 'b';

  if (!results) ***REMOVED***
    // Nothing could be extracted from the given string
    floatValue = parseInt(val, 10);
    unit = 'b'
  ***REMOVED*** else ***REMOVED***
    // Retrieve the value and the unit
    floatValue = parseFloat(results[1]);
    unit = results[4].toLowerCase();
  ***REMOVED***

  return Math.floor(map[unit] * floatValue);
***REMOVED***
