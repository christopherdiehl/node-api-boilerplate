'use strict';

Object.defineProperty(exports, "__esModule", ***REMOVED***
    value: true
***REMOVED***);

exports.default = function (tasks, concurrency, callback) ***REMOVED***
    if (typeof concurrency === 'function') ***REMOVED***
        // concurrency is optional, shift the args.
        callback = concurrency;
        concurrency = null;
    ***REMOVED***
    callback = (0, _once2.default)(callback || _noop2.default);
    var keys = (0, _keys2.default)(tasks);
    var numTasks = keys.length;
    if (!numTasks) ***REMOVED***
        return callback(null);
    ***REMOVED***
    if (!concurrency) ***REMOVED***
        concurrency = numTasks;
    ***REMOVED***

    var results = ***REMOVED******REMOVED***;
    var runningTasks = 0;
    var hasError = false;

    var listeners = ***REMOVED******REMOVED***;

    var readyTasks = [];

    // for cycle detection:
    var readyToCheck = []; // tasks that have been identified as reachable
    // without the possibility of returning to an ancestor task
    var uncheckedDependencies = ***REMOVED******REMOVED***;

    (0, _baseForOwn2.default)(tasks, function (task, key) ***REMOVED***
        if (!(0, _isArray2.default)(task)) ***REMOVED***
            // no dependencies
            enqueueTask(key, [task]);
            readyToCheck.push(key);
            return;
        ***REMOVED***

        var dependencies = task.slice(0, task.length - 1);
        var remainingDependencies = dependencies.length;
        if (remainingDependencies === 0) ***REMOVED***
            enqueueTask(key, task);
            readyToCheck.push(key);
            return;
        ***REMOVED***
        uncheckedDependencies[key] = remainingDependencies;

        (0, _arrayEach2.default)(dependencies, function (dependencyName) ***REMOVED***
            if (!tasks[dependencyName]) ***REMOVED***
                throw new Error('async.auto task `' + key + '` has a non-existent dependency in ' + dependencies.join(', '));
            ***REMOVED***
            addListener(dependencyName, function () ***REMOVED***
                remainingDependencies--;
                if (remainingDependencies === 0) ***REMOVED***
                    enqueueTask(key, task);
                ***REMOVED***
            ***REMOVED***);
        ***REMOVED***);
    ***REMOVED***);

    checkForDeadlocks();
    processQueue();

    function enqueueTask(key, task) ***REMOVED***
        readyTasks.push(function () ***REMOVED***
            runTask(key, task);
        ***REMOVED***);
    ***REMOVED***

    function processQueue() ***REMOVED***
        if (readyTasks.length === 0 && runningTasks === 0) ***REMOVED***
            return callback(null, results);
        ***REMOVED***
        while (readyTasks.length && runningTasks < concurrency) ***REMOVED***
            var run = readyTasks.shift();
            run();
        ***REMOVED***
    ***REMOVED***

    function addListener(taskName, fn) ***REMOVED***
        var taskListeners = listeners[taskName];
        if (!taskListeners) ***REMOVED***
            taskListeners = listeners[taskName] = [];
        ***REMOVED***

        taskListeners.push(fn);
    ***REMOVED***

    function taskComplete(taskName) ***REMOVED***
        var taskListeners = listeners[taskName] || [];
        (0, _arrayEach2.default)(taskListeners, function (fn) ***REMOVED***
            fn();
        ***REMOVED***);
        processQueue();
    ***REMOVED***

    function runTask(key, task) ***REMOVED***
        if (hasError) return;

        var taskCallback = (0, _onlyOnce2.default)((0, _rest2.default)(function (err, args) ***REMOVED***
            runningTasks--;
            if (args.length <= 1) ***REMOVED***
                args = args[0];
            ***REMOVED***
            if (err) ***REMOVED***
                var safeResults = ***REMOVED******REMOVED***;
                (0, _baseForOwn2.default)(results, function (val, rkey) ***REMOVED***
                    safeResults[rkey] = val;
                ***REMOVED***);
                safeResults[key] = args;
                hasError = true;
                listeners = [];

                callback(err, safeResults);
            ***REMOVED*** else ***REMOVED***
                results[key] = args;
                taskComplete(key);
            ***REMOVED***
        ***REMOVED***));

        runningTasks++;
        var taskFn = task[task.length - 1];
        if (task.length > 1) ***REMOVED***
            taskFn(results, taskCallback);
        ***REMOVED*** else ***REMOVED***
            taskFn(taskCallback);
        ***REMOVED***
    ***REMOVED***

    function checkForDeadlocks() ***REMOVED***
        // Kahn's algorithm
        // https://en.wikipedia.org/wiki/Topological_sorting#Kahn.27s_algorithm
        // http://connalle.blogspot.com/2013/10/topological-sortingkahn-algorithm.html
        var currentTask;
        var counter = 0;
        while (readyToCheck.length) ***REMOVED***
            currentTask = readyToCheck.pop();
            counter++;
            (0, _arrayEach2.default)(getDependents(currentTask), function (dependent) ***REMOVED***
                if (--uncheckedDependencies[dependent] === 0) ***REMOVED***
                    readyToCheck.push(dependent);
                ***REMOVED***
            ***REMOVED***);
        ***REMOVED***

        if (counter !== numTasks) ***REMOVED***
            throw new Error('async.auto cannot execute tasks due to a recursive dependency');
        ***REMOVED***
    ***REMOVED***

    function getDependents(taskName) ***REMOVED***
        var result = [];
        (0, _baseForOwn2.default)(tasks, function (task, key) ***REMOVED***
            if ((0, _isArray2.default)(task) && (0, _baseIndexOf2.default)(task, taskName, 0) >= 0) ***REMOVED***
                result.push(key);
            ***REMOVED***
        ***REMOVED***);
        return result;
    ***REMOVED***
***REMOVED***;

var _arrayEach = require('lodash/_arrayEach');

var _arrayEach2 = _interopRequireDefault(_arrayEach);

var _baseForOwn = require('lodash/_baseForOwn');

var _baseForOwn2 = _interopRequireDefault(_baseForOwn);

var _baseIndexOf = require('lodash/_baseIndexOf');

var _baseIndexOf2 = _interopRequireDefault(_baseIndexOf);

var _isArray = require('lodash/isArray');

var _isArray2 = _interopRequireDefault(_isArray);

var _keys = require('lodash/keys');

var _keys2 = _interopRequireDefault(_keys);

var _noop = require('lodash/noop');

var _noop2 = _interopRequireDefault(_noop);

var _rest = require('./internal/rest');

var _rest2 = _interopRequireDefault(_rest);

var _once = require('./internal/once');

var _once2 = _interopRequireDefault(_once);

var _onlyOnce = require('./internal/onlyOnce');

var _onlyOnce2 = _interopRequireDefault(_onlyOnce);

function _interopRequireDefault(obj) ***REMOVED*** return obj && obj.__esModule ? obj : ***REMOVED*** default: obj ***REMOVED***; ***REMOVED***

module.exports = exports['default'];

/**
 * Determines the best order for running the functions in `tasks`, based on
 * their requirements. Each function can optionally depend on other functions
 * being completed first, and each function is run as soon as its requirements
 * are satisfied.
 *
 * If any of the functions pass an error to their callback, the `auto` sequence
 * will stop. Further tasks will not execute (so any other functions depending
 * on it will not run), and the main `callback` is immediately called with the
 * error.
 *
 * Functions also receive an object containing the results of functions which
 * have completed so far as the first argument, if they have dependencies. If a
 * task function has no dependencies, it will only be passed a callback.
 *
 * @name auto
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param ***REMOVED***Object***REMOVED*** tasks - An object. Each of its properties is either a
 * function or an array of requirements, with the function itself the last item
 * in the array. The object's key of a property serves as the name of the task
 * defined by that property, i.e. can be used when specifying requirements for
 * other tasks. The function receives one or two arguments:
 * * a `results` object, containing the results of the previously executed
 *   functions, only passed if the task has any dependencies,
 * * a `callback(err, result)` function, which must be called when finished,
 *   passing an `error` (which can be `null`) and the result of the function's
 *   execution.
 * @param ***REMOVED***number***REMOVED*** [concurrency=Infinity] - An optional `integer` for
 * determining the maximum number of tasks that can be run in parallel. By
 * default, as many as possible.
 * @param ***REMOVED***Function***REMOVED*** [callback] - An optional callback which is called when all
 * the tasks have been completed. It receives the `err` argument if any `tasks`
 * pass an error to their callback. Results are always returned; however, if an
 * error occurs, no further `tasks` will be performed, and the results object
 * will only contain partial results. Invoked with (err, results).
 * @returns undefined
 * @example
 *
 * async.auto(***REMOVED***
 *     // this function will just be passed a callback
 *     readData: async.apply(fs.readFile, 'data.txt', 'utf-8'),
 *     showData: ['readData', function(results, cb) ***REMOVED***
 *         // results.readData is the file's contents
 *         // ...
 *     ***REMOVED***]
 * ***REMOVED***, callback);
 *
 * async.auto(***REMOVED***
 *     get_data: function(callback) ***REMOVED***
 *         console.log('in get_data');
 *         // async code to get some data
 *         callback(null, 'data', 'converted to array');
 *     ***REMOVED***,
 *     make_folder: function(callback) ***REMOVED***
 *         console.log('in make_folder');
 *         // async code to create a directory to store a file in
 *         // this is run at the same time as getting the data
 *         callback(null, 'folder');
 *     ***REMOVED***,
 *     write_file: ['get_data', 'make_folder', function(results, callback) ***REMOVED***
 *         console.log('in write_file', JSON.stringify(results));
 *         // once there is some data and the directory exists,
 *         // write the data to a file in the directory
 *         callback(null, 'filename');
 *     ***REMOVED***],
 *     email_link: ['write_file', function(results, callback) ***REMOVED***
 *         console.log('in email_link', JSON.stringify(results));
 *         // once the file is written let's email a link to it...
 *         // results.write_file contains the filename returned by write_file.
 *         callback(null, ***REMOVED***'file':results.write_file, 'email':'user@example.com'***REMOVED***);
 *     ***REMOVED***]
 * ***REMOVED***, function(err, results) ***REMOVED***
 *     console.log('err = ', err);
 *     console.log('results = ', results);
 * ***REMOVED***);
 */