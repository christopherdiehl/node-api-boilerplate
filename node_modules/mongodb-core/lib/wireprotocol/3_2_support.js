"use strict";

var Query = require('../connection/commands').Query
  , retrieveBSON = require('../connection/utils').retrieveBSON
  , f = require('util').format
  , MongoError = require('../error')
  , getReadPreference = require('./shared').getReadPreference;

var BSON = retrieveBSON(),
  Long = BSON.Long;

var WireProtocol = function(legacyWireProtocol) ***REMOVED***
  this.legacyWireProtocol = legacyWireProtocol;
***REMOVED***

//
// Execute a write operation
var executeWrite = function(pool, bson, type, opsField, ns, ops, options, callback) ***REMOVED***
  if(ops.length == 0) throw new MongoError("insert must contain at least one document");
  if(typeof options == 'function') ***REMOVED***
    callback = options;
    options = ***REMOVED******REMOVED***;
    options = options || ***REMOVED******REMOVED***;
  ***REMOVED***

  // Split the ns up to get db and collection
  var p = ns.split(".");
  var d = p.shift();
  // Options
  var ordered = typeof options.ordered == 'boolean' ? options.ordered : true;
  var writeConcern = options.writeConcern;

  // return skeleton
  var writeCommand = ***REMOVED******REMOVED***;
  writeCommand[type] = p.join('.');
  writeCommand[opsField] = ops;
  writeCommand.ordered = ordered;

  // Did we specify a write concern
  if(writeConcern && Object.keys(writeConcern).length > 0) ***REMOVED***
    writeCommand.writeConcern = writeConcern;
  ***REMOVED***

  // If we have collation passed in
  if(options.collation) ***REMOVED***
    for(var i = 0; i < writeCommand[opsField].length; i++) ***REMOVED***
      if(!writeCommand[opsField][i].collation) ***REMOVED***
        writeCommand[opsField][i].collation = options.collation;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  // Do we have bypassDocumentValidation set, then enable it on the write command
  if(typeof options.bypassDocumentValidation == 'boolean') ***REMOVED***
    writeCommand.bypassDocumentValidation = options.bypassDocumentValidation;
  ***REMOVED***

  // Options object
  var opts = ***REMOVED*** command: true ***REMOVED***;
  var queryOptions = ***REMOVED*** checkKeys : false, numberToSkip: 0, numberToReturn: 1 ***REMOVED***;
  if(type == 'insert') queryOptions.checkKeys = true;

  // Ensure we support serialization of functions
  if(options.serializeFunctions) queryOptions.serializeFunctions = options.serializeFunctions;
  // Do not serialize the undefined fields
  if(options.ignoreUndefined) queryOptions.ignoreUndefined = options.ignoreUndefined;

  try ***REMOVED***
    // Create write command
    var cmd = new Query(bson, f("%s.$cmd", d), writeCommand, queryOptions);
    // Execute command
    pool.write(cmd, opts, callback);
  ***REMOVED*** catch(err) ***REMOVED***
    callback(err);
  ***REMOVED***
***REMOVED***

//
// Needs to support legacy mass insert as well as ordered/unordered legacy
// emulation
//
WireProtocol.prototype.insert = function(pool, ismaster, ns, bson, ops, options, callback) ***REMOVED***
  executeWrite(pool, bson, 'insert', 'documents', ns, ops, options, callback);
***REMOVED***

WireProtocol.prototype.update = function(pool, ismaster, ns, bson, ops, options, callback) ***REMOVED***
  executeWrite(pool, bson, 'update', 'updates', ns, ops, options, callback);
***REMOVED***

WireProtocol.prototype.remove = function(pool, ismaster, ns, bson, ops, options, callback) ***REMOVED***
  executeWrite(pool, bson, 'delete', 'deletes', ns, ops, options, callback);
***REMOVED***

WireProtocol.prototype.killCursor = function(bson, ns, cursorId, pool, callback) ***REMOVED***
  // Build command namespace
  var parts = ns.split(/\./);
  // Command namespace
  var commandns = f('%s.$cmd', parts.shift());
  // Create getMore command
  var killcursorCmd = ***REMOVED***
    killCursors: parts.join('.'),
    cursors: [cursorId]
  ***REMOVED***

  // Build Query object
  var query = new Query(bson, commandns, killcursorCmd, ***REMOVED***
      numberToSkip: 0, numberToReturn: -1
    , checkKeys: false, returnFieldSelector: null
  ***REMOVED***);

  // Set query flags
  query.slaveOk = true;

  // Kill cursor callback
  var killCursorCallback = function(err, result) ***REMOVED***
    if(err) ***REMOVED***
      if(typeof callback != 'function') return;
      return callback(err);
    ***REMOVED***

    // Result
    var r = result.message;
    // If we have a timed out query or a cursor that was killed
    if((r.responseFlags & (1 << 0)) != 0) ***REMOVED***
      if(typeof callback != 'function') return;
      return callback(new MongoError("cursor killed or timed out"), null);
    ***REMOVED***

    if(!Array.isArray(r.documents) || r.documents.length == 0) ***REMOVED***
      if(typeof callback != 'function') return;
      return callback(new MongoError(f('invalid killCursors result returned for cursor id %s', cursorId)));
    ***REMOVED***

    // Return the result
    if(typeof callback == 'function') ***REMOVED***
      callback(null, r.documents[0]);
    ***REMOVED***
  ***REMOVED***

  // Execute the kill cursor command
  if(pool && pool.isConnected()) ***REMOVED***
    pool.write(query, ***REMOVED***
      command: true
    ***REMOVED***, killCursorCallback);
  ***REMOVED***
***REMOVED***

WireProtocol.prototype.getMore = function(bson, ns, cursorState, batchSize, raw, connection, options, callback) ***REMOVED***
  options = options || ***REMOVED******REMOVED***;
  // Build command namespace
  var parts = ns.split(/\./);
  // Command namespace
  var commandns = f('%s.$cmd', parts.shift());

  // Create getMore command
  var getMoreCmd = ***REMOVED***
    getMore: cursorState.cursorId,
    collection: parts.join('.'),
    batchSize: Math.abs(batchSize)
  ***REMOVED***

  if(cursorState.cmd.tailable
    && typeof cursorState.cmd.maxAwaitTimeMS == 'number') ***REMOVED***
    getMoreCmd.maxTimeMS = cursorState.cmd.maxAwaitTimeMS;
  ***REMOVED***

  // Build Query object
  var query = new Query(bson, commandns, getMoreCmd, ***REMOVED***
      numberToSkip: 0, numberToReturn: -1
    , checkKeys: false, returnFieldSelector: null
  ***REMOVED***);

  // Set query flags
  query.slaveOk = true;

  // Query callback
  var queryCallback = function(err, result) ***REMOVED***
    if(err) return callback(err);
    // Get the raw message
    var r = result.message;

    // If we have a timed out query or a cursor that was killed
    if((r.responseFlags & (1 << 0)) != 0) ***REMOVED***
      return callback(new MongoError("cursor killed or timed out"), null);
    ***REMOVED***

    // Raw, return all the extracted documents
    if(raw) ***REMOVED***
      cursorState.documents = r.documents;
      cursorState.cursorId = r.cursorId;
      return callback(null, r.documents);
    ***REMOVED***

    // We have an error detected
    if(r.documents[0].ok == 0) ***REMOVED***
      return callback(MongoError.create(r.documents[0]));
    ***REMOVED***

    // Ensure we have a Long valid cursor id
    var cursorId = typeof r.documents[0].cursor.id == 'number'
      ? Long.fromNumber(r.documents[0].cursor.id)
      : r.documents[0].cursor.id;

    // Set all the values
    cursorState.documents = r.documents[0].cursor.nextBatch;
    cursorState.cursorId = cursorId;

    // Return the result
    callback(null, r.documents[0], r.connection);
  ***REMOVED***

  // Query options
  var queryOptions = ***REMOVED*** command: true ***REMOVED***;

  // If we have a raw query decorate the function
  if(raw) ***REMOVED***
    queryOptions.raw = raw;
  ***REMOVED***

  // Add the result field needed
  queryOptions.documentsReturnedIn = 'nextBatch';

  // Check if we need to promote longs
  if(typeof cursorState.promoteLongs == 'boolean') ***REMOVED***
    queryOptions.promoteLongs = cursorState.promoteLongs;
  ***REMOVED***

  if(typeof cursorState.promoteValues == 'boolean') ***REMOVED***
    queryCallback.promoteValues = cursorState.promoteValues;
  ***REMOVED***

  if(typeof cursorState.promoteBuffers == 'boolean') ***REMOVED***
    queryCallback.promoteBuffers = cursorState.promoteBuffers;
  ***REMOVED***

  // Write out the getMore command
  connection.write(query, queryOptions, queryCallback);
***REMOVED***

WireProtocol.prototype.command = function(bson, ns, cmd, cursorState, topology, options) ***REMOVED***
  // Establish type of command
  if(cmd.find) ***REMOVED***
    // Create the find command
    var query = executeFindCommand(bson, ns, cmd, cursorState, topology, options)
    // Mark the cmd as virtual
    cmd.virtual = false;
    // Signal the documents are in the firstBatch value
    query.documentsReturnedIn = 'firstBatch';
    // Return the query
    return query;
  ***REMOVED*** else if(cursorState.cursorId != null) ***REMOVED***
    return;
  ***REMOVED*** else if(cmd) ***REMOVED***
    return setupCommand(bson, ns, cmd, cursorState, topology, options);
  ***REMOVED*** else ***REMOVED***
    throw new MongoError(f("command %s does not return a cursor", JSON.stringify(cmd)));
  ***REMOVED***
***REMOVED***

// // Command
// ***REMOVED***
//     find: ns
//   , query: <object>
//   , limit: <n>
//   , fields: <object>
//   , skip: <n>
//   , hint: <string>
//   , explain: <boolean>
//   , snapshot: <boolean>
//   , batchSize: <n>
//   , returnKey: <boolean>
//   , maxScan: <n>
//   , min: <n>
//   , max: <n>
//   , showDiskLoc: <boolean>
//   , comment: <string>
//   , maxTimeMS: <n>
//   , raw: <boolean>
//   , readPreference: <ReadPreference>
//   , tailable: <boolean>
//   , oplogReplay: <boolean>
//   , noCursorTimeout: <boolean>
//   , awaitdata: <boolean>
//   , exhaust: <boolean>
//   , partial: <boolean>
// ***REMOVED***

// FIND/GETMORE SPEC
// ***REMOVED***
//     “find”: <string>,
//     “filter”: ***REMOVED*** ... ***REMOVED***,
//     “sort”: ***REMOVED*** ... ***REMOVED***,
//     “projection”: ***REMOVED*** ... ***REMOVED***,
//     “hint”: ***REMOVED*** ... ***REMOVED***,
//     “skip”: <int>,
//     “limit”: <int>,
//     “batchSize”: <int>,
//     “singleBatch”: <bool>,
//     “comment”: <string>,
//     “maxScan”: <int>,
//     “maxTimeMS”: <int>,
//     “max”: ***REMOVED*** ... ***REMOVED***,
//     “min”: ***REMOVED*** ... ***REMOVED***,
//     “returnKey”: <bool>,
//     “showRecordId”: <bool>,
//     “snapshot”: <bool>,
//     “tailable”: <bool>,
//     “oplogReplay”: <bool>,
//     “noCursorTimeout”: <bool>,
//     “awaitData”: <bool>,
//     “partial”: <bool>,
//     “$readPreference”: ***REMOVED*** ... ***REMOVED***
// ***REMOVED***

//
// Execute a find command
var executeFindCommand = function(bson, ns, cmd, cursorState, topology, options) ***REMOVED***
  // Ensure we have at least some options
  options = options || ***REMOVED******REMOVED***;
  // Get the readPreference
  var readPreference = getReadPreference(cmd, options);
  // Set the optional batchSize
  cursorState.batchSize = cmd.batchSize || cursorState.batchSize;

  // Build command namespace
  var parts = ns.split(/\./);
  // Command namespace
  var commandns = f('%s.$cmd', parts.shift());

  // Build actual find command
  var findCmd = ***REMOVED***
    find: parts.join('.')
  ***REMOVED***;

  // I we provided a filter
  if(cmd.query) ***REMOVED***
    // Check if the user is passing in the $query parameter
    if(cmd.query['$query']) ***REMOVED***
      findCmd.filter = cmd.query['$query'];
    ***REMOVED*** else ***REMOVED***
      findCmd.filter = cmd.query;
    ***REMOVED***
  ***REMOVED***

  // Sort value
  var sortValue = cmd.sort;

  // Handle issue of sort being an Array
  if(Array.isArray(sortValue)) ***REMOVED***
    var sortObject = ***REMOVED******REMOVED***;

    if(sortValue.length > 0 && !Array.isArray(sortValue[0])) ***REMOVED***
      var sortDirection = sortValue[1];
      // Translate the sort order text
      if(sortDirection == 'asc') ***REMOVED***
        sortDirection = 1;
      ***REMOVED*** else if(sortDirection == 'desc') ***REMOVED***
        sortDirection = -1;
      ***REMOVED***

      // Set the sort order
      sortObject[sortValue[0]] = sortDirection;
    ***REMOVED*** else ***REMOVED***
      for(var i = 0; i < sortValue.length; i++) ***REMOVED***
        sortDirection = sortValue[i][1];
        // Translate the sort order text
        if(sortDirection == 'asc') ***REMOVED***
          sortDirection = 1;
        ***REMOVED*** else if(sortDirection == 'desc') ***REMOVED***
          sortDirection = -1;
        ***REMOVED***

        // Set the sort order
        sortObject[sortValue[i][0]] = sortDirection;
      ***REMOVED***
    ***REMOVED***

    sortValue = sortObject;
  ***REMOVED***

  // Add sort to command
  if(cmd.sort) findCmd.sort = sortValue;
  // Add a projection to the command
  if(cmd.fields) findCmd.projection = cmd.fields;
  // Add a hint to the command
  if(cmd.hint) findCmd.hint = cmd.hint;
  // Add a skip
  if(cmd.skip) findCmd.skip = cmd.skip;
  // Add a limit
  if(cmd.limit) findCmd.limit = cmd.limit;
  // Add a batchSize
  if(typeof cmd.batchSize == 'number') findCmd.batchSize = Math.abs(cmd.batchSize);

  // Check if we wish to have a singleBatch
  if(cmd.limit < 0) ***REMOVED***
    findCmd.limit = Math.abs(cmd.limit);
    findCmd.singleBatch = true;
  ***REMOVED***

  // If we have comment set
  if(cmd.comment) findCmd.comment = cmd.comment;

  // If we have maxScan
  if(cmd.maxScan) findCmd.maxScan = cmd.maxScan;

  // If we have maxTimeMS set
  if(cmd.maxTimeMS) findCmd.maxTimeMS = cmd.maxTimeMS;

  // If we have min
  if(cmd.min) findCmd.min = cmd.min;

  // If we have max
  if(cmd.max) findCmd.max = cmd.max;

  // If we have returnKey set
  if(cmd.returnKey) findCmd.returnKey = cmd.returnKey;

  // If we have showDiskLoc set
  if(cmd.showDiskLoc) findCmd.showRecordId = cmd.showDiskLoc;

  // If we have snapshot set
  if(cmd.snapshot) findCmd.snapshot = cmd.snapshot;

  // If we have tailable set
  if(cmd.tailable) findCmd.tailable = cmd.tailable;

  // If we have oplogReplay set
  if(cmd.oplogReplay) findCmd.oplogReplay = cmd.oplogReplay;

  // If we have noCursorTimeout set
  if(cmd.noCursorTimeout) findCmd.noCursorTimeout = cmd.noCursorTimeout;

  // If we have awaitData set
  if(cmd.awaitData) findCmd.awaitData = cmd.awaitData;
  if(cmd.awaitdata) findCmd.awaitData = cmd.awaitdata;

  // If we have partial set
  if(cmd.partial) findCmd.partial = cmd.partial;

  // If we have collation passed in
  if(cmd.collation) findCmd.collation = cmd.collation;

  // If we have explain, we need to rewrite the find command
  // to wrap it in the explain command
  if(cmd.explain) ***REMOVED***
    findCmd = ***REMOVED***
      explain: findCmd
    ***REMOVED***
  ***REMOVED***

  // Did we provide a readConcern
  if(cmd.readConcern) findCmd.readConcern = cmd.readConcern;

  // Set up the serialize and ignoreUndefined fields
  var serializeFunctions = typeof options.serializeFunctions == 'boolean'
    ? options.serializeFunctions : false;
  var ignoreUndefined = typeof options.ignoreUndefined == 'boolean'
    ? options.ignoreUndefined : false;

  // We have a Mongos topology, check if we need to add a readPreference
  if(topology.type == 'mongos'
    && readPreference
    && readPreference.preference != 'primary') ***REMOVED***
    findCmd = ***REMOVED***
      '$query': findCmd,
      '$readPreference': readPreference.toJSON()
    ***REMOVED***;
  ***REMOVED***

  // Build Query object
  var query = new Query(bson, commandns, findCmd, ***REMOVED***
      numberToSkip: 0, numberToReturn: 1
    , checkKeys: false, returnFieldSelector: null
    , serializeFunctions: serializeFunctions, ignoreUndefined: ignoreUndefined
  ***REMOVED***);

  // Set query flags
  query.slaveOk = readPreference.slaveOk();

  // Return the query
  return query;
***REMOVED***

//
// Set up a command cursor
var setupCommand = function(bson, ns, cmd, cursorState, topology, options) ***REMOVED***
  // Set empty options object
  options = options || ***REMOVED******REMOVED***
  // Get the readPreference
  var readPreference = getReadPreference(cmd, options);

  // Final query
  var finalCmd = ***REMOVED******REMOVED***;
  for(var name in cmd) ***REMOVED***
    finalCmd[name] = cmd[name];
  ***REMOVED***

  // Build command namespace
  var parts = ns.split(/\./);

  // Serialize functions
  var serializeFunctions = typeof options.serializeFunctions == 'boolean'
    ? options.serializeFunctions : false;

  // Set up the serialize and ignoreUndefined fields
  var ignoreUndefined = typeof options.ignoreUndefined == 'boolean'
    ? options.ignoreUndefined : false;

  // We have a Mongos topology, check if we need to add a readPreference
  if(topology.type == 'mongos'
    && readPreference
    && readPreference.preference != 'primary') ***REMOVED***
    finalCmd = ***REMOVED***
      '$query': finalCmd,
      '$readPreference': readPreference.toJSON()
    ***REMOVED***;
  ***REMOVED***

  // Build Query object
  var query = new Query(bson, f('%s.$cmd', parts.shift()), finalCmd, ***REMOVED***
      numberToSkip: 0, numberToReturn: -1
    , checkKeys: false, serializeFunctions: serializeFunctions
    , ignoreUndefined: ignoreUndefined
  ***REMOVED***);

  // Set query flags
  query.slaveOk = readPreference.slaveOk();

  // Return the query
  return query;
***REMOVED***

module.exports = WireProtocol;
