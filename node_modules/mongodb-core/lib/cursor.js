"use strict";

var Logger = require('./connection/logger')
  , retrieveBSON = require('./connection/utils').retrieveBSON
  , MongoError = require('./error')
  , f = require('util').format;

var BSON = retrieveBSON(),
  Long = BSON.Long;

/**
 * This is a cursor results callback
 *
 * @callback resultCallback
 * @param ***REMOVED***error***REMOVED*** error An error object. Set to null if no error present
 * @param ***REMOVED***object***REMOVED*** document
 */

/**
 * @fileOverview The **Cursor** class is an internal class that embodies a cursor on MongoDB
 * allowing for iteration over the results returned from the underlying query.
 *
 * **CURSORS Cannot directly be instantiated**
 * @example
 * var Server = require('mongodb-core').Server
 *   , ReadPreference = require('mongodb-core').ReadPreference
 *   , assert = require('assert');
 *
 * var server = new Server(***REMOVED***host: 'localhost', port: 27017***REMOVED***);
 * // Wait for the connection event
 * server.on('connect', function(server) ***REMOVED***
 *   assert.equal(null, err);
 *
 *   // Execute the write
 *   var cursor = _server.cursor('integration_tests.inserts_example4', ***REMOVED***
 *       find: 'integration_tests.example4'
 *     , query: ***REMOVED***a:1***REMOVED***
 *   ***REMOVED***, ***REMOVED***
 *     readPreference: new ReadPreference('secondary');
 *   ***REMOVED***);
 *
 *   // Get the first document
 *   cursor.next(function(err, doc) ***REMOVED***
 *     assert.equal(null, err);
 *     server.destroy();
 *   ***REMOVED***);
 * ***REMOVED***);
 *
 * // Start connecting
 * server.connect();
 */

/**
 * Creates a new Cursor, not to be used directly
 * @class
 * @param ***REMOVED***object***REMOVED*** bson An instance of the BSON parser
 * @param ***REMOVED***string***REMOVED*** ns The MongoDB fully qualified namespace (ex: db1.collection1)
 * @param ***REMOVED******REMOVED***object***REMOVED***|Long***REMOVED*** cmd The selector (can be a command or a cursorId)
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***object***REMOVED*** [options.batchSize=1000] Batchsize for the operation
 * @param ***REMOVED***array***REMOVED*** [options.documents=[]] Initial documents list for cursor
 * @param ***REMOVED***object***REMOVED*** [options.transforms=null] Transform methods for the cursor results
 * @param ***REMOVED***function***REMOVED*** [options.transforms.query] Transform the value returned from the initial query
 * @param ***REMOVED***function***REMOVED*** [options.transforms.doc] Transform each document returned from Cursor.prototype.next
 * @param ***REMOVED***object***REMOVED*** topology The server topology instance.
 * @param ***REMOVED***object***REMOVED*** topologyOptions The server topology options.
 * @return ***REMOVED***Cursor***REMOVED*** A cursor instance
 * @property ***REMOVED***number***REMOVED*** cursorBatchSize The current cursorBatchSize for the cursor
 * @property ***REMOVED***number***REMOVED*** cursorLimit The current cursorLimit for the cursor
 * @property ***REMOVED***number***REMOVED*** cursorSkip The current cursorSkip for the cursor
 */
var Cursor = function(bson, ns, cmd, options, topology, topologyOptions) ***REMOVED***
  options = options || ***REMOVED******REMOVED***;

  // Cursor pool
  this.pool = null;
  // Cursor server
  this.server = null;

  // Do we have a not connected handler
  this.disconnectHandler = options.disconnectHandler;

  // Set local values
  this.bson = bson;
  this.ns = ns;
  this.cmd = cmd;
  this.options = options;
  this.topology = topology;

  // All internal state
  this.cursorState = ***REMOVED***
      cursorId: null
    , cmd: cmd
    , documents: options.documents || []
    , cursorIndex: 0
    , dead: false
    , killed: false
    , init: false
    , notified: false
    , limit: options.limit || cmd.limit || 0
    , skip: options.skip || cmd.skip || 0
    , batchSize: options.batchSize || cmd.batchSize || 1000
    , currentLimit: 0
    // Result field name if not a cursor (contains the array of results)
    , transforms: options.transforms
  ***REMOVED***

  // Add promoteLong to cursor state
  if(typeof topologyOptions.promoteLongs == 'boolean') ***REMOVED***
    this.cursorState.promoteLongs = topologyOptions.promoteLongs;
  ***REMOVED*** else if(typeof options.promoteLongs == 'boolean') ***REMOVED***
    this.cursorState.promoteLongs = options.promoteLongs;
  ***REMOVED***

  // Add promoteValues to cursor state
  if(typeof topologyOptions.promoteValues == 'boolean') ***REMOVED***
    this.cursorState.promoteValues = topologyOptions.promoteValues;
  ***REMOVED*** else if(typeof options.promoteValues == 'boolean') ***REMOVED***
    this.cursorState.promoteValues = options.promoteValues;
  ***REMOVED***

  // Add promoteBuffers to cursor state
  if(typeof topologyOptions.promoteBuffers == 'boolean') ***REMOVED***
    this.cursorState.promoteBuffers = topologyOptions.promoteBuffers;
  ***REMOVED*** else if(typeof options.promoteBuffers == 'boolean') ***REMOVED***
    this.cursorState.promoteBuffers = options.promoteBuffers;
  ***REMOVED***

  // Logger
  this.logger = Logger('Cursor', topologyOptions);

  //
  // Did we pass in a cursor id
  if(typeof cmd == 'number') ***REMOVED***
    this.cursorState.cursorId = Long.fromNumber(cmd);
    this.cursorState.lastCursorId = this.cursorState.cursorId;
  ***REMOVED*** else if(cmd instanceof Long) ***REMOVED***
    this.cursorState.cursorId = cmd;
    this.cursorState.lastCursorId = cmd;
  ***REMOVED***
***REMOVED***

Cursor.prototype.setCursorBatchSize = function(value) ***REMOVED***
  this.cursorState.batchSize = value;
***REMOVED***

Cursor.prototype.cursorBatchSize = function() ***REMOVED***
  return this.cursorState.batchSize;
***REMOVED***

Cursor.prototype.setCursorLimit = function(value) ***REMOVED***
  this.cursorState.limit = value;
***REMOVED***

Cursor.prototype.cursorLimit = function() ***REMOVED***
  return this.cursorState.limit;
***REMOVED***

Cursor.prototype.setCursorSkip = function(value) ***REMOVED***
  this.cursorState.skip = value;
***REMOVED***

Cursor.prototype.cursorSkip = function() ***REMOVED***
  return this.cursorState.skip;
***REMOVED***

//
// Handle callback (including any exceptions thrown)
var handleCallback = function(callback, err, result) ***REMOVED***
  try ***REMOVED***
    callback(err, result);
  ***REMOVED*** catch(err) ***REMOVED***
    process.nextTick(function() ***REMOVED***
      throw err;
    ***REMOVED***);
  ***REMOVED***
***REMOVED***

// Internal methods
Cursor.prototype._find = function(callback) ***REMOVED***
  var self = this;

  if(self.logger.isDebug()) ***REMOVED***
    self.logger.debug(f('issue initial query [%s] with flags [%s]'
      , JSON.stringify(self.cmd)
      , JSON.stringify(self.query)));
  ***REMOVED***

  var queryCallback = function(err, r) ***REMOVED***
    if(err) return callback(err);

    // Get the raw message
    var result = r.message;

    // Query failure bit set
    if(result.queryFailure) ***REMOVED***
      return callback(MongoError.create(result.documents[0]), null);
    ***REMOVED***

    // Check if we have a command cursor
    if(Array.isArray(result.documents) && result.documents.length == 1
      && (!self.cmd.find || (self.cmd.find && self.cmd.virtual == false))
      && (result.documents[0].cursor != 'string'
        || result.documents[0]['$err']
        || result.documents[0]['errmsg']
        || Array.isArray(result.documents[0].result))
      ) ***REMOVED***

      // We have a an error document return the error
      if(result.documents[0]['$err']
        || result.documents[0]['errmsg']) ***REMOVED***
        return callback(MongoError.create(result.documents[0]), null);
      ***REMOVED***

      // We have a cursor document
      if(result.documents[0].cursor != null
        && typeof result.documents[0].cursor != 'string') ***REMOVED***
          var id = result.documents[0].cursor.id;
          // If we have a namespace change set the new namespace for getmores
          if(result.documents[0].cursor.ns) ***REMOVED***
            self.ns = result.documents[0].cursor.ns;
          ***REMOVED***
          // Promote id to long if needed
          self.cursorState.cursorId = typeof id == 'number' ? Long.fromNumber(id) : id;
          self.cursorState.lastCursorId = self.cursorState.cursorId;
          // If we have a firstBatch set it
          if(Array.isArray(result.documents[0].cursor.firstBatch)) ***REMOVED***
            self.cursorState.documents = result.documents[0].cursor.firstBatch;//.reverse();
          ***REMOVED***

          // Return after processing command cursor
          return callback(null, null);
      ***REMOVED***

      if(Array.isArray(result.documents[0].result)) ***REMOVED***
        self.cursorState.documents = result.documents[0].result;
        self.cursorState.cursorId = Long.ZERO;
        return callback(null, null);
      ***REMOVED***
    ***REMOVED***

    // Otherwise fall back to regular find path
    self.cursorState.cursorId = result.cursorId;
    self.cursorState.documents = result.documents;
    self.cursorState.lastCursorId = result.cursorId;

    // Transform the results with passed in transformation method if provided
    if(self.cursorState.transforms && typeof self.cursorState.transforms.query == 'function') ***REMOVED***
      self.cursorState.documents = self.cursorState.transforms.query(result);
    ***REMOVED***

    // Return callback
    callback(null, null);
  ***REMOVED***

  // Options passed to the pool
  var queryOptions = ***REMOVED******REMOVED***;

  // If we have a raw query decorate the function
  if(self.options.raw || self.cmd.raw) ***REMOVED***
    // queryCallback.raw = self.options.raw || self.cmd.raw;
    queryOptions.raw = self.options.raw || self.cmd.raw;
  ***REMOVED***

  // Do we have documentsReturnedIn set on the query
  if(typeof self.query.documentsReturnedIn == 'string') ***REMOVED***
    // queryCallback.documentsReturnedIn = self.query.documentsReturnedIn;
    queryOptions.documentsReturnedIn = self.query.documentsReturnedIn;
  ***REMOVED***

  // Add promote Long value if defined
  if(typeof self.cursorState.promoteLongs == 'boolean') ***REMOVED***
    queryOptions.promoteLongs = self.cursorState.promoteLongs;
  ***REMOVED***

  // Add promote values if defined
  if(typeof self.cursorState.promoteValues == 'boolean') ***REMOVED***
    queryOptions.promoteValues = self.cursorState.promoteValues;
  ***REMOVED***

  // Add promote values if defined
  if(typeof self.cursorState.promoteBuffers == 'boolean') ***REMOVED***
    queryOptions.promoteBuffers = self.cursorState.promoteBuffers;
  ***REMOVED***

  // Write the initial command out
  self.server.s.pool.write(self.query, queryOptions, queryCallback);
***REMOVED***

Cursor.prototype._getmore = function(callback) ***REMOVED***
  if(this.logger.isDebug()) this.logger.debug(f('schedule getMore call for query [%s]', JSON.stringify(this.query)))
  // Determine if it's a raw query
  var raw = this.options.raw || this.cmd.raw;

  // Set the current batchSize
  var batchSize = this.cursorState.batchSize;
  if(this.cursorState.limit > 0
    && ((this.cursorState.currentLimit + batchSize) > this.cursorState.limit)) ***REMOVED***
    batchSize = this.cursorState.limit - this.cursorState.currentLimit;
  ***REMOVED***

  // Default pool
  var pool = this.server.s.pool;

  // We have a wire protocol handler
  this.server.wireProtocolHandler.getMore(this.bson, this.ns, this.cursorState, batchSize, raw, pool, this.options, callback);
***REMOVED***

Cursor.prototype._killcursor = function(callback) ***REMOVED***
  // Set cursor to dead
  this.cursorState.dead = true;
  this.cursorState.killed = true;
  // Remove documents
  this.cursorState.documents = [];

  // If no cursor id just return
  if(this.cursorState.cursorId == null || this.cursorState.cursorId.isZero() || this.cursorState.init == false) ***REMOVED***
    if(callback) callback(null, null);
    return;
  ***REMOVED***

  // Default pool
  var pool = this.server.s.pool;
  // Execute command
  this.server.wireProtocolHandler.killCursor(this.bson, this.ns, this.cursorState.cursorId, pool, callback);
***REMOVED***

/**
 * Clone the cursor
 * @method
 * @return ***REMOVED***Cursor***REMOVED***
 */
Cursor.prototype.clone = function() ***REMOVED***
  return this.topology.cursor(this.ns, this.cmd, this.options);
***REMOVED***

/**
 * Checks if the cursor is dead
 * @method
 * @return ***REMOVED***boolean***REMOVED*** A boolean signifying if the cursor is dead or not
 */
Cursor.prototype.isDead = function() ***REMOVED***
  return this.cursorState.dead == true;
***REMOVED***

/**
 * Checks if the cursor was killed by the application
 * @method
 * @return ***REMOVED***boolean***REMOVED*** A boolean signifying if the cursor was killed by the application
 */
Cursor.prototype.isKilled = function() ***REMOVED***
  return this.cursorState.killed == true;
***REMOVED***

/**
 * Checks if the cursor notified it's caller about it's death
 * @method
 * @return ***REMOVED***boolean***REMOVED*** A boolean signifying if the cursor notified the callback
 */
Cursor.prototype.isNotified = function() ***REMOVED***
  return this.cursorState.notified == true;
***REMOVED***

/**
 * Returns current buffered documents length
 * @method
 * @return ***REMOVED***number***REMOVED*** The number of items in the buffered documents
 */
Cursor.prototype.bufferedCount = function() ***REMOVED***
  return this.cursorState.documents.length - this.cursorState.cursorIndex;
***REMOVED***

/**
 * Returns current buffered documents
 * @method
 * @return ***REMOVED***Array***REMOVED*** An array of buffered documents
 */
Cursor.prototype.readBufferedDocuments = function(number) ***REMOVED***
  var unreadDocumentsLength = this.cursorState.documents.length - this.cursorState.cursorIndex;
  var length = number < unreadDocumentsLength ? number : unreadDocumentsLength;
  var elements = this.cursorState.documents.slice(this.cursorState.cursorIndex, this.cursorState.cursorIndex + length);

  // Transform the doc with passed in transformation method if provided
  if(this.cursorState.transforms && typeof this.cursorState.transforms.doc == 'function') ***REMOVED***
    // Transform all the elements
    for(var i = 0; i < elements.length; i++) ***REMOVED***
      elements[i] = this.cursorState.transforms.doc(elements[i]);
    ***REMOVED***
  ***REMOVED***

  // Ensure we do not return any more documents than the limit imposed
  // Just return the number of elements up to the limit
  if(this.cursorState.limit > 0 && (this.cursorState.currentLimit + elements.length) > this.cursorState.limit) ***REMOVED***
    elements = elements.slice(0, (this.cursorState.limit - this.cursorState.currentLimit));
    this.kill();
  ***REMOVED***

  // Adjust current limit
  this.cursorState.currentLimit = this.cursorState.currentLimit + elements.length;
  this.cursorState.cursorIndex = this.cursorState.cursorIndex + elements.length;

  // Return elements
  return elements;
***REMOVED***

/**
 * Kill the cursor
 * @method
 * @param ***REMOVED***resultCallback***REMOVED*** callback A callback function
 */
Cursor.prototype.kill = function(callback) ***REMOVED***
  this._killcursor(callback);
***REMOVED***

/**
 * Resets the cursor
 * @method
 * @return ***REMOVED***null***REMOVED***
 */
Cursor.prototype.rewind = function() ***REMOVED***
  if(this.cursorState.init) ***REMOVED***
    if(!this.cursorState.dead) ***REMOVED***
      this.kill();
    ***REMOVED***

    this.cursorState.currentLimit = 0;
    this.cursorState.init = false;
    this.cursorState.dead = false;
    this.cursorState.killed = false;
    this.cursorState.notified = false;
    this.cursorState.documents = [];
    this.cursorState.cursorId = null;
    this.cursorState.cursorIndex = 0;
  ***REMOVED***
***REMOVED***

/**
 * Validate if the pool is dead and return error
 */
var isConnectionDead = function(self, callback) ***REMOVED***
  if(self.pool
    && self.pool.isDestroyed()) ***REMOVED***
    self.cursorState.notified = true;
    self.cursorState.killed = true;
    self.cursorState.documents = [];
    self.cursorState.cursorIndex = 0;
    callback(MongoError.create(f('connection to host %s:%s was destroyed', self.pool.host, self.pool.port)))
    return true;
  ***REMOVED***

  return false;
***REMOVED***

/**
 * Validate if the cursor is dead but was not explicitly killed by user
 */
var isCursorDeadButNotkilled = function(self, callback) ***REMOVED***
  // Cursor is dead but not marked killed, return null
  if(self.cursorState.dead && !self.cursorState.killed) ***REMOVED***
    self.cursorState.notified = true;
    self.cursorState.killed = true;
    self.cursorState.documents = [];
    self.cursorState.cursorIndex = 0;
    handleCallback(callback, null, null);
    return true;
  ***REMOVED***

  return false;
***REMOVED***

/**
 * Validate if the cursor is dead and was killed by user
 */
var isCursorDeadAndKilled = function(self, callback) ***REMOVED***
  if(self.cursorState.dead && self.cursorState.killed) ***REMOVED***
    handleCallback(callback, MongoError.create('cursor is dead'));
    return true;
  ***REMOVED***

  return false;
***REMOVED***

/**
 * Validate if the cursor was killed by the user
 */
var isCursorKilled = function(self, callback) ***REMOVED***
  if(self.cursorState.killed) ***REMOVED***
    self.cursorState.notified = true;
    self.cursorState.documents = [];
    self.cursorState.cursorIndex = 0;
    handleCallback(callback, null, null);
    return true;
  ***REMOVED***

  return false;
***REMOVED***

/**
 * Mark cursor as being dead and notified
 */
var setCursorDeadAndNotified = function(self, callback) ***REMOVED***
  self.cursorState.dead = true;
  self.cursorState.notified = true;
  self.cursorState.documents = [];
  self.cursorState.cursorIndex = 0;
  handleCallback(callback, null, null);
***REMOVED***

/**
 * Mark cursor as being notified
 */
var setCursorNotified = function(self, callback) ***REMOVED***
  self.cursorState.notified = true;
  self.cursorState.documents = [];
  self.cursorState.cursorIndex = 0;
  handleCallback(callback, null, null);
***REMOVED***

var nextFunction = function(self, callback) ***REMOVED***
  // We have notified about it
  if(self.cursorState.notified) ***REMOVED***
    return callback(new Error('cursor is exhausted'));
  ***REMOVED***

  // Cursor is killed return null
  if(isCursorKilled(self, callback)) return;

  // Cursor is dead but not marked killed, return null
  if(isCursorDeadButNotkilled(self, callback)) return;

  // We have a dead and killed cursor, attempting to call next should error
  if(isCursorDeadAndKilled(self, callback)) return;

  // We have just started the cursor
  if(!self.cursorState.init) ***REMOVED***
    // Topology is not connected, save the call in the provided store to be
    // Executed at some point when the handler deems it's reconnected
    if(!self.topology.isConnected(self.options) && self.disconnectHandler != null) ***REMOVED***
      if (self.topology.isDestroyed()) ***REMOVED***
        // Topology was destroyed, so don't try to wait for it to reconnect
        return callback(new MongoError('Topology was destroyed'));
      ***REMOVED***
      return self.disconnectHandler.addObjectAndMethod('cursor', self, 'next', [callback], callback);
    ***REMOVED***

    try ***REMOVED***
      self.server = self.topology.getServer(self.options);
    ***REMOVED*** catch(err) ***REMOVED***
      // Handle the error and add object to next method call
      if(self.disconnectHandler != null) ***REMOVED***
        return self.disconnectHandler.addObjectAndMethod('cursor', self, 'next', [callback], callback);
      ***REMOVED***

      // Otherwise return the error
      return callback(err);
    ***REMOVED***

    // Set as init
    self.cursorState.init = true;

    // Server does not support server
    if(self.cmd
      && self.cmd.collation
      && self.server.ismaster.maxWireVersion < 5) ***REMOVED***
      return callback(new MongoError(f('server %s does not support collation', self.server.name)));
    ***REMOVED***

    try ***REMOVED***
      self.query = self.server.wireProtocolHandler.command(self.bson, self.ns, self.cmd, self.cursorState, self.topology, self.options);
    ***REMOVED*** catch(err) ***REMOVED***
      return callback(err);
    ***REMOVED***
  ***REMOVED***

  // If we don't have a cursorId execute the first query
  if(self.cursorState.cursorId == null) ***REMOVED***
    // Check if pool is dead and return if not possible to
    // execute the query against the db
    if(isConnectionDead(self, callback)) return;

    // Check if topology is destroyed
    if(self.topology.isDestroyed()) return callback(new MongoError('connection destroyed, not possible to instantiate cursor'));

    // query, cmd, options, cursorState, callback
    self._find(function(err) ***REMOVED***
      if(err) return handleCallback(callback, err, null);

      if(self.cursorState.documents.length == 0
        && self.cursorState.cursorId && self.cursorState.cursorId.isZero()
        && !self.cmd.tailable && !self.cmd.awaitData) ***REMOVED***
        return setCursorNotified(self, callback);
      ***REMOVED***

      nextFunction(self, callback);
    ***REMOVED***);
  ***REMOVED*** else if(self.cursorState.limit > 0 && self.cursorState.currentLimit >= self.cursorState.limit) ***REMOVED***
    // Ensure we kill the cursor on the server
    self.kill();
    // Set cursor in dead and notified state
    return setCursorDeadAndNotified(self, callback);
  ***REMOVED*** else if(self.cursorState.cursorIndex == self.cursorState.documents.length
      && !Long.ZERO.equals(self.cursorState.cursorId)) ***REMOVED***
      // Ensure an empty cursor state
      self.cursorState.documents = [];
      self.cursorState.cursorIndex = 0;

      // Check if topology is destroyed
      if(self.topology.isDestroyed()) return callback(new MongoError('connection destroyed, not possible to instantiate cursor'));

      // Check if connection is dead and return if not possible to
      // execute a getmore on this connection
      if(isConnectionDead(self, callback)) return;

      // Execute the next get more
      self._getmore(function(err, doc, connection) ***REMOVED***
        if(err) return handleCallback(callback, err);

        // Save the returned connection to ensure all getMore's fire over the same connection
        self.connection = connection;

        // Tailable cursor getMore result, notify owner about it
        // No attempt is made here to retry, this is left to the user of the
        // core module to handle to keep core simple
        if(self.cursorState.documents.length == 0
          && self.cmd.tailable && Long.ZERO.equals(self.cursorState.cursorId)) ***REMOVED***
          // No more documents in the tailed cursor
          return handleCallback(callback, MongoError.create(***REMOVED***
              message: 'No more documents in tailed cursor'
            , tailable: self.cmd.tailable
            , awaitData: self.cmd.awaitData
          ***REMOVED***));
        ***REMOVED*** else if(self.cursorState.documents.length == 0
          && self.cmd.tailable && !Long.ZERO.equals(self.cursorState.cursorId)) ***REMOVED***
          return nextFunction(self, callback);
        ***REMOVED***

        if(self.cursorState.limit > 0 && self.cursorState.currentLimit >= self.cursorState.limit) ***REMOVED***
          return setCursorDeadAndNotified(self, callback);
        ***REMOVED***

        nextFunction(self, callback);
      ***REMOVED***);
  ***REMOVED*** else if(self.cursorState.documents.length == self.cursorState.cursorIndex
    && self.cmd.tailable && Long.ZERO.equals(self.cursorState.cursorId)) ***REMOVED***
      return handleCallback(callback, MongoError.create(***REMOVED***
          message: 'No more documents in tailed cursor'
        , tailable: self.cmd.tailable
        , awaitData: self.cmd.awaitData
      ***REMOVED***));
  ***REMOVED*** else if(self.cursorState.documents.length == self.cursorState.cursorIndex
      && Long.ZERO.equals(self.cursorState.cursorId)) ***REMOVED***
      setCursorDeadAndNotified(self, callback);
  ***REMOVED*** else ***REMOVED***
    if(self.cursorState.limit > 0 && self.cursorState.currentLimit >= self.cursorState.limit) ***REMOVED***
      // Ensure we kill the cursor on the server
      self.kill();
      // Set cursor in dead and notified state
      return setCursorDeadAndNotified(self, callback);
    ***REMOVED***

    // Increment the current cursor limit
    self.cursorState.currentLimit += 1;

    // Get the document
    var doc = self.cursorState.documents[self.cursorState.cursorIndex++];

    // Doc overflow
    if(doc.$err) ***REMOVED***
      // Ensure we kill the cursor on the server
      self.kill();
      // Set cursor in dead and notified state
      return setCursorDeadAndNotified(self, function() ***REMOVED***
        handleCallback(callback, new MongoError(doc.$err));
      ***REMOVED***);
    ***REMOVED***

    // Transform the doc with passed in transformation method if provided
    if(self.cursorState.transforms && typeof self.cursorState.transforms.doc == 'function') ***REMOVED***
      doc = self.cursorState.transforms.doc(doc);
    ***REMOVED***

    // Return the document
    handleCallback(callback, null, doc);
  ***REMOVED***
***REMOVED***

/**
 * Retrieve the next document from the cursor
 * @method
 * @param ***REMOVED***resultCallback***REMOVED*** callback A callback function
 */
Cursor.prototype.next = function(callback) ***REMOVED***
  nextFunction(this, callback);
***REMOVED***

module.exports = Cursor;
