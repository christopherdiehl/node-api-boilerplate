"use strict";

var f = require('util').format
  , crypto = require('crypto')
  , retrieveBSON = require('../connection/utils').retrieveBSON
  , Query = require('../connection/commands').Query
  , MongoError = require('../error');

var BSON = retrieveBSON(),
  Binary = BSON.Binary;

var AuthSession = function(db, username, password) ***REMOVED***
  this.db = db;
  this.username = username;
  this.password = password;
***REMOVED***

AuthSession.prototype.equal = function(session) ***REMOVED***
  return session.db == this.db
    && session.username == this.username
    && session.password == this.password;
***REMOVED***

var id = 0;

/**
 * Creates a new ScramSHA1 authentication mechanism
 * @class
 * @return ***REMOVED***ScramSHA1***REMOVED*** A cursor instance
 */
var ScramSHA1 = function(bson) ***REMOVED***
  this.bson = bson;
  this.authStore = [];
  this.id = id++;
***REMOVED***

var parsePayload = function(payload) ***REMOVED***
  var dict = ***REMOVED******REMOVED***;
  var parts = payload.split(',');

  for(var i = 0; i < parts.length; i++) ***REMOVED***
    var valueParts = parts[i].split('=');
    dict[valueParts[0]] = valueParts[1];
  ***REMOVED***

  return dict;
***REMOVED***

var passwordDigest = function(username, password) ***REMOVED***
  if(typeof username != 'string') throw new MongoError("username must be a string");
  if(typeof password != 'string') throw new MongoError("password must be a string");
  if(password.length == 0) throw new MongoError("password cannot be empty");
  // Use node md5 generator
  var md5 = crypto.createHash('md5');
  // Generate keys used for authentication
  md5.update(username + ":mongo:" + password, 'utf8');
  return md5.digest('hex');
***REMOVED***

// XOR two buffers
var xor = function(a, b) ***REMOVED***
  if (!Buffer.isBuffer(a)) a = new Buffer(a)
  if (!Buffer.isBuffer(b)) b = new Buffer(b)
  var res = []
  if (a.length > b.length) ***REMOVED***
    for (var i = 0; i < b.length; i++) ***REMOVED***
      res.push(a[i] ^ b[i])
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    for (i = 0; i < a.length; i++) ***REMOVED***
      res.push(a[i] ^ b[i])
    ***REMOVED***
  ***REMOVED***
  return new Buffer(res);
***REMOVED***

// Create a final digest
var hi = function(data, salt, iterations) ***REMOVED***
  // Create digest
  var digest = function(msg) ***REMOVED***
    var hmac = crypto.createHmac('sha1', data);
    hmac.update(msg);
    return new Buffer(hmac.digest('base64'), 'base64');
  ***REMOVED***

  // Create variables
  salt = Buffer.concat([salt, new Buffer('\x00\x00\x00\x01')])
  var ui = digest(salt);
  var u1 = ui;

  for(var i = 0; i < iterations - 1; i++) ***REMOVED***
    u1 = digest(u1);
    ui = xor(ui, u1);
  ***REMOVED***

  return ui;
***REMOVED***

/**
 * Authenticate
 * @method
 * @param ***REMOVED******REMOVED***Server***REMOVED***|***REMOVED***ReplSet***REMOVED***|***REMOVED***Mongos***REMOVED******REMOVED*** server Topology the authentication method is being called on
 * @param ***REMOVED***[]Connections***REMOVED*** connections Connections to authenticate using this authenticator
 * @param ***REMOVED***string***REMOVED*** db Name of the database
 * @param ***REMOVED***string***REMOVED*** username Username
 * @param ***REMOVED***string***REMOVED*** password Password
 * @param ***REMOVED***authResultCallback***REMOVED*** callback The callback to return the result from the authentication
 * @return ***REMOVED***object***REMOVED***
 */
ScramSHA1.prototype.auth = function(server, connections, db, username, password, callback) ***REMOVED***
  var self = this;
  // Total connections
  var count = connections.length;
  if(count == 0) return callback(null, null);

  // Valid connections
  var numberOfValidConnections = 0;
  var errorObject = null;

  // Execute MongoCR
  var executeScram = function(connection) ***REMOVED***
    // Clean up the user
    username = username.replace('=', "=3D").replace(',', '=2C');

    // Create a random nonce
    var nonce = crypto.randomBytes(24).toString('base64');
    // var nonce = 'MsQUY9iw0T9fx2MUEz6LZPwGuhVvWAhc'
    var firstBare = f("n=%s,r=%s", username, nonce);

    // Build command structure
    var cmd = ***REMOVED***
        saslStart: 1
      , mechanism: 'SCRAM-SHA-1'
      , payload: new Binary(f("n,,%s", firstBare))
      , autoAuthorize: 1
    ***REMOVED***

    // Handle the error
    var handleError = function(err, r) ***REMOVED***
      if(err) ***REMOVED***
        numberOfValidConnections = numberOfValidConnections - 1;
        errorObject = err; return false;
      ***REMOVED*** else if(r.result['$err']) ***REMOVED***
        errorObject = r.result; return false;
      ***REMOVED*** else if(r.result['errmsg']) ***REMOVED***
        errorObject = r.result; return false;
      ***REMOVED*** else ***REMOVED***
        numberOfValidConnections = numberOfValidConnections + 1;
      ***REMOVED***

      return true
    ***REMOVED***

    // Finish up
    var finish = function(_count, _numberOfValidConnections) ***REMOVED***
      if(_count == 0 && _numberOfValidConnections > 0) ***REMOVED***
        // Store the auth details
        addAuthSession(self.authStore, new AuthSession(db, username, password));
        // Return correct authentication
        return callback(null, true);
      ***REMOVED*** else if(_count == 0) ***REMOVED***
        if(errorObject == null) errorObject = new MongoError(f("failed to authenticate using scram"));
        return callback(errorObject, false);
      ***REMOVED***
    ***REMOVED***

    var handleEnd = function(_err, _r) ***REMOVED***
      // Handle any error
      handleError(_err, _r)
      // Adjust the number of connections
      count = count - 1;
      // Execute the finish
      finish(count, numberOfValidConnections);
    ***REMOVED***

    // Write the commmand on the connection
    server(connection, new Query(self.bson, f("%s.$cmd", db), cmd, ***REMOVED***
      numberToSkip: 0, numberToReturn: 1
    ***REMOVED***), function(err, r) ***REMOVED***
      // Do we have an error, handle it
      if(handleError(err, r) == false) ***REMOVED***
        count = count - 1;

        if(count == 0 && numberOfValidConnections > 0) ***REMOVED***
          // Store the auth details
          addAuthSession(self.authStore, new AuthSession(db, username, password));
          // Return correct authentication
          return callback(null, true);
        ***REMOVED*** else if(count == 0) ***REMOVED***
          if(errorObject == null) errorObject = new MongoError(f("failed to authenticate using scram"));
          return callback(errorObject, false);
        ***REMOVED***

        return;
      ***REMOVED***

      // Get the dictionary
      var dict = parsePayload(r.result.payload.value())

      // Unpack dictionary
      var iterations = parseInt(dict.i, 10);
      var salt = dict.s;
      var rnonce = dict.r;

      // Set up start of proof
      var withoutProof = f("c=biws,r=%s", rnonce);
      var passwordDig = passwordDigest(username, password);
      var saltedPassword = hi(passwordDig
          , new Buffer(salt, 'base64')
          , iterations);

      // Create the client key
      var hmac = crypto.createHmac('sha1', saltedPassword);
      hmac.update(new Buffer("Client Key"));
      var clientKey = new Buffer(hmac.digest('base64'), 'base64');

      // Create the stored key
      var hash = crypto.createHash('sha1');
      hash.update(clientKey);
      var storedKey = new Buffer(hash.digest('base64'), 'base64');

      // Create the authentication message
      var authMsg = [firstBare, r.result.payload.value().toString('base64'), withoutProof].join(',');

      // Create client signature
      hmac = crypto.createHmac('sha1', storedKey);
      hmac.update(new Buffer(authMsg));
      var clientSig = new Buffer(hmac.digest('base64'), 'base64');

      // Create client proof
      var clientProof = f("p=%s", new Buffer(xor(clientKey, clientSig)).toString('base64'));

      // Create client final
      var clientFinal = [withoutProof, clientProof].join(',');

      // Generate server key
      hmac = crypto.createHmac('sha1', saltedPassword);
      hmac.update(new Buffer('Server Key'))
      var serverKey = new Buffer(hmac.digest('base64'), 'base64');

      // Generate server signature
      hmac = crypto.createHmac('sha1', serverKey);
      hmac.update(new Buffer(authMsg))

      //
      // Create continue message
      var cmd = ***REMOVED***
          saslContinue: 1
        , conversationId: r.result.conversationId
        , payload: new Binary(new Buffer(clientFinal))
      ***REMOVED***

      //
      // Execute sasl continue
      // Write the commmand on the connection
      server(connection, new Query(self.bson, f("%s.$cmd", db), cmd, ***REMOVED***
        numberToSkip: 0, numberToReturn: 1
      ***REMOVED***), function(err, r) ***REMOVED***
        if(r && r.result.done == false) ***REMOVED***
          var cmd = ***REMOVED***
              saslContinue: 1
            , conversationId: r.result.conversationId
            , payload: new Buffer(0)
          ***REMOVED***

          // Write the commmand on the connection
          server(connection, new Query(self.bson, f("%s.$cmd", db), cmd, ***REMOVED***
            numberToSkip: 0, numberToReturn: 1
          ***REMOVED***), function(err, r) ***REMOVED***
            handleEnd(err, r);
          ***REMOVED***);
        ***REMOVED*** else ***REMOVED***
          handleEnd(err, r);
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***);
  ***REMOVED***

  var _execute = function(_connection) ***REMOVED***
    process.nextTick(function() ***REMOVED***
      executeScram(_connection);
    ***REMOVED***);
  ***REMOVED***

  // For each connection we need to authenticate
  while(connections.length > 0) ***REMOVED***
    _execute(connections.shift());
  ***REMOVED***
***REMOVED***

// Add to store only if it does not exist
var addAuthSession = function(authStore, session) ***REMOVED***
  var found = false;

  for(var i = 0; i < authStore.length; i++) ***REMOVED***
    if(authStore[i].equal(session)) ***REMOVED***
      found = true;
      break;
    ***REMOVED***
  ***REMOVED***

  if(!found) authStore.push(session);
***REMOVED***

/**
 * Remove authStore credentials
 * @method
 * @param ***REMOVED***string***REMOVED*** db Name of database we are removing authStore details about
 * @return ***REMOVED***object***REMOVED***
 */
ScramSHA1.prototype.logout = function(dbName) ***REMOVED***
  this.authStore = this.authStore.filter(function(x) ***REMOVED***
    return x.db != dbName;
  ***REMOVED***);
***REMOVED***

/**
 * Re authenticate pool
 * @method
 * @param ***REMOVED******REMOVED***Server***REMOVED***|***REMOVED***ReplSet***REMOVED***|***REMOVED***Mongos***REMOVED******REMOVED*** server Topology the authentication method is being called on
 * @param ***REMOVED***[]Connections***REMOVED*** connections Connections to authenticate using this authenticator
 * @param ***REMOVED***authResultCallback***REMOVED*** callback The callback to return the result from the authentication
 * @return ***REMOVED***object***REMOVED***
 */
ScramSHA1.prototype.reauthenticate = function(server, connections, callback) ***REMOVED***
  var authStore = this.authStore.slice(0);
  var count = authStore.length;
  // No connections
  if(count == 0) return callback(null, null);
  // Iterate over all the auth details stored
  for(var i = 0; i < authStore.length; i++) ***REMOVED***
    this.auth(server, connections, authStore[i].db, authStore[i].username, authStore[i].password, function(err) ***REMOVED***
      count = count - 1;
      // Done re-authenticating
      if(count == 0) ***REMOVED***
        callback(err, null);
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***
***REMOVED***


module.exports = ScramSHA1;
