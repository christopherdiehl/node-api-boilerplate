"use strict"

var inherits = require('util').inherits,
  require_optional = require('require_optional'),
  f = require('util').format,
  EventEmitter = require('events').EventEmitter,
  ReadPreference = require('./read_preference'),
  Logger = require('../connection/logger'),
  debugOptions = require('../connection/utils').debugOptions,
  retrieveBSON = require('../connection/utils').retrieveBSON,
  Pool = require('../connection/pool'),
  Query = require('../connection/commands').Query,
  MongoError = require('../error'),
  PreTwoSixWireProtocolSupport = require('../wireprotocol/2_4_support'),
  TwoSixWireProtocolSupport = require('../wireprotocol/2_6_support'),
  ThreeTwoWireProtocolSupport = require('../wireprotocol/3_2_support'),
  BasicCursor = require('../cursor'),
  sdam = require('./shared'),
  assign = require('./shared').assign,
  createClientInfo = require('./shared').createClientInfo;

// Used for filtering out fields for loggin
var debugFields = ['reconnect', 'reconnectTries', 'reconnectInterval', 'emitError', 'cursorFactory', 'host'
  , 'port', 'size', 'keepAlive', 'keepAliveInitialDelay', 'noDelay', 'connectionTimeout', 'checkServerIdentity'
  , 'socketTimeout', 'singleBufferSerializtion', 'ssl', 'ca', 'cert', 'key', 'rejectUnauthorized', 'promoteLongs', 'promoteValues'
  , 'promoteBuffers', 'servername'];

// Server instance id
var id = 0;
var serverAccounting = false;
var servers = ***REMOVED******REMOVED***;
var BSON = retrieveBSON();

/**
 * Creates a new Server instance
 * @class
 * @param ***REMOVED***boolean***REMOVED*** [options.reconnect=true] Server will attempt to reconnect on loss of connection
 * @param ***REMOVED***number***REMOVED*** [options.reconnectTries=30] Server attempt to reconnect #times
 * @param ***REMOVED***number***REMOVED*** [options.reconnectInterval=1000] Server will wait # milliseconds between retries
 * @param ***REMOVED***number***REMOVED*** [options.monitoring=true] Enable the server state monitoring (calling ismaster at monitoringInterval)
 * @param ***REMOVED***number***REMOVED*** [options.monitoringInterval=5000] The interval of calling ismaster when monitoring is enabled.
 * @param ***REMOVED***Cursor***REMOVED*** [options.cursorFactory=Cursor] The cursor factory class used for all query cursors
 * @param ***REMOVED***string***REMOVED*** options.host The server host
 * @param ***REMOVED***number***REMOVED*** options.port The server port
 * @param ***REMOVED***number***REMOVED*** [options.size=5] Server connection pool size
 * @param ***REMOVED***boolean***REMOVED*** [options.keepAlive=true] TCP Connection keep alive enabled
 * @param ***REMOVED***number***REMOVED*** [options.keepAliveInitialDelay=0] Initial delay before TCP keep alive enabled
 * @param ***REMOVED***boolean***REMOVED*** [options.noDelay=true] TCP Connection no delay
 * @param ***REMOVED***number***REMOVED*** [options.connectionTimeout=0] TCP Connection timeout setting
 * @param ***REMOVED***number***REMOVED*** [options.socketTimeout=0] TCP Socket timeout setting
 * @param ***REMOVED***boolean***REMOVED*** [options.ssl=false] Use SSL for connection
 * @param ***REMOVED***boolean|function***REMOVED*** [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.
 * @param ***REMOVED***Buffer***REMOVED*** [options.ca] SSL Certificate store binary buffer
 * @param ***REMOVED***Buffer***REMOVED*** [options.cert] SSL Certificate binary buffer
 * @param ***REMOVED***Buffer***REMOVED*** [options.key] SSL Key file binary buffer
 * @param ***REMOVED***string***REMOVED*** [options.passphrase] SSL Certificate pass phrase
 * @param ***REMOVED***boolean***REMOVED*** [options.rejectUnauthorized=true] Reject unauthorized server certificates
 * @param ***REMOVED***string***REMOVED*** [options.servername=null] String containing the server name requested via TLS SNI.
 * @param ***REMOVED***boolean***REMOVED*** [options.promoteLongs=true] Convert Long values from the db into Numbers if they fit into 53 bits
 * @param ***REMOVED***boolean***REMOVED*** [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.
 * @param ***REMOVED***boolean***REMOVED*** [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.
 * @param ***REMOVED***string***REMOVED*** [options.appname=null] Application name, passed in on ismaster call and logged in mongod server logs. Maximum size 128 bytes.
 * @param ***REMOVED***boolean***REMOVED*** [options.domainsEnabled=false] Enable the wrapping of the callback in the current domain, disabled by default to avoid perf hit.
 * @return ***REMOVED***Server***REMOVED*** A cursor instance
 * @fires Server#connect
 * @fires Server#close
 * @fires Server#error
 * @fires Server#timeout
 * @fires Server#parseError
 * @fires Server#reconnect
 * @fires Server#reconnectFailed
 * @fires Server#serverHeartbeatStarted
 * @fires Server#serverHeartbeatSucceeded
 * @fires Server#serverHeartbeatFailed
 * @fires Server#topologyOpening
 * @fires Server#topologyClosed
 * @fires Server#topologyDescriptionChanged
 * @property ***REMOVED***string***REMOVED*** type the topology type.
 * @property ***REMOVED***string***REMOVED*** parserType the parser type used (c++ or js).
 */
var Server = function(options) ***REMOVED***
  options = options || ***REMOVED******REMOVED***;

  // Add event listener
  EventEmitter.call(this);

  // Server instance id
  this.id = id++;

  // Internal state
  this.s = ***REMOVED***
    // Options
    options: options,
    // Logger
    logger: Logger('Server', options),
    // Factory overrides
    Cursor: options.cursorFactory || BasicCursor,
    // BSON instance
    bson: options.bson || new BSON([BSON.Binary, BSON.Code, BSON.DBRef, BSON.Decimal128,
      BSON.Double, BSON.Int32, BSON.Long, BSON.Map, BSON.MaxKey, BSON.MinKey,
      BSON.ObjectId, BSON.BSONRegExp, BSON.Symbol, BSON.Timestamp]),
    // Pool
    pool: null,
    // Disconnect handler
    disconnectHandler: options.disconnectHandler,
    // Monitor thread (keeps the connection alive)
    monitoring: typeof options.monitoring == 'boolean' ? options.monitoring : true,
    // Is the server in a topology
    inTopology: typeof options.inTopology == 'boolean' ? options.inTopology : false,
    // Monitoring timeout
    monitoringInterval: typeof options.monitoringInterval == 'number'
      ? options.monitoringInterval
      : 5000,
    // Topology id
    topologyId: -1
  ***REMOVED***

  // Curent ismaster
  this.ismaster = null;
  // Current ping time
  this.lastIsMasterMS = -1;
  // The monitoringProcessId
  this.monitoringProcessId = null;
  // Initial connection
  this.initalConnect = true;
  // Wire protocol handler, default to oldest known protocol handler
  // this gets changed when the first ismaster is called.
  this.wireProtocolHandler = new PreTwoSixWireProtocolSupport();
  // Default type
  this._type = 'server';
  // Set the client info
  this.clientInfo = createClientInfo(options);

  // Max Stalleness values
  // last time we updated the ismaster state
  this.lastUpdateTime = 0;
  // Last write time
  this.lastWriteDate = 0;
  // Stalleness
  this.staleness = 0;
***REMOVED***

inherits(Server, EventEmitter);

Object.defineProperty(Server.prototype, 'type', ***REMOVED***
  enumerable:true, get: function() ***REMOVED*** return this._type; ***REMOVED***
***REMOVED***);

Object.defineProperty(Server.prototype, 'parserType', ***REMOVED***
  enumerable:true, get: function() ***REMOVED***
    return BSON.native ? "c++" : "js";
  ***REMOVED***
***REMOVED***);

Server.enableServerAccounting = function() ***REMOVED***
  serverAccounting = true;
  servers = ***REMOVED******REMOVED***;
***REMOVED***

Server.disableServerAccounting = function() ***REMOVED***
  serverAccounting = false;
***REMOVED***

Server.servers = function() ***REMOVED***
  return servers;
***REMOVED***

Object.defineProperty(Server.prototype, 'name', ***REMOVED***
  enumerable:true,
  get: function() ***REMOVED*** return this.s.options.host + ":" + this.s.options.port; ***REMOVED***
***REMOVED***);

function configureWireProtocolHandler(self, ismaster) ***REMOVED***
  // 3.2 wire protocol handler
  if(ismaster.maxWireVersion >= 4) ***REMOVED***
    return new ThreeTwoWireProtocolSupport(new TwoSixWireProtocolSupport());
  ***REMOVED***

  // 2.6 wire protocol handler
  if(ismaster.maxWireVersion >= 2) ***REMOVED***
    return new TwoSixWireProtocolSupport();
  ***REMOVED***

  // 2.4 or earlier wire protocol handler
  return new PreTwoSixWireProtocolSupport();
***REMOVED***

function disconnectHandler(self, type, ns, cmd, options, callback) ***REMOVED***
  // Topology is not connected, save the call in the provided store to be
  // Executed at some point when the handler deems it's reconnected
  if(!self.s.pool.isConnected() && self.s.disconnectHandler != null && !options.monitoring) ***REMOVED***
    self.s.disconnectHandler.add(type, ns, cmd, options, callback);
    return true;
  ***REMOVED***

  // If we have no connection error
  if(!self.s.pool.isConnected()) ***REMOVED***
    callback(MongoError.create(f("no connection available to server %s", self.name)));
    return true;
  ***REMOVED***
***REMOVED***

function monitoringProcess(self) ***REMOVED***
  return function() ***REMOVED***
    // Pool was destroyed do not continue process
    if(self.s.pool.isDestroyed()) return;
    // Emit monitoring Process event
    self.emit('monitoring', self);
    // Perform ismaster call
    // Query options
    var queryOptions = ***REMOVED*** numberToSkip: 0, numberToReturn: -1, checkKeys: false, slaveOk: true ***REMOVED***;
    // Create a query instance
    var query = new Query(self.s.bson, 'admin.$cmd', ***REMOVED***ismaster:true***REMOVED***, queryOptions);
    // Get start time
    var start = new Date().getTime();
    // Execute the ismaster query
    self.s.pool.write(query, ***REMOVED***
      socketTimeout: self.s.options.connectionTimeout || 2000,
    ***REMOVED***, function(err, result) ***REMOVED***
      // Set initial lastIsMasterMS
      self.lastIsMasterMS = new Date().getTime() - start;
      if(self.s.pool.isDestroyed()) return;
      // Update the ismaster view if we have a result
      if(result) ***REMOVED***
        self.ismaster = result.result;
      ***REMOVED***
      // Re-schedule the monitoring process
      self.monitoringProcessId = setTimeout(monitoringProcess(self), self.s.monitoringInterval);
    ***REMOVED***);
  ***REMOVED***
***REMOVED***

var eventHandler = function(self, event) ***REMOVED***
  return function(err) ***REMOVED***
    // Log information of received information if in info mode
    if(self.s.logger.isInfo()) ***REMOVED***
      var object = err instanceof MongoError ? JSON.stringify(err) : ***REMOVED******REMOVED***
      self.s.logger.info(f('server %s fired event %s out with message %s'
        , self.name, event, object));
    ***REMOVED***

    // Handle connect event
    if(event == 'connect') ***REMOVED***
      // Issue an ismaster command at connect
      // Query options
      var queryOptions = ***REMOVED*** numberToSkip: 0, numberToReturn: -1, checkKeys: false, slaveOk: true ***REMOVED***;
      // Create a query instance
      var query = new Query(self.s.bson, 'admin.$cmd', ***REMOVED***ismaster:true, client: self.clientInfo***REMOVED***, queryOptions);
      // Get start time
      var start = new Date().getTime();
      // Execute the ismaster query
      self.s.pool.write(query, ***REMOVED***
        socketTimeout: self.s.options.connectionTimeout || 2000,
      ***REMOVED***, function(err, result) ***REMOVED***
        // Set initial lastIsMasterMS
        self.lastIsMasterMS = new Date().getTime() - start;
        if(err) ***REMOVED***
          self.destroy();
          if(self.listeners('error').length > 0) self.emit('error', err);
          return;
        ***REMOVED***

        // Ensure no error emitted after initial connect when reconnecting
        self.initalConnect = false;
        // Save the ismaster
        self.ismaster = result.result;

        // It's a proxy change the type so
        // the wireprotocol will send $readPreference
        if(self.ismaster.msg == 'isdbgrid') ***REMOVED***
          self._type = 'mongos';
        ***REMOVED***
        // Add the correct wire protocol handler
        self.wireProtocolHandler = configureWireProtocolHandler(self, self.ismaster);
        // Have we defined self monitoring
        if(self.s.monitoring) ***REMOVED***
          self.monitoringProcessId = setTimeout(monitoringProcess(self), self.s.monitoringInterval);
        ***REMOVED***

        // Emit server description changed if something listening
        sdam.emitServerDescriptionChanged(self, ***REMOVED***
          address: self.name, arbiters: [], hosts: [], passives: [], type: !self.s.inTopology ? 'Standalone' : sdam.getTopologyType(self)
        ***REMOVED***);

        // Emit topology description changed if something listening
        sdam.emitTopologyDescriptionChanged(self, ***REMOVED***
          topologyType: 'Single', servers: [***REMOVED***address: self.name, arbiters: [], hosts: [], passives: [], type: 'Standalone'***REMOVED***]
        ***REMOVED***);

        // Log the ismaster if available
        if(self.s.logger.isInfo()) ***REMOVED***
          self.s.logger.info(f('server %s connected with ismaster [%s]', self.name, JSON.stringify(self.ismaster)));
        ***REMOVED***

        // Emit connect
        self.emit('connect', self);
      ***REMOVED***);
    ***REMOVED*** else if(event == 'error' || event == 'parseError'
      || event == 'close' || event == 'timeout' || event == 'reconnect'
      || event == 'attemptReconnect' || 'reconnectFailed') ***REMOVED***
      // Remove server instance from accounting
      if(serverAccounting && ['close', 'timeout', 'error', 'parseError', 'reconnectFailed'].indexOf(event) != -1) ***REMOVED***
        // Emit toplogy opening event if not in topology
        if(!self.s.inTopology) ***REMOVED***
          self.emit('topologyOpening', ***REMOVED*** topologyId: self.id ***REMOVED***);
        ***REMOVED***

        delete servers[self.id];
      ***REMOVED***

      // Reconnect failed return error
      if(event == 'reconnectFailed') ***REMOVED***
        self.emit('reconnectFailed', err);
        // Emit error if any listeners
        if(self.listeners('error').length > 0) ***REMOVED***
          self.emit('error', err);
        ***REMOVED***
        // Terminate
        return;
      ***REMOVED***

      // On first connect fail
      if(self.s.pool.state == 'disconnected' && self.initalConnect && ['close', 'timeout', 'error', 'parseError'].indexOf(event) != -1) ***REMOVED***
        self.initalConnect = false;
        return self.emit('error', new MongoError(f('failed to connect to server [%s] on first connect', self.name)));
      ***REMOVED***

      // Reconnect event, emit the server
      if(event == 'reconnect') ***REMOVED***
        return self.emit(event, self);
      ***REMOVED***

      // Emit the event
      self.emit(event, err);
    ***REMOVED***
  ***REMOVED***
***REMOVED***

/**
 * Initiate server connect
 * @method
 * @param ***REMOVED***array***REMOVED*** [options.auth=null] Array of auth options to apply on connect
 */
Server.prototype.connect = function(options) ***REMOVED***
  var self = this;
  options = options || ***REMOVED******REMOVED***;

  // Set the connections
  if(serverAccounting) servers[this.id] = this;

  // Do not allow connect to be called on anything that's not disconnected
  if(self.s.pool && !self.s.pool.isDisconnected() && !self.s.pool.isDestroyed()) ***REMOVED***
    throw MongoError.create(f('server instance in invalid state %s', self.s.state));
  ***REMOVED***

  // Create a pool
  self.s.pool = new Pool(assign(self.s.options, options, ***REMOVED***bson: this.s.bson***REMOVED***));

  // Set up listeners
  self.s.pool.on('close', eventHandler(self, 'close'));
  self.s.pool.on('error', eventHandler(self, 'error'));
  self.s.pool.on('timeout', eventHandler(self, 'timeout'));
  self.s.pool.on('parseError', eventHandler(self, 'parseError'));
  self.s.pool.on('connect', eventHandler(self, 'connect'));
  self.s.pool.on('reconnect', eventHandler(self, 'reconnect'));
  self.s.pool.on('reconnectFailed', eventHandler(self, 'reconnectFailed'));

  // Emit toplogy opening event if not in topology
  if(!self.s.inTopology) ***REMOVED***
    this.emit('topologyOpening', ***REMOVED*** topologyId: self.id ***REMOVED***);
  ***REMOVED***

  // Emit opening server event
  self.emit('serverOpening', ***REMOVED***
    topologyId: self.s.topologyId != -1 ? self.s.topologyId : self.id,
    address: self.name
  ***REMOVED***);

  // Connect with optional auth settings
  if(options.auth) ***REMOVED***
    self.s.pool.connect.apply(self.s.pool, options.auth);
  ***REMOVED*** else ***REMOVED***
    self.s.pool.connect();
  ***REMOVED***
***REMOVED***

/**
 * Get the server description
 * @method
 * @return ***REMOVED***object***REMOVED***
*/
Server.prototype.getDescription = function() ***REMOVED***
  var ismaster = this.ismaster || ***REMOVED******REMOVED***;
  var description = ***REMOVED***
    type: sdam.getTopologyType(this),
    address: this.name,
  ***REMOVED***;

  // Add fields if available
  if(ismaster.hosts) description.hosts = ismaster.hosts;
  if(ismaster.arbiters) description.arbiters = ismaster.arbiters;
  if(ismaster.passives) description.passives = ismaster.passives;
  if(ismaster.setName) description.setName = ismaster.setName;
  return description;
***REMOVED***

/**
 * Returns the last known ismaster document for this server
 * @method
 * @return ***REMOVED***object***REMOVED***
 */
Server.prototype.lastIsMaster = function() ***REMOVED***
  return this.ismaster;
***REMOVED***

/**
 * Unref all connections belong to this server
 * @method
 */
Server.prototype.unref = function() ***REMOVED***
  this.s.pool.unref();
***REMOVED***

/**
 * Figure out if the server is connected
 * @method
 * @return ***REMOVED***boolean***REMOVED***
 */
Server.prototype.isConnected = function() ***REMOVED***
  if(!this.s.pool) return false;
  return this.s.pool.isConnected();
***REMOVED***

/**
 * Figure out if the server instance was destroyed by calling destroy
 * @method
 * @return ***REMOVED***boolean***REMOVED***
 */
Server.prototype.isDestroyed = function() ***REMOVED***
  if(!this.s.pool) return false;
  return this.s.pool.isDestroyed();
***REMOVED***

function basicWriteValidations(self) ***REMOVED***
  if(!self.s.pool) return MongoError.create('server instance is not connected');
  if(self.s.pool.isDestroyed()) return MongoError.create('server instance pool was destroyed');
***REMOVED***

function basicReadValidations(self, options) ***REMOVED***
  basicWriteValidations(self, options);

  if(options.readPreference && !(options.readPreference instanceof ReadPreference)) ***REMOVED***
    throw new Error("readPreference must be an instance of ReadPreference");
  ***REMOVED***
***REMOVED***

/**
 * Execute a command
 * @method
 * @param ***REMOVED***string***REMOVED*** ns The MongoDB fully qualified namespace (ex: db1.collection1)
 * @param ***REMOVED***object***REMOVED*** cmd The command hash
 * @param ***REMOVED***ReadPreference***REMOVED*** [options.readPreference] Specify read preference if command supports it
 * @param ***REMOVED***Boolean***REMOVED*** [options.serializeFunctions=false] Specify if functions on an object should be serialized.
 * @param ***REMOVED***Boolean***REMOVED*** [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
 * @param ***REMOVED***Boolean***REMOVED*** [options.fullResult=false] Return the full envelope instead of just the result document.
 * @param ***REMOVED***opResultCallback***REMOVED*** callback A callback function
 */
Server.prototype.command = function(ns, cmd, options, callback) ***REMOVED***
  var self = this;
  if(typeof options == 'function') callback = options, options = ***REMOVED******REMOVED***, options = options || ***REMOVED******REMOVED***;
  var result = basicReadValidations(self, options);
  if(result) return callback(result);

  // Debug log
  if(self.s.logger.isDebug()) self.s.logger.debug(f('executing command [%s] against %s', JSON.stringify(***REMOVED***
    ns: ns, cmd: cmd, options: debugOptions(debugFields, options)
  ***REMOVED***), self.name));

  // If we are not connected or have a disconnectHandler specified
  if(disconnectHandler(self, 'command', ns, cmd, options, callback)) return;

  // Check if we have collation support
  if(this.ismaster && this.ismaster.maxWireVersion < 5 && cmd.collation) ***REMOVED***
    return callback(new MongoError(f('server %s does not support collation', this.name)));
  ***REMOVED***

  // Query options
  var queryOptions = ***REMOVED***
    numberToSkip: 0,
    numberToReturn: -1,
    checkKeys: typeof options.checkKeys == 'boolean' ? options.checkKeys: false,
    serializeFunctions: typeof options.serializeFunctions == 'boolean' ? options.serializeFunctions : false,
    ignoreUndefined: typeof options.ignoreUndefined == 'boolean' ? options.ignoreUndefined : false
  ***REMOVED***;

  // Create a query instance
  var query = new Query(self.s.bson, ns, cmd, queryOptions);
  // Set slave OK of the query
  query.slaveOk = options.readPreference ? options.readPreference.slaveOk() : false;

  // Write options
  var writeOptions = ***REMOVED***
    raw: typeof options.raw == 'boolean' ? options.raw : false,
    promoteLongs: typeof options.promoteLongs == 'boolean' ? options.promoteLongs : true,
    promoteValues: typeof options.promoteValues == 'boolean' ? options.promoteValues : true,
    promoteBuffers: typeof options.promoteBuffers == 'boolean' ? options.promoteBuffers : false,
    command: true,
    monitoring: typeof options.monitoring == 'boolean' ? options.monitoring : false,
    fullResult: typeof options.fullResult == 'boolean' ? options.fullResult : false,
    requestId: query.requestId,
    socketTimeout: typeof options.socketTimeout == 'number' ? options.socketTimeout : null,
  ***REMOVED***;

  // Write the operation to the pool
  self.s.pool.write(query, writeOptions, callback);
***REMOVED***

/**
 * Insert one or more documents
 * @method
 * @param ***REMOVED***string***REMOVED*** ns The MongoDB fully qualified namespace (ex: db1.collection1)
 * @param ***REMOVED***array***REMOVED*** ops An array of documents to insert
 * @param ***REMOVED***boolean***REMOVED*** [options.ordered=true] Execute in order or out of order
 * @param ***REMOVED***object***REMOVED*** [options.writeConcern=***REMOVED******REMOVED***] Write concern for the operation
 * @param ***REMOVED***Boolean***REMOVED*** [options.serializeFunctions=false] Specify if functions on an object should be serialized.
 * @param ***REMOVED***Boolean***REMOVED*** [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
 * @param ***REMOVED***opResultCallback***REMOVED*** callback A callback function
 */
Server.prototype.insert = function(ns, ops, options, callback) ***REMOVED***
  var self = this;
  if(typeof options == 'function') callback = options, options = ***REMOVED******REMOVED***, options = options || ***REMOVED******REMOVED***;
  var result = basicWriteValidations(self, options);
  if(result) return callback(result);

  // If we are not connected or have a disconnectHandler specified
  if(disconnectHandler(self, 'insert', ns, ops, options, callback)) return;

  // Setup the docs as an array
  ops = Array.isArray(ops) ? ops : [ops];

  // Execute write
  return self.wireProtocolHandler.insert(self.s.pool, self.ismaster, ns, self.s.bson, ops, options, callback);
***REMOVED***

/**
 * Perform one or more update operations
 * @method
 * @param ***REMOVED***string***REMOVED*** ns The MongoDB fully qualified namespace (ex: db1.collection1)
 * @param ***REMOVED***array***REMOVED*** ops An array of updates
 * @param ***REMOVED***boolean***REMOVED*** [options.ordered=true] Execute in order or out of order
 * @param ***REMOVED***object***REMOVED*** [options.writeConcern=***REMOVED******REMOVED***] Write concern for the operation
 * @param ***REMOVED***Boolean***REMOVED*** [options.serializeFunctions=false] Specify if functions on an object should be serialized.
 * @param ***REMOVED***Boolean***REMOVED*** [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
 * @param ***REMOVED***opResultCallback***REMOVED*** callback A callback function
 */
Server.prototype.update = function(ns, ops, options, callback) ***REMOVED***
  var self = this;
  if(typeof options == 'function') callback = options, options = ***REMOVED******REMOVED***, options = options || ***REMOVED******REMOVED***;
  var result = basicWriteValidations(self, options);
  if(result) return callback(result);

  // If we are not connected or have a disconnectHandler specified
  if(disconnectHandler(self, 'update', ns, ops, options, callback)) return;

  // Check if we have collation support
  if(this.ismaster && this.ismaster.maxWireVersion < 5 && options.collation) ***REMOVED***
    return callback(new MongoError(f('server %s does not support collation', this.name)));
  ***REMOVED***

  // Setup the docs as an array
  ops = Array.isArray(ops) ? ops : [ops];
  // Execute write
  return self.wireProtocolHandler.update(self.s.pool, self.ismaster, ns, self.s.bson, ops, options, callback);
***REMOVED***

/**
 * Perform one or more remove operations
 * @method
 * @param ***REMOVED***string***REMOVED*** ns The MongoDB fully qualified namespace (ex: db1.collection1)
 * @param ***REMOVED***array***REMOVED*** ops An array of removes
 * @param ***REMOVED***boolean***REMOVED*** [options.ordered=true] Execute in order or out of order
 * @param ***REMOVED***object***REMOVED*** [options.writeConcern=***REMOVED******REMOVED***] Write concern for the operation
 * @param ***REMOVED***Boolean***REMOVED*** [options.serializeFunctions=false] Specify if functions on an object should be serialized.
 * @param ***REMOVED***Boolean***REMOVED*** [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
 * @param ***REMOVED***opResultCallback***REMOVED*** callback A callback function
 */
Server.prototype.remove = function(ns, ops, options, callback) ***REMOVED***
  var self = this;
  if(typeof options == 'function') callback = options, options = ***REMOVED******REMOVED***, options = options || ***REMOVED******REMOVED***;
  var result = basicWriteValidations(self, options);
  if(result) return callback(result);

  // If we are not connected or have a disconnectHandler specified
  if(disconnectHandler(self, 'remove', ns, ops, options, callback)) return;

  // Check if we have collation support
  if(this.ismaster && this.ismaster.maxWireVersion < 5 && options.collation) ***REMOVED***
    return callback(new MongoError(f('server %s does not support collation', this.name)));
  ***REMOVED***

  // Setup the docs as an array
  ops = Array.isArray(ops) ? ops : [ops];
  // Execute write
  return self.wireProtocolHandler.remove(self.s.pool, self.ismaster, ns, self.s.bson, ops, options, callback);
***REMOVED***

/**
 * Get a new cursor
 * @method
 * @param ***REMOVED***string***REMOVED*** ns The MongoDB fully qualified namespace (ex: db1.collection1)
 * @param ***REMOVED******REMOVED***object***REMOVED***|***REMOVED***Long***REMOVED******REMOVED*** cmd Can be either a command returning a cursor or a cursorId
 * @param ***REMOVED***object***REMOVED*** [options.batchSize=0] Batchsize for the operation
 * @param ***REMOVED***array***REMOVED*** [options.documents=[]] Initial documents list for cursor
 * @param ***REMOVED***ReadPreference***REMOVED*** [options.readPreference] Specify read preference if command supports it
 * @param ***REMOVED***Boolean***REMOVED*** [options.serializeFunctions=false] Specify if functions on an object should be serialized.
 * @param ***REMOVED***Boolean***REMOVED*** [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
 * @param ***REMOVED***opResultCallback***REMOVED*** callback A callback function
 */
Server.prototype.cursor = function(ns, cmd, cursorOptions) ***REMOVED***
  var s = this.s;
  cursorOptions = cursorOptions || ***REMOVED******REMOVED***;
  // Set up final cursor type
  var FinalCursor = cursorOptions.cursorFactory || s.Cursor;
  // Return the cursor
  return new FinalCursor(s.bson, ns, cmd, cursorOptions, this, s.options);
***REMOVED***

/**
 * Logout from a database
 * @method
 * @param ***REMOVED***string***REMOVED*** db The db we are logging out from
 * @param ***REMOVED***authResultCallback***REMOVED*** callback A callback function
 */
Server.prototype.logout = function(dbName, callback) ***REMOVED***
  this.s.pool.logout(dbName, callback);
***REMOVED***

/**
 * Authenticate using a specified mechanism
 * @method
 * @param ***REMOVED***string***REMOVED*** mechanism The Auth mechanism we are invoking
 * @param ***REMOVED***string***REMOVED*** db The db we are invoking the mechanism against
 * @param ***REMOVED***...object***REMOVED*** param Parameters for the specific mechanism
 * @param ***REMOVED***authResultCallback***REMOVED*** callback A callback function
 */
Server.prototype.auth = function(mechanism, db) ***REMOVED***
  var self = this;

  // If we have the default mechanism we pick mechanism based on the wire
  // protocol max version. If it's >= 3 then scram-sha1 otherwise mongodb-cr
  if(mechanism == 'default' && self.ismaster && self.ismaster.maxWireVersion >= 3) ***REMOVED***
    mechanism = 'scram-sha-1';
  ***REMOVED*** else if(mechanism == 'default') ***REMOVED***
    mechanism = 'mongocr';
  ***REMOVED***

  // Slice all the arguments off
  var args = Array.prototype.slice.call(arguments, 0);
  // Set the mechanism
  args[0] = mechanism;
  // Get the callback
  var callback = args[args.length - 1];

  // If we are not connected or have a disconnectHandler specified
  if(disconnectHandler(self, 'auth', db, args, ***REMOVED******REMOVED***, callback)) ***REMOVED***
    return;
  ***REMOVED***

  // Do not authenticate if we are an arbiter
  if(this.lastIsMaster() && this.lastIsMaster().arbiterOnly) ***REMOVED***
    return callback(null, true);
  ***REMOVED***

  // Apply the arguments to the pool
  self.s.pool.auth.apply(self.s.pool, args);
***REMOVED***

/**
 * Compare two server instances
 * @method
 * @param ***REMOVED***Server***REMOVED*** server Server to compare equality against
 * @return ***REMOVED***boolean***REMOVED***
 */
Server.prototype.equals = function(server) ***REMOVED***
  if(typeof server == 'string') return this.name == server;
  if(server.name) return this.name == server.name;
  return false;
***REMOVED***

/**
 * All raw connections
 * @method
 * @return ***REMOVED***Connection[]***REMOVED***
 */
Server.prototype.connections = function() ***REMOVED***
  return this.s.pool.allConnections();
***REMOVED***

/**
 * Get server
 * @method
 * @return ***REMOVED***Server***REMOVED***
 */
Server.prototype.getServer = function() ***REMOVED***
  return this;
***REMOVED***

/**
 * Get connection
 * @method
 * @return ***REMOVED***Connection***REMOVED***
 */
Server.prototype.getConnection = function() ***REMOVED***
  return this.s.pool.get();
***REMOVED***

var listeners = ['close', 'error', 'timeout', 'parseError', 'connect'];

/**
 * Destroy the server connection
 * @method
 * @param ***REMOVED***boolean***REMOVED*** [options.emitClose=false] Emit close event on destroy
 * @param ***REMOVED***boolean***REMOVED*** [options.emitDestroy=false] Emit destroy event on destroy
 * @param ***REMOVED***boolean***REMOVED*** [options.force=false] Force destroy the pool
 */
Server.prototype.destroy = function(options) ***REMOVED***
  options = options || ***REMOVED******REMOVED***;
  var self = this;

  // Set the connections
  if(serverAccounting) delete servers[this.id];

  // Destroy the monitoring process if any
  if(this.monitoringProcessId) ***REMOVED***
    clearTimeout(this.monitoringProcessId);
  ***REMOVED***

  // Emit close event
  if(options.emitClose) ***REMOVED***
    self.emit('close', self);
  ***REMOVED***

  // Emit destroy event
  if(options.emitDestroy) ***REMOVED***
    self.emit('destroy', self);
  ***REMOVED***

  // Remove all listeners
  listeners.forEach(function(event) ***REMOVED***
    self.s.pool.removeAllListeners(event);
  ***REMOVED***);

  // Emit opening server event
  if(self.listeners('serverClosed').length > 0) self.emit('serverClosed', ***REMOVED***
    topologyId: self.s.topologyId != -1 ? self.s.topologyId : self.id, address: self.name
  ***REMOVED***);

  // Emit toplogy opening event if not in topology
  if(self.listeners('topologyClosed').length > 0 && !self.s.inTopology) ***REMOVED***
    self.emit('topologyClosed', ***REMOVED*** topologyId: self.id ***REMOVED***);
  ***REMOVED***

  if(self.s.logger.isDebug()) ***REMOVED***
    self.s.logger.debug(f('destroy called on server %s', self.name));
  ***REMOVED***

  // Destroy the pool
  this.s.pool.destroy(options.force);
***REMOVED***

/**
 * A server connect event, used to verify that the connection is up and running
 *
 * @event Server#connect
 * @type ***REMOVED***Server***REMOVED***
 */

/**
 * A server reconnect event, used to verify that the server topology has reconnected
 *
 * @event Server#reconnect
 * @type ***REMOVED***Server***REMOVED***
 */

/**
 * A server opening SDAM monitoring event
 *
 * @event Server#serverOpening
 * @type ***REMOVED***object***REMOVED***
 */

/**
 * A server closed SDAM monitoring event
 *
 * @event Server#serverClosed
 * @type ***REMOVED***object***REMOVED***
 */

/**
 * A server description SDAM change monitoring event
 *
 * @event Server#serverDescriptionChanged
 * @type ***REMOVED***object***REMOVED***
 */

/**
 * A topology open SDAM event
 *
 * @event Server#topologyOpening
 * @type ***REMOVED***object***REMOVED***
 */

/**
 * A topology closed SDAM event
 *
 * @event Server#topologyClosed
 * @type ***REMOVED***object***REMOVED***
 */

/**
 * A topology structure SDAM change event
 *
 * @event Server#topologyDescriptionChanged
 * @type ***REMOVED***object***REMOVED***
 */

/**
 * Server reconnect failed
 *
 * @event Server#reconnectFailed
 * @type ***REMOVED***Error***REMOVED***
 */

/**
 * Server connection pool closed
 *
 * @event Server#close
 * @type ***REMOVED***object***REMOVED***
 */

/**
 * Server connection pool caused an error
 *
 * @event Server#error
 * @type ***REMOVED***Error***REMOVED***
 */

/**
 * Server destroyed was called
 *
 * @event Server#destroy
 * @type ***REMOVED***Server***REMOVED***
 */

module.exports = Server;
